diff --git a/drivers/Kconfig b/drivers/Kconfig
index ba2901e76769..2bfbf104c650 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -12,6 +12,8 @@ source "drivers/mtd/Kconfig"
 
 source "drivers/of/Kconfig"
 
+source "drivers/stromer/Kconfig"
+
 source "drivers/parport/Kconfig"
 
 source "drivers/pnp/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index cfabd141dba2..0d91c8a03228 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -8,6 +8,8 @@
 obj-y				+= irqchip/
 obj-y				+= bus/
 
+obj-y				+= stromer/
+
 obj-$(CONFIG_GENERIC_PHY)	+= phy/
 
 # GPIO must come after pinctrl as gpios may need to mux pins etc
diff --git a/drivers/stromer/Kconfig b/drivers/stromer/Kconfig
new file mode 100644
index 000000000000..428465c13f1f
--- /dev/null
+++ b/drivers/stromer/Kconfig
@@ -0,0 +1,31 @@
+
+menuconfig STROMER_DP
+	tristate "myStromer SUI - Display und Touch driver"
+	---help---
+	  Framebuffer driver for the IMX6UL LCDIF periphery in combination
+	  with the ST7789 based display
+
+if STROMER_DP
+
+config ST1633_TOUCH
+	tristate "ST1633 touch controller driver"
+	default m
+	help
+	  ST1633 Touch controller driver using I2C interfaces
+
+config IMX6UL_LCDIF_ST7789
+	tristate "LCDIF peripheral driver for a ST7789 display"
+	default y
+	help
+	  LCDIF driver for IMX6UL for usage with a ST7789 based
+	  display
+
+config ST7789_SPI
+	tristate "ST7789 - Supports spi init functionality required for RGB interface"
+	default y
+	depends on IMX6UL_LCDIF_ST7789
+	help
+	  SPI driver for the ST7789 3-wire interface (1. SCL, 2. CS, 3. MISO/MOSI)
+	  providing functions to inititalize the display for RGB interface
+
+endif #STROMER_DP
diff --git a/drivers/stromer/Makefile b/drivers/stromer/Makefile
new file mode 100644
index 000000000000..b4feb388e860
--- /dev/null
+++ b/drivers/stromer/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_ST1633_TOUCH)         += st1633.o
+obj-$(CONFIG_IMX6UL_LCDIF_ST7789)  += fb_imx6_lcdif.o
+obj-$(CONFIG_ST7789_SPI)           += fb_imx6_st7789_spi.o
diff --git a/drivers/stromer/fb_imx6.h b/drivers/stromer/fb_imx6.h
new file mode 100644
index 000000000000..13be4b5037dc
--- /dev/null
+++ b/drivers/stromer/fb_imx6.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2017 Christian Duenki, Escatec Switzerland AG
+ */
+
+/* #define DEBUG */
+
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+/** SPI driver name */
+#define SPI_DRIVER_NAME "st7789v"
+
+/** Perform SPI init sequence */
+#define DO_SPI_INIT_SEQUENCE
+/** Do panning in spi driver */
+#define DO_SPI_PAN
+/** Register SPI device */
+#define DO_REGISTER_SPI_DEVICE
+/** Do panning in lcdif driver */
+//#define DO_LCDIF_PAN
+
+/** Reset pin responsibility */
+/* define RESET_DONE_BY_LCDIF */
+
+#if defined (RESET_DONE_BY_LCDIF)
+ #define GPIO_LCDIF_RESET  (int)68
+#else
+ #define GPIO_SPI_RESET    (int)68
+#endif
+
+#define NUMARGS(...) (sizeof((int[]){__VA_ARGS__})/sizeof(int))
+
+#define st7789_write_reg(...)				\
+	st7789_write_register(NUMARGS(__VA_ARGS__), __VA_ARGS__)
+
+struct mxsfb_info {
+	struct fb_info fb_info;
+	struct platform_device *pdev;
+	struct clk *clk;
+	struct clk *clk_axi;
+	struct clk *clk_disp_axi;
+	void __iomem *base;	/* registers */
+	unsigned allocated_size;
+	int enabled;
+	unsigned ld_intf_width;
+	unsigned dotclk_delay;
+	const struct mxsfb_devdata *devdata;
+	u32 sync;
+	struct regulator *reg_lcd;
+#if defined (GPIO_LCDIF_RESET)
+	int gpio_reset;
+#endif
+};
diff --git a/drivers/stromer/fb_imx6_lcdif.c b/drivers/stromer/fb_imx6_lcdif.c
new file mode 100644
index 000000000000..006252042d2d
--- /dev/null
+++ b/drivers/stromer/fb_imx6_lcdif.c
@@ -0,0 +1,1015 @@
+/*
+ * Copyright (C) 2017 Christian Duenki, Escatec Switzerland AG
+ *
+ * This code is based on:
+ * Author: Juefgen Beisert, Pengutronix
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ */
+/**
+ * @file
+ * @brief LCDIF driver for i.MX6UL (based on mxsfb.c)
+ *
+ * Only the Dotclock mode of the LCDIF is implemented (RGB interface)
+ *
+ * This driver depends on a correct setup of the pins used for this purpose
+ * (platform specific).
+ *
+ * For the developer: Don't forget to set the data bus width to the display
+ * in the imx_fb_videomode structure. You will else end up with ugly colours.
+ * If you fight against jitter you can vary the clock delay. This is a feature
+ * of the i.MX6 and you can vary it between 2 ns ... 8 ns in 2 ns steps. Give
+ * the required value in the imx_fb_videomode structure.
+ */
+
+#include "fb_imx6.h"
+
+#define DRIVER_NAME "mxsfb_st7789"
+
+/* LCDIF part */
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/regulator/consumer.h>
+#include <video/of_display_timing.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+#include <linux/export.h>
+#if defined (GPIO_LCDIF_RESET)
+ #include <linux/gpio.h>
+ #include <linux/delay.h>
+#endif
+
+/* SPI */
+#include <linux/spi/spi.h>
+
+#define REG_SET	4
+#define REG_CLR	8
+
+#define LCDC_CTRL			0x00
+#define LCDC_CTRL1			0x10
+#define LCDC_V4_CTRL2			0x20
+#define LCDC_V4_TRANSFER_COUNT		0x30
+#define LCDC_V4_CUR_BUF			0x40
+#define LCDC_V4_NEXT_BUF		0x50
+#define LCDC_TIMING			0x60
+#define LCDC_VDCTRL0			0x70
+#define LCDC_VDCTRL1			0x80
+#define LCDC_VDCTRL2			0x90
+#define LCDC_VDCTRL3			0xa0
+#define LCDC_VDCTRL4			0xb0
+#define LCDC_DVICTRL0			0xc0
+#define LCDC_DVICTRL1			0xd0
+#define LCDC_DVICTRL2			0xe0
+#define LCDC_DVICTRL3			0xf0
+#define LCDC_DVICTRL4			0x100
+#define LCDC_V4_DATA			0x180
+#define LCDC_V4_DEBUG0			0x1d0
+
+#define CTRL_SFTRST			(1 << 31)
+#define CTRL_CLKGATE			(1 << 30)
+#define CTRL_BYPASS_COUNT		(1 << 19)
+#define CTRL_VSYNC_MODE			(1 << 18)
+#define CTRL_DOTCLK_MODE		(1 << 17)
+#define CTRL_DATA_SELECT		(1 << 16)
+#define CTRL_SET_BUS_WIDTH(x)		(((x) & 0x3) << 10)
+#define CTRL_GET_BUS_WIDTH(x)		(((x) >> 10) & 0x3)
+#define CTRL_SET_WORD_LENGTH(x)		(((x) & 0x3) << 8)
+#define CTRL_GET_WORD_LENGTH(x)		(((x) >> 8) & 0x3)
+#define CTRL_MASTER			(1 << 5)
+#define CTRL_DF16			(1 << 3)
+#define CTRL_DF18			(1 << 2)
+#define CTRL_DF24			(1 << 1)
+#define CTRL_RUN			(1 << 0)
+
+#define CTRL1_FIFO_CLEAR		(1 << 21)
+#define CTRL1_SET_BYTE_PACKAGING(x)	(((x) & 0xf) << 16)
+#define CTRL1_GET_BYTE_PACKAGING(x)	(((x) >> 16) & 0xf)
+
+#define TRANSFER_COUNT_SET_VCOUNT(x)	(((x) & 0xffff) << 16)
+#define TRANSFER_COUNT_GET_VCOUNT(x)	(((x) >> 16) & 0xffff)
+#define TRANSFER_COUNT_SET_HCOUNT(x)	((x) & 0xffff)
+#define TRANSFER_COUNT_GET_HCOUNT(x)	((x) & 0xffff)
+
+#define VDCTRL0_ENABLE_PRESENT		(1 << 28)
+#define VDCTRL0_VSYNC_ACT_HIGH		(1 << 27)
+#define VDCTRL0_HSYNC_ACT_HIGH		(1 << 26)
+#define VDCTRL0_DOTCLK_ACT_FALLING	(1 << 25)
+#define VDCTRL0_ENABLE_ACT_HIGH		(1 << 24)
+#define VDCTRL0_VSYNC_PERIOD_UNIT	(1 << 21)
+#define VDCTRL0_VSYNC_PULSE_WIDTH_UNIT	(1 << 20)
+#define VDCTRL0_HALF_LINE		(1 << 19)
+#define VDCTRL0_HALF_LINE_MODE		(1 << 18)
+#define VDCTRL0_SET_VSYNC_PULSE_WIDTH(x) ((x) & 0x3ffff)
+#define VDCTRL0_GET_VSYNC_PULSE_WIDTH(x) ((x) & 0x3ffff)
+
+#define VDCTRL2_SET_HSYNC_PERIOD(x)	((x) & 0x3ffff)
+#define VDCTRL2_GET_HSYNC_PERIOD(x)	((x) & 0x3ffff)
+
+#define VDCTRL3_MUX_SYNC_SIGNALS	(1 << 29)
+#define VDCTRL3_VSYNC_ONLY		(1 << 28)
+#define SET_HOR_WAIT_CNT(x)		(((x) & 0xfff) << 16)
+#define GET_HOR_WAIT_CNT(x)		(((x) >> 16) & 0xfff)
+#define SET_VERT_WAIT_CNT(x)		((x) & 0xffff)
+#define GET_VERT_WAIT_CNT(x)		((x) & 0xffff)
+
+#define VDCTRL4_SET_DOTCLK_DLY(x)	(((x) & 0x7) << 29)
+#define VDCTRL4_GET_DOTCLK_DLY(x)	(((x) >> 29) & 0x7)
+#define VDCTRL4_SYNC_SIGNALS_ON		(1 << 18)
+#define SET_DOTCLK_H_VALID_DATA_CNT(x)	((x) & 0x3ffff)
+
+#define DEBUG0_HSYNC			(1 < 26)
+#define DEBUG0_VSYNC			(1 < 25)
+
+#define MIN_XRES			120
+#define MIN_YRES			120
+
+#define RED 0
+#define GREEN 1
+#define BLUE 2
+#define TRANSP 3
+
+#define STMLCDIF_8BIT  1 /** pixel data bus to the display is of 8 bit width */
+#define STMLCDIF_16BIT 0 /** pixel data bus to the display is of 16 bit width */
+#define STMLCDIF_18BIT 2 /** pixel data bus to the display is of 18 bit width */
+#define STMLCDIF_24BIT 3 /** pixel data bus to the display is of 24 bit width */
+
+#define MXSFB_SYNC_DATA_ENABLE_HIGH_ACT	(1 << 6)
+#define MXSFB_SYNC_DOTCLK_FALLING_ACT	(1 << 7) /* negtive edge sampling */
+
+//#define SPI_BUS_SPEED 6500000 /* Max read clock cycle 150 ns -> 6.5 MHz */
+#define SPI_BUS_SPEED 1000000
+#define SPI_BUS 0 /** Bus used for display initialization */
+#define SPI_DISP_CS 0 /** CS on selected SPI bus to access display */
+
+/* CPU dependent register offsets */
+struct mxsfb_devdata {
+	unsigned transfer_count;
+	unsigned cur_buf;
+	unsigned next_buf;
+	unsigned debug0;
+	unsigned hs_wdth_mask;
+	unsigned hs_wdth_shift;
+};
+
+static const struct mxsfb_devdata mxsfb_devdata = {
+	.transfer_count = LCDC_V4_TRANSFER_COUNT,
+	.cur_buf = LCDC_V4_CUR_BUF,
+	.next_buf = LCDC_V4_NEXT_BUF,
+	.debug0 = LCDC_V4_DEBUG0,
+	.hs_wdth_mask = 0x3fff,
+	.hs_wdth_shift = 18,
+};
+
+#define to_imxfb_host(x) (container_of(x, struct mxsfb_info, fb_info))
+
+/* mask and shift depends on architecture */
+static inline u32 set_hsync_pulse_width(struct mxsfb_info *host, unsigned val)
+{
+	return (val & host->devdata->hs_wdth_mask) <<
+		host->devdata->hs_wdth_shift;
+}
+
+static inline u32 get_hsync_pulse_width(struct mxsfb_info *host, unsigned val)
+{
+	return (val >> host->devdata->hs_wdth_shift) &
+		host->devdata->hs_wdth_mask;
+}
+
+static const struct fb_bitfield def_rgb565[] = {
+	[RED] = {
+		.offset = 11,
+		.length = 5,
+	},
+	[GREEN] = {
+		.offset = 5,
+		.length = 6,
+	},
+	[BLUE] = {
+		.offset = 0,
+		.length = 5,
+	},
+	[TRANSP] = {	/* no support for transparency */
+		.length = 0,
+	}
+};
+
+static const struct fb_bitfield def_rgb888[] = {
+	[RED] = {
+		.offset = 16,
+		.length = 8,
+	},
+	[GREEN] = {
+		.offset = 8,
+		.length = 8,
+	},
+	[BLUE] = {
+		.offset = 0,
+		.length = 8,
+	},
+	[TRANSP] = {	/* no support for transparency */
+		.length = 0,
+	}
+};
+
+static inline unsigned chan_to_field(unsigned chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int mxsfb_check_var(struct fb_var_screeninfo *var,
+		struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	const struct fb_bitfield *rgb = NULL;
+
+	if (var->xres < MIN_XRES)
+		var->xres = MIN_XRES;
+	if (var->yres < MIN_YRES)
+		var->yres = MIN_YRES;
+
+	var->xres_virtual = var->xres;
+
+	var->yres_virtual = var->yres;
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		/* always expect RGB 565 */
+		rgb = def_rgb565;
+		break;
+	case 32:
+		switch (host->ld_intf_width) {
+		case STMLCDIF_8BIT:
+			pr_debug("Unsupported LCD bus width mapping\n");
+			break;
+		case STMLCDIF_16BIT:
+		case STMLCDIF_18BIT:
+		case STMLCDIF_24BIT:
+			/* real 24 bit */
+			rgb = def_rgb888;
+			break;
+		}
+		break;
+	default:
+		pr_err("Unsupported colour depth: %u\n", var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	/*
+	 * Copy the RGB parameters for this display
+	 * from the machine specific parameters.
+	 */
+	var->red    = rgb[RED];
+	var->green  = rgb[GREEN];
+	var->blue   = rgb[BLUE];
+	var->transp = rgb[TRANSP];
+
+	return 0;
+}
+
+static inline void mxsfb_enable_axi_clk(struct mxsfb_info *host)
+{
+	if (host->clk_axi)
+		clk_prepare_enable(host->clk_axi);
+}
+
+static inline void mxsfb_disable_axi_clk(struct mxsfb_info *host)
+{
+	if (host->clk_axi)
+		clk_disable_unprepare(host->clk_axi);
+}
+
+void mxsfb_enable_controller(struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	u32 reg;
+	int ret;
+
+	dev_dbg(&host->pdev->dev, "%s\n", __func__);
+
+	if (host->reg_lcd) {
+		ret = regulator_enable(host->reg_lcd);
+		if (ret) {
+			dev_err(&host->pdev->dev,
+				"lcd regulator enable failed:	%d\n", ret);
+			return;
+		}
+	}
+
+	if (host->clk_disp_axi)
+		clk_prepare_enable(host->clk_disp_axi);
+	clk_prepare_enable(host->clk);
+	clk_set_rate(host->clk, PICOS2KHZ(fb_info->var.pixclock) * 1000U);
+
+	mxsfb_enable_axi_clk(host);
+
+	/* if it was disabled, re-enable the mode again */
+	writel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_SET);
+
+	/* enable the SYNC signals first, then the DMA engine */
+	reg = readl(host->base + LCDC_VDCTRL4);
+	reg |= VDCTRL4_SYNC_SIGNALS_ON;
+	writel(reg, host->base + LCDC_VDCTRL4);
+
+	writel(CTRL_RUN, host->base + LCDC_CTRL + REG_SET);
+
+	host->enabled = 1;
+}
+EXPORT_SYMBOL(mxsfb_enable_controller);
+
+void mxsfb_disable_controller(struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	unsigned loop;
+	u32 reg;
+	int ret;
+
+	dev_dbg(&host->pdev->dev, "%s\n", __func__);
+
+	/*
+	 * Even if we disable the controller here, it will still continue
+	 * until its FIFOs are running out of data
+	 */
+	writel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_CLR);
+
+	loop = 1000;
+	while (loop) {
+		reg = readl(host->base + LCDC_CTRL);
+		if (!(reg & CTRL_RUN))
+			break;
+		loop--;
+	}
+
+	reg = readl(host->base + LCDC_VDCTRL4);
+	writel(reg & ~VDCTRL4_SYNC_SIGNALS_ON, host->base + LCDC_VDCTRL4);
+
+	mxsfb_disable_axi_clk(host);
+
+	clk_disable_unprepare(host->clk);
+	if (host->clk_disp_axi)
+		clk_disable_unprepare(host->clk_disp_axi);
+
+	host->enabled = 0;
+
+	if (host->reg_lcd) {
+		ret = regulator_disable(host->reg_lcd);
+		if (ret)
+			dev_err(&host->pdev->dev,
+				"lcd regulator disable failed: %d\n", ret);
+	}
+}
+EXPORT_SYMBOL(mxsfb_disable_controller);
+
+static int mxsfb_set_par(struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	u32 ctrl, vdctrl0, vdctrl4;
+	int line_size, fb_size;
+	int reenable = 0;
+
+	line_size =  fb_info->var.xres * (fb_info->var.bits_per_pixel >> 3);
+	fb_size = fb_info->var.yres_virtual * line_size;
+
+	if (fb_size > fb_info->fix.smem_len)
+		return -ENOMEM;
+
+	fb_info->fix.line_length = line_size;
+
+	/*
+	 * It seems, you can't re-program the controller if it is still running.
+	 * This may lead into shifted pictures (FIFO issue?).
+	 * So, first stop the controller and drain its FIFOs
+	 */
+	if (host->enabled) {
+		reenable = 1;
+		mxsfb_disable_controller(fb_info);
+	}
+
+	mxsfb_enable_axi_clk(host);
+
+	/* clear the FIFOs */
+	writel(CTRL1_FIFO_CLEAR, host->base + LCDC_CTRL1 + REG_SET);
+
+	ctrl = CTRL_BYPASS_COUNT | CTRL_MASTER |
+		CTRL_SET_BUS_WIDTH(host->ld_intf_width);
+
+	switch (fb_info->var.bits_per_pixel) {
+	case 16:
+		dev_dbg(&host->pdev->dev, "Setting up RGB565 mode\n");
+		ctrl |= CTRL_SET_WORD_LENGTH(0);
+		writel(CTRL1_SET_BYTE_PACKAGING(0xf), host->base + LCDC_CTRL1);
+		break;
+	case 32:
+		dev_dbg(&host->pdev->dev, "Setting up RGB888/666 mode\n");
+		ctrl |= CTRL_SET_WORD_LENGTH(3);
+		switch (host->ld_intf_width) {
+		case STMLCDIF_8BIT:
+			mxsfb_disable_axi_clk(host);
+			dev_err(&host->pdev->dev,
+					"Unsupported LCD bus width mapping\n");
+			return -EINVAL;
+		case STMLCDIF_16BIT:
+		case STMLCDIF_18BIT:
+		case STMLCDIF_24BIT:
+			/* real 24 bit */
+			break;
+		}
+		/* do not use packed pixels = one pixel per word instead */
+		writel(CTRL1_SET_BYTE_PACKAGING(0x7), host->base + LCDC_CTRL1);
+		break;
+	default:
+		mxsfb_disable_axi_clk(host);
+		dev_err(&host->pdev->dev, "Unhandled color depth of %u\n",
+				fb_info->var.bits_per_pixel);
+		return -EINVAL;
+	}
+
+	writel(ctrl, host->base + LCDC_CTRL);
+
+	writel(TRANSFER_COUNT_SET_VCOUNT(fb_info->var.yres) |
+			TRANSFER_COUNT_SET_HCOUNT(fb_info->var.xres),
+			host->base + host->devdata->transfer_count);
+
+	vdctrl0 = VDCTRL0_ENABLE_PRESENT |	/* always in DOTCLOCK mode */
+		VDCTRL0_VSYNC_PERIOD_UNIT |
+		VDCTRL0_VSYNC_PULSE_WIDTH_UNIT |
+		VDCTRL0_SET_VSYNC_PULSE_WIDTH(fb_info->var.vsync_len);
+	if (fb_info->var.sync & FB_SYNC_HOR_HIGH_ACT)
+		vdctrl0 |= VDCTRL0_HSYNC_ACT_HIGH;
+	if (fb_info->var.sync & FB_SYNC_VERT_HIGH_ACT)
+		vdctrl0 |= VDCTRL0_VSYNC_ACT_HIGH;
+	if (host->sync & MXSFB_SYNC_DATA_ENABLE_HIGH_ACT)
+		vdctrl0 |= VDCTRL0_ENABLE_ACT_HIGH;
+	if (host->sync & MXSFB_SYNC_DOTCLK_FALLING_ACT)
+		vdctrl0 |= VDCTRL0_DOTCLK_ACT_FALLING;
+
+	writel(vdctrl0, host->base + LCDC_VDCTRL0);
+
+	/* frame length in lines */
+	writel(fb_info->var.upper_margin + fb_info->var.vsync_len +
+		fb_info->var.lower_margin + fb_info->var.yres,
+		host->base + LCDC_VDCTRL1);
+
+	/* line length in units of clocks or pixels */
+	writel(set_hsync_pulse_width(host, fb_info->var.hsync_len) |
+		VDCTRL2_SET_HSYNC_PERIOD(fb_info->var.left_margin +
+		fb_info->var.hsync_len + fb_info->var.right_margin +
+		fb_info->var.xres),
+		host->base + LCDC_VDCTRL2);
+
+	writel(SET_HOR_WAIT_CNT(fb_info->var.left_margin +
+		fb_info->var.hsync_len) |
+		SET_VERT_WAIT_CNT(fb_info->var.upper_margin +
+			fb_info->var.vsync_len),
+		host->base + LCDC_VDCTRL3);
+
+	vdctrl4 = SET_DOTCLK_H_VALID_DATA_CNT(fb_info->var.xres);
+	vdctrl4 |= VDCTRL4_SET_DOTCLK_DLY(host->dotclk_delay);
+	writel(vdctrl4, host->base + LCDC_VDCTRL4);
+
+	writel(fb_info->fix.smem_start +
+			fb_info->fix.line_length * fb_info->var.yoffset,
+			host->base + host->devdata->next_buf);
+
+	mxsfb_disable_axi_clk(host);
+
+	if (reenable)
+		mxsfb_enable_controller(fb_info);
+
+	return 0;
+}
+
+static int mxsfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+		u_int transp, struct fb_info *fb_info)
+{
+	unsigned int val;
+	int ret = -EINVAL;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (fb_info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+					7471 * blue) >> 16;
+
+	switch (fb_info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 12 or 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fb_info->pseudo_palette;
+
+			val  = chan_to_field(red, &fb_info->var.red);
+			val |= chan_to_field(green, &fb_info->var.green);
+			val |= chan_to_field(blue, &fb_info->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+static int mxsfb_blank(int blank, struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		if (host->enabled)
+			mxsfb_disable_controller(fb_info);
+		break;
+
+	case FB_BLANK_UNBLANK:
+		if (!host->enabled)
+			mxsfb_enable_controller(fb_info);
+		break;
+	}
+	return 0;
+}
+
+int mxsfb_pan_display(struct fb_var_screeninfo *var,
+					  struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	unsigned offset;
+
+	if (var->xoffset != 0)
+		return -EINVAL;
+
+	offset = fb_info->fix.line_length * var->yoffset;
+
+	mxsfb_enable_axi_clk(host);
+
+	/* update on next VSYNC */
+	writel(fb_info->fix.smem_start + offset,
+			host->base + host->devdata->next_buf);
+
+	mxsfb_disable_axi_clk(host);
+
+	return 0;
+}
+EXPORT_SYMBOL(mxsfb_pan_display);
+
+static struct fb_ops mxsfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = mxsfb_check_var,
+	.fb_set_par = mxsfb_set_par,
+	.fb_setcolreg = mxsfb_setcolreg,
+	.fb_blank = mxsfb_blank,
+	.fb_pan_display = mxsfb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+};
+
+static int mxsfb_restore_mode(struct mxsfb_info *host,
+			struct fb_videomode *vmode)
+{
+	struct fb_info *fb_info = &host->fb_info;
+	unsigned line_count;
+	unsigned period;
+	unsigned long pa, fbsize;
+	int bits_per_pixel, ofs, ret = 0;
+	u32 transfer_count, vdctrl0, vdctrl2, vdctrl3, vdctrl4, ctrl;
+
+	mxsfb_enable_axi_clk(host);
+
+	/* Only restore the mode when the controller is running */
+	ctrl = readl(host->base + LCDC_CTRL);
+	if (!(ctrl & CTRL_RUN)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	vdctrl0 = readl(host->base + LCDC_VDCTRL0);
+	vdctrl2 = readl(host->base + LCDC_VDCTRL2);
+	vdctrl3 = readl(host->base + LCDC_VDCTRL3);
+	vdctrl4 = readl(host->base + LCDC_VDCTRL4);
+
+	transfer_count = readl(host->base + host->devdata->transfer_count);
+
+	vmode->xres = TRANSFER_COUNT_GET_HCOUNT(transfer_count);
+	vmode->yres = TRANSFER_COUNT_GET_VCOUNT(transfer_count);
+
+	switch (CTRL_GET_WORD_LENGTH(ctrl)) {
+	case 0:
+		bits_per_pixel = 16;
+		break;
+	case 3:
+		bits_per_pixel = 32;
+		break;
+	case 1:
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	fb_info->var.bits_per_pixel = bits_per_pixel;
+
+	vmode->pixclock = KHZ2PICOS(clk_get_rate(host->clk) / 1000U);
+	vmode->hsync_len = get_hsync_pulse_width(host, vdctrl2);
+	vmode->left_margin = GET_HOR_WAIT_CNT(vdctrl3) - vmode->hsync_len;
+	vmode->right_margin = VDCTRL2_GET_HSYNC_PERIOD(vdctrl2) -
+		vmode->hsync_len - vmode->left_margin - vmode->xres;
+	vmode->vsync_len = VDCTRL0_GET_VSYNC_PULSE_WIDTH(vdctrl0);
+	period = readl(host->base + LCDC_VDCTRL1);
+	vmode->upper_margin = GET_VERT_WAIT_CNT(vdctrl3) - vmode->vsync_len;
+	vmode->lower_margin = period - vmode->vsync_len -
+		vmode->upper_margin - vmode->yres;
+
+	vmode->vmode = FB_VMODE_NONINTERLACED;
+
+	vmode->sync = 0;
+	if (vdctrl0 & VDCTRL0_HSYNC_ACT_HIGH)
+		vmode->sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (vdctrl0 & VDCTRL0_VSYNC_ACT_HIGH)
+		vmode->sync |= FB_SYNC_VERT_HIGH_ACT;
+
+	pr_debug("Reconstructed video mode:\n");
+	pr_debug("%dx%d, hsync: %u left: %u, right: %u, vsync: %u, upper: %u, lower: %u\n",
+		vmode->xres, vmode->yres, vmode->hsync_len, vmode->left_margin,
+		vmode->right_margin, vmode->vsync_len, vmode->upper_margin,
+		vmode->lower_margin);
+	pr_debug("pixclk: %ldkHz\n", PICOS2KHZ(vmode->pixclock));
+
+	host->ld_intf_width = CTRL_GET_BUS_WIDTH(ctrl);
+	host->dotclk_delay = VDCTRL4_GET_DOTCLK_DLY(vdctrl4);
+
+	fb_info->fix.line_length = vmode->xres * (bits_per_pixel >> 3);
+
+	pa = readl(host->base + host->devdata->cur_buf);
+	fbsize = fb_info->fix.line_length * vmode->yres;
+	if (pa < fb_info->fix.smem_start) {
+		ret = -EINVAL;
+		goto err;
+	}
+	if (pa + fbsize > fb_info->fix.smem_start + fb_info->fix.smem_len) {
+		ret = -EINVAL;
+		goto err;
+	}
+	ofs = pa - fb_info->fix.smem_start;
+	if (ofs) {
+		memmove(fb_info->screen_base, fb_info->screen_base + ofs, fbsize);
+		writel(fb_info->fix.smem_start, host->base + host->devdata->next_buf);
+	}
+
+	line_count = fb_info->fix.smem_len / fb_info->fix.line_length;
+	fb_info->fix.ypanstep = 1;
+
+	clk_prepare_enable(host->clk);
+	host->enabled = 1;
+
+err:
+	if (ret)
+		mxsfb_disable_axi_clk(host);
+
+	return ret;
+}
+
+static int mxsfb_init_fbinfo_dt(struct mxsfb_info *host,
+				struct fb_videomode *vmode)
+{
+	struct fb_info *fb_info = &host->fb_info;
+	struct fb_var_screeninfo *var = &fb_info->var;
+	struct device *dev = &host->pdev->dev;
+	struct device_node *np = host->pdev->dev.of_node;
+	struct device_node *display_np;
+	struct videomode vm;
+	u32 width;
+	int ret;
+
+	display_np = of_parse_phandle(np, "display", 0);
+	if (!display_np) {
+		dev_err(dev, "failed to find display phandle\n");
+		return -ENOENT;
+	}
+
+	ret = of_property_read_u32(display_np, "bus-width", &width);
+	if (ret < 0) {
+		dev_err(dev, "failed to get property bus-width\n");
+		goto put_display_node;
+	}
+
+	switch (width) {
+	case 8:
+		host->ld_intf_width = STMLCDIF_8BIT;
+		break;
+	case 16:
+		host->ld_intf_width = STMLCDIF_16BIT;
+		break;
+	case 18:
+		host->ld_intf_width = STMLCDIF_18BIT;
+		break;
+	case 24:
+		host->ld_intf_width = STMLCDIF_24BIT;
+		break;
+	default:
+		dev_err(dev, "invalid bus-width value\n");
+		ret = -EINVAL;
+		goto put_display_node;
+	}
+
+	ret = of_property_read_u32(display_np, "bits-per-pixel",
+				   &var->bits_per_pixel);
+	if (ret < 0) {
+		dev_err(dev, "failed to get property bits-per-pixel\n");
+		goto put_display_node;
+	}
+
+	ret = of_get_videomode(display_np, &vm, OF_USE_NATIVE_MODE);
+	if (ret) {
+		dev_err(dev, "failed to get videomode from DT\n");
+		goto put_display_node;
+	}
+
+	ret = fb_videomode_from_videomode(&vm, vmode);
+	if (ret < 0)
+		goto put_display_node;
+
+	if (vm.flags & DISPLAY_FLAGS_DE_HIGH)
+		host->sync |= MXSFB_SYNC_DATA_ENABLE_HIGH_ACT;
+	if (vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)
+		host->sync |= MXSFB_SYNC_DOTCLK_FALLING_ACT;
+
+put_display_node:
+	of_node_put(display_np);
+	return ret;
+}
+
+static int mxsfb_init_fbinfo(struct mxsfb_info *host,
+			struct fb_videomode *vmode)
+{
+	int ret;
+	struct fb_info *fb_info = &host->fb_info;
+	struct fb_var_screeninfo *var = &fb_info->var;
+	dma_addr_t fb_phys;
+	void *fb_virt;
+	unsigned fb_size;
+
+	fb_info->fbops = &mxsfb_ops;
+	fb_info->flags = FBINFO_FLAG_DEFAULT | FBINFO_READS_FAST;
+	strlcpy(fb_info->fix.id, "mxs", sizeof(fb_info->fix.id));
+	fb_info->fix.type = FB_TYPE_PACKED_PIXELS;
+	fb_info->fix.ypanstep = 1;
+	fb_info->fix.visual = FB_VISUAL_TRUECOLOR,
+	fb_info->fix.accel = FB_ACCEL_NONE;
+
+	ret = mxsfb_init_fbinfo_dt(host, vmode);
+	if (ret)
+		return ret;
+
+	var->nonstd = 0;
+	var->activate = FB_ACTIVATE_NOW;
+	var->accel_flags = 0;
+	var->vmode = FB_VMODE_NONINTERLACED;
+
+	/* Memory allocation for framebuffer */
+	fb_size = ((var->xres * var->yres) / 8) * 3;
+	fb_virt = alloc_pages_exact(fb_size, GFP_DMA);
+	if (!fb_virt)
+		return -ENOMEM;
+
+	fb_phys = virt_to_phys(fb_virt);
+
+	fb_info->fix.smem_start = fb_phys;
+	fb_info->screen_base = fb_virt;
+	fb_info->screen_size = fb_info->fix.smem_len = fb_size;
+
+	if (mxsfb_restore_mode(host, vmode))
+		memset(fb_virt, 0, fb_size);
+
+	return 0;
+}
+
+static void mxsfb_free_videomem(struct mxsfb_info *host)
+{
+	struct fb_info *fb_info = &host->fb_info;
+
+	free_pages_exact(fb_info->screen_base, fb_info->fix.smem_len);
+}
+
+static const struct platform_device_id mxsfb_devtype[] = {
+	{
+		.name = "imx6ul-fb",
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(platform, mxsfb_devtype);
+
+static const struct of_device_id mxsfb_dt_ids[] = {
+	{ .compatible = "fsl,imx6ul-lcdif", .data = &mxsfb_devtype, },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, mxsfb_dt_ids);
+
+/** Used for control and initialize the display */
+static struct spi_board_info spi_if;
+
+static int mxsfb_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id =
+			of_match_device(mxsfb_dt_ids, &pdev->dev);
+	struct resource *res;
+	struct mxsfb_info *host;
+	struct fb_info *fb_info;
+	struct fb_videomode *mode;
+#if defined (DO_REGISTER_SPI_DEVICE)
+	struct spi_board_info *spi = &spi_if;
+#endif
+	int ret;
+
+	if (of_id)
+		pdev->id_entry = of_id->data;
+
+	fb_info = framebuffer_alloc(sizeof(struct mxsfb_info), &pdev->dev);
+	if (!fb_info) {
+		dev_err(&pdev->dev, "Failed to allocate fbdev\n");
+		return -ENOMEM;
+	}
+
+	mode = devm_kzalloc(&pdev->dev, sizeof(struct fb_videomode),
+			GFP_KERNEL);
+	if (mode == NULL)
+		return -ENOMEM;
+
+	host = to_imxfb_host(fb_info);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	host->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(host->base)) {
+		ret = PTR_ERR(host->base);
+		goto fb_release;
+	}
+
+	host->pdev = pdev;
+	platform_set_drvdata(pdev, host);
+
+	host->devdata = &mxsfb_devdata;
+
+#if defined (GPIO_LCDIF_RESET)
+	ret = gpio_request_one(GPIO_LCDIF_RESET, GPIOF_OUT_INIT_LOW, "st7789v_reset");
+	if (ret) {
+		dev_err(&host->pdev->dev, "Failed to get the reset pin\n");
+		return ret;
+	}
+	/* Generate display reset sequence */
+	gpio_set_value(host->gpio_reset, 1);
+	mdelay(1);
+	gpio_set_value(host->gpio_reset, 0);
+	mdelay(10);
+	gpio_set_value(host->gpio_reset, 1);
+#endif
+#if defined (DO_REGISTER_SPI_DEVICE)
+	/* Fill SPI information to board info struct */
+	strncpy(spi->modalias, SPI_DRIVER_NAME, SPI_NAME_SIZE);
+	spi->chip_select = (u16)SPI_DISP_CS;
+	spi->bus_num = (u16)SPI_BUS;
+	spi->max_speed_hz = (u32)SPI_BUS_SPEED;
+	spi->mode = SPI_MODE_0;
+	spi->controller_data = (void *)fb_info;
+	/* Registrer new device */
+	dev_dbg(&pdev->dev, "Registering SPI device: %s", spi->modalias);
+	ret = spi_register_board_info(spi, 1);
+
+	if (ret) {
+		pr_err("failed to register SPI device\n");
+		return ret;
+	} else {
+		dev_dbg(&pdev->dev, "Successfully registered SPI device");
+	}
+#endif
+	host->clk = devm_clk_get(&host->pdev->dev, NULL);
+	if (IS_ERR(host->clk)) {
+		ret = PTR_ERR(host->clk);
+		goto fb_release;
+	}
+
+	host->clk_axi = devm_clk_get(&host->pdev->dev, "axi");
+	if (IS_ERR(host->clk_axi))
+		host->clk_axi = NULL;
+
+	host->clk_disp_axi = devm_clk_get(&host->pdev->dev, "disp_axi");
+	if (IS_ERR(host->clk_disp_axi))
+		host->clk_disp_axi = NULL;
+
+	host->reg_lcd = devm_regulator_get(&pdev->dev, "lcd");
+	if (IS_ERR(host->reg_lcd))
+		host->reg_lcd = NULL;
+
+	fb_info->pseudo_palette = devm_kzalloc(&pdev->dev, sizeof(u32) * 16,
+					       GFP_KERNEL);
+	if (!fb_info->pseudo_palette) {
+		ret = -ENOMEM;
+		goto fb_release;
+	}
+
+	ret = mxsfb_init_fbinfo(host, mode);
+	if (ret != 0)
+		goto fb_release;
+
+	fb_videomode_to_var(&fb_info->var, mode);
+
+	/* init the color fields */
+	mxsfb_check_var(&fb_info->var, fb_info);
+#if defined (DO_LCDIF_PAN)
+	fb_info->var.xoffset = 0;
+	fb_info->var.yoffset = 0;
+	/* mxsfb_pan_display(&fb_info->var, fb_info); */
+#endif
+
+	platform_set_drvdata(pdev, fb_info);
+
+	ret = register_framebuffer(fb_info);
+	if (ret != 0) {
+		dev_err(&pdev->dev,"Failed to register framebuffer\n");
+		goto fb_destroy;
+	}
+
+	if (!host->enabled) {
+		mxsfb_enable_axi_clk(host);
+		writel(0, host->base + LCDC_CTRL);
+		mxsfb_disable_axi_clk(host);
+		mxsfb_set_par(fb_info);
+		mxsfb_enable_controller(fb_info);
+	}
+	dev_info(&pdev->dev, "initialized\n");
+
+	return 0;
+
+fb_destroy:
+	if (host->enabled)
+		clk_disable_unprepare(host->clk);
+fb_release:
+	framebuffer_release(fb_info);
+
+	return ret;
+}
+
+static int mxsfb_remove(struct platform_device *pdev)
+{
+	struct fb_info *fb_info = platform_get_drvdata(pdev);
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+
+	if (host->enabled)
+		mxsfb_disable_controller(fb_info);
+
+	unregister_framebuffer(fb_info);
+	mxsfb_free_videomem(host);
+
+	framebuffer_release(fb_info);
+
+	return 0;
+}
+
+static void mxsfb_shutdown(struct platform_device *pdev)
+{
+	struct fb_info *fb_info = platform_get_drvdata(pdev);
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+
+	mxsfb_enable_axi_clk(host);
+
+	/*
+	 * Force stop the LCD controller as keeping it running during reboot
+	 * might interfere with the BootROM's boot mode pads sampling.
+	 */
+	writel(CTRL_RUN, host->base + LCDC_CTRL + REG_CLR);
+
+	mxsfb_disable_axi_clk(host);
+}
+
+static struct platform_driver mxsfb_driver = {
+	.probe = mxsfb_probe,
+	.remove = mxsfb_remove,
+	.shutdown = mxsfb_shutdown,
+	.id_table = mxsfb_devtype,
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .of_match_table = mxsfb_dt_ids,
+	},
+};
+
+module_platform_driver(mxsfb_driver);
+
+MODULE_DESCRIPTION("Freescale mxs framebuffer driver");
+MODULE_AUTHOR("Christian Duenki, Escatec Switzerland AG");
+MODULE_LICENSE("GPL");
diff --git a/drivers/stromer/fb_imx6_st7789_spi.c b/drivers/stromer/fb_imx6_st7789_spi.c
new file mode 100644
index 000000000000..8dad043231ab
--- /dev/null
+++ b/drivers/stromer/fb_imx6_st7789_spi.c
@@ -0,0 +1,468 @@
+/*
+ * Copyright (C) 2017 Christian Duenki, Escatec Switzerland AG
+ *
+ * This driver is inspired by:
+ *   fbtft, Copyright (C) 2013 Noralf Tronnes
+ *   fb_st7789v, Copyright (C) 2015 Dennis Menschel
+ */
+
+#include "fb_imx6.h"
+
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <video/mipi_display.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+
+#define DEFAULT_GAMMA \
+	"70 2C 2E 15 10 09 48 33 53 0B 19 18 20 25\n" \
+	"70 2C 2E 15 10 09 48 33 53 0B 19 18 20 25"
+
+/**
+ * enum st7789v_command - ST7789V display controller commands
+ *
+ * @PORCTRL: porch setting
+ * @GCTRL: gate control
+ * @VCOMS: VCOM setting
+ * @VDVVRHEN: VDV and VRH command enable
+ * @VRHS: VRH set
+ * @VDVS: VDV set
+ * @VCMOFSET: VCOM offset set
+ * @PWCTRL1: power control 1
+ * @PVGAMCTRL: positive voltage gamma control
+ * @NVGAMCTRL: negative voltage gamma control
+ *
+ * The command names are the same as those found in the datasheet to ease
+ * looking up their semantics and usage.
+ *
+ * Note that the ST7789V display controller offers quite a few more commands
+ * which have been omitted from this list as they are not used at the moment.
+ * Furthermore, commands that are compliant with the MIPI DCS have been left
+ * out as well to avoid duplicate entries.
+ */
+
+enum st7789v_command {
+	RAMWR = 0x2C,
+	RAMCTRL = 0xB0,
+	RGBCTRL = 0xB1,
+	PORCTRL = 0xB2,
+	GCTRL = 0xB7,
+	VCOMS = 0xBB,
+	LCMCTRL = 0xC0,
+	VDVVRHEN = 0xC2,
+	VRHS = 0xC3,
+	VDVS = 0xC4,
+	VCMOFSET = 0xC5,
+	FRCTRL2 = 0xC6,
+	PWCTRL1 = 0xD0,
+	PVGAMCTRL = 0xE0,
+	NVGAMCTRL = 0xE1,
+};
+
+struct st7789_driver_par {
+	struct spi_device *spi;
+	struct fb_info *p_fb_info;
+#if defined (GPIO_SPI_RESET)
+	int gpio_reset;
+#endif
+	u8 *buf;
+};
+
+#define MADCTL_BGR BIT(3) /* bitmask for RGB/BGR order */
+#define MADCTL_MV BIT(5) /* bitmask for page/column order */
+#define MADCTL_MX BIT(6) /* bitmask for column address order */
+#define MADCTL_MY BIT(7) /* bitmask for page address order */
+
+extern void mxsfb_enable_controller(struct fb_info *fb_info);
+extern void mxsfb_disable_controller(struct fb_info *fb_info);
+extern int mxsfb_pan_display(struct fb_var_screeninfo *var,
+							 struct fb_info *fb_info);
+
+void st7789_write_register(int len, ...);
+int st7789_write_spi(void *buf, size_t len);
+int st7789_trx_spi(void *buf_out, void *buf_in, size_t trx_len);
+int st7789_init_display(void);
+
+/** Local driver information */
+static struct st7789_driver_par disp;
+
+void st7789_write_register(int len, ...)
+{
+	va_list args;
+	u16 *buf = NULL;
+	int res, cnt = 0;
+
+	buf = (u16*)kmalloc((size_t)(len * sizeof(u16)), GFP_NOIO);
+
+	va_start(args, len);
+	for (cnt = 0; cnt < len; cnt++) {
+		buf[cnt] = (u16)(((u16)va_arg(args, unsigned int) & 0x00ff) | 0x0100);
+	}
+	va_end(args);
+
+	/* Set data(!command) bit of forst byte */
+	buf[0] &= 0x00ff;
+#if defined (DEBUG)
+	pr_debug("SPI Data: 0x%04x", buf[0]);
+	for (cnt = 1; cnt < len; cnt++) {
+		pr_debug(", 0x%04x", buf[cnt]);
+	}
+	pr_debug("\n");
+#endif
+
+	res = st7789_write_spi(buf, (size_t)(sizeof(u16) * len));
+
+	kfree(buf);
+
+	return;
+}
+
+/**
+ * @brief Transmit spi messages to the stromer-display
+ *
+ * @param buf[in] Data to be sent
+ * @param len[in] Length of message
+ * @return Success
+ */
+int st7789_write_spi(void *buf, size_t len)
+{
+	struct spi_device *spi = disp.spi;
+	struct spi_message m;
+	struct spi_transfer t = {
+		.tx_buf = buf,
+		.len = len,
+	};
+
+	if (!spi) {
+		pr_err("%s: spi is unexpectedly NULL\n", __func__);
+		return PTR_ERR(spi);
+	}
+
+	spi_message_init(&m);
+
+	spi_message_add_tail(&t, &m);
+	return spi_sync(spi, &m);
+}
+/* EXPORT_SYMBOL(st7789_write_spi); */
+
+/**
+ * @brief Transmit and receive spi messages
+ *
+ * @param buf_out[in] Buffer containing data to be sent
+ * @param buf_in[out] Buffer to store received data
+ * @param trx_len[in] Length of transmitt and receive (sum)
+ * @return zero on success, else a negative error code
+ */
+int st7789_trx_spi(void *buf_out, void *buf_in,
+				   size_t trx_len)
+{
+	struct spi_device *spi = disp.spi;
+	struct spi_message m;
+	struct spi_transfer t = {
+		.tx_buf = buf_out,
+		.rx_buf = buf_in,
+		.len = trx_len,
+	};
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+
+	return spi_sync(spi, &m);
+}
+/* EXPORT_SYMBOL(st7789_trx_spi); */
+
+#if 0
+/**
+ * blank() - blank the display
+ *
+ * @on: whether to enable or disable blanking the display
+ *
+ * Return: 0 on success, < 0 if error occurred.
+ */
+static int st7789_spi_blank(bool on)
+{
+	if (on)
+		st7789_write_reg(MIPI_DCS_SET_DISPLAY_OFF);
+	else
+		st7789_write_reg(MIPI_DCS_SET_DISPLAY_ON);
+	return 0;
+}
+/* EXPORT_SYMBOL(st7789_spi_blank); */
+#endif
+
+/**
+ * init_display() - initialize the display controller
+ *
+ * Most of the commands in this init function set their parameters to the
+ * same default values which are already in place after the display has been
+ * powered up. (The main exception to this rule is the pixel format which
+ * would default to 18 instead of 16 bit per pixel.)
+ * Nonetheless, this sequence can be used as a template for concrete
+ * displays which usually need some adjustments.
+ *
+ * Return: 0 on success, < 0 if error occurred.
+ */
+int st7789_init_display(void)
+{
+#if defined (GPIO_SPI_RESET)
+	/* Apply reset sequence */
+	if (gpio_is_valid(disp.gpio_reset)) {
+		/* dummy write to activate spi lines */
+		st7789_write_reg(MIPI_DCS_EXIT_SLEEP_MODE);
+
+		/* Apply clean reset sequence */
+		gpio_set_value(disp.gpio_reset, 1);
+		pr_debug("Set Display reset\n");
+		mdelay(1);
+		gpio_set_value(disp.gpio_reset, 0);
+		pr_debug("Clear Display reset\n");
+		mdelay(10);
+		gpio_set_value(disp.gpio_reset, 1);
+		pr_debug("Set Display reset\n");
+		mdelay(120);
+	}
+#endif
+	/* turn off sleep mode */
+	st7789_write_reg(MIPI_DCS_EXIT_SLEEP_MODE);
+	mdelay(120);
+
+	/* Memory data access contrl */
+	st7789_write_reg(MIPI_DCS_SET_ADDRESS_MODE, 0x00);
+
+	/* Porch settings */
+	st7789_write_reg(PORCTRL, 0x0c, 0x0c, 0x00,  0x33, 0x33);
+
+	/* Gate control
+	 * VGH = 13.26V
+	 * VGL = -10.43V
+	 */
+	st7789_write_reg(GCTRL, 0x70);
+
+	/* VCOM = 1.425 V */
+	st7789_write_reg(VCOMS, 0x35);
+
+	/* LCMCTRL */
+	st7789_write_reg(LCMCTRL, 0x2C);
+
+	/*
+	 * VDV and VRH register values come from command write
+	 * (instead of NVM)
+	 */
+	st7789_write_reg(VDVVRHEN, 0x01);
+
+	/*
+	 * VAP =  4.4V + (VCOM + VCOM offset + 0.5 * VDV)
+	 * VAN = -4.4V + (VCOM + VCOM offset + 0.5 * VDV)
+	 */
+	st7789_write_reg(VRHS, 0x11);
+
+	/* VDV = 0V */
+	st7789_write_reg(VDVS, 0x20);
+
+	/* Frame rate control */
+	st7789_write_reg(FRCTRL2, 0x0F);
+
+	/*
+	 * AVDD = 6.8V
+	 * AVCL = -4.8V
+	 * VDS = 2.3V
+	 */
+	st7789_write_reg(PWCTRL1, 0xA4, 0xA1);
+
+	/* Positive voltage gamma control */
+	st7789_write_reg(PVGAMCTRL, 0xD0, 0x00, 0x06, 0x09, 0x0b, 0x2a, 0x3c, 0x55,
+					 0x4b, 0x08, 0x16, 0x14, 0x19, 0x20);
+
+	/* Negative voltage gamma control */
+	st7789_write_reg(NVGAMCTRL, 0xD0, 0x00, 0x06, 0x09, 0x0b, 0x29, 0x36, 0x54,
+					 0x4b, 0x0d, 0x16, 0x14, 0x21, 0x20);
+
+	/* RAM control */
+	st7789_write_reg(RAMCTRL, 0x11, 0x00, 0x00);
+
+	/* RGB Interface control */
+	st7789_write_reg(RGBCTRL, 0x40, 0x04, 0x0A);
+
+	/* set pixel format to RGB-565 */
+	st7789_write_reg(MIPI_DCS_SET_PIXEL_FORMAT, 0x55); //<-- 0x50 proposed?
+
+	/* Frame rate control */
+	st7789_write_reg(MIPI_DCS_SET_COLUMN_ADDRESS, 0x00, 0x00, 0x00, 0xEF);
+
+	/* Display function control */
+	st7789_write_reg(MIPI_DCS_SET_PAGE_ADDRESS, 0x00, 0x00, 0x01, 0x3F);
+
+	/* Display on */
+	st7789_write_reg(MIPI_DCS_SET_DISPLAY_ON);
+
+	/* Memory write control */
+	st7789_write_reg(RAMWR);
+
+	pr_debug("Display init done...\n");
+
+	return 0;
+}
+/* EXPORT_SYMBOL(st7789_init_display); */
+
+#if 0
+/**
+ * set_gamma() - set gamma curves
+ *
+ * @curves: gamma curves
+ *
+ * Before the gamma curves are applied, they are preprocessed with a bitmask
+ * to ensure syntactically correct input for the display controller.
+ * This implies that the curves input parameter might be changed by this
+ * function and that illegal gamma values are auto-corrected and not
+ * reported as errors.
+ *
+ * Return: 0 on success, < 0 if error occurred.
+ */
+static int set_gamma(unsigned long *curves)
+{
+	/* int i; */
+	/* int j; */
+	/* int c; /\* curve index offset *\/ */
+
+	/* /\* */
+	/*  * Bitmasks for gamma curve command parameters. */
+	/*  * The masks are the same for both positive and negative voltage */
+	/*  * gamma curves. */
+	/*  *\/ */
+	/* const u8 gamma_par_mask[] = { */
+	/* 	0xFF, /\* V63[3:0], V0[3:0]*\/ */
+	/* 	0x3F, /\* V1[5:0] *\/ */
+	/* 	0x3F, /\* V2[5:0] *\/ */
+	/* 	0x1F, /\* V4[4:0] *\/ */
+	/* 	0x1F, /\* V6[4:0] *\/ */
+	/* 	0x3F, /\* J0[1:0], V13[3:0] *\/ */
+	/* 	0x7F, /\* V20[6:0] *\/ */
+	/* 	0x77, /\* V36[2:0], V27[2:0] *\/ */
+	/* 	0x7F, /\* V43[6:0] *\/ */
+	/* 	0x3F, /\* J1[1:0], V50[3:0] *\/ */
+	/* 	0x1F, /\* V57[4:0] *\/ */
+	/* 	0x1F, /\* V59[4:0] *\/ */
+	/* 	0x3F, /\* V61[5:0] *\/ */
+	/* 	0x3F, /\* V62[5:0] *\/ */
+	/* }; */
+
+	/* for (i = 0; i < par->gamma.num_curves; i++) { */
+	/* 	c = i * par->gamma.num_values; */
+	/* 	for (j = 0; j < par->gamma.num_values; j++) */
+	/* 		curves[c + j] &= gamma_par_mask[j]; */
+	/* 	st7789_write_reg( */
+	/* 		par, PVGAMCTRL + i, */
+	/* 		curves[c + 0], curves[c + 1], curves[c + 2], */
+	/* 		curves[c + 3], curves[c + 4], curves[c + 5], */
+	/* 		curves[c + 6], curves[c + 7], curves[c + 8], */
+	/* 		curves[c + 9], curves[c + 10], curves[c + 11], */
+	/* 		curves[c + 12], curves[c + 13]); */
+	/* } */
+	return 0;
+}
+#endif
+
+int st7789_probe_spi(struct spi_device *spi)
+{
+	int ret = 0;
+	struct fb_info *fb_info;
+#if defined (DO_SPI_PAN)
+	struct fb_var_screeninfo *var;
+#endif
+	if (NULL == spi) {
+		return PTR_ERR(spi);
+	}
+
+	/* dev_dbg(spi, "Probing STROMER-ST7789v device"); */
+	pr_debug("Probing STROMER-ST7789v device");
+
+	/* store spi device locally */
+	disp.spi = spi;
+	/* Set mode to 9-Bit */
+	spi->bits_per_word = 9;
+#if defined (GPIO_SPI_RESET)
+	/* Try getting the reset pin */
+	ret = gpio_request_one(GPIO_SPI_RESET, GPIOF_OUT_INIT_LOW, "st7789v_reset");
+	if (ret) {
+		pr_debug("Failed to get the reset pin");
+		return ret;
+	}
+	disp.gpio_reset = GPIO_SPI_RESET;
+#endif
+
+	/* Disable lcdif during initialization */
+	if (!spi->controller_data) {
+		pr_err("No LCDIF controller data!\n");
+		return -1;
+	}
+#if defined (DO_SPI_INIT_SEQUENCE)
+	fb_info = (struct fb_info *)spi->controller_data;
+	mxsfb_disable_controller(fb_info);
+	/* Init and configure display */
+	pr_debug("Configuring display...\n");
+	ret = st7789_init_display();
+ #if defined (DO_SPI_PAN)
+	pr_debug("Do panning\n");
+	var = &(fb_info->var);
+
+	var->xoffset = 0;
+	var->yoffset = 0;
+	mxsfb_pan_display(var, fb_info);
+ #endif
+	mxsfb_enable_controller(fb_info);
+#endif
+	return ret;
+}
+
+int st7789_remove_spi(struct spi_device *spi)
+{
+	/* ToDo! */
+	return 0;
+}
+
+static const struct of_device_id dt_ids[] = {
+	{ .compatible = "st7789v" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, dt_ids);
+
+static struct spi_driver st7789_driver_spi_driver = {
+	.driver = {
+		.name   = "st7789v",
+		/* .of_match_table = of_match_ptr(dt_ids), */
+		.owner = THIS_MODULE,
+	},
+	.probe  = st7789_probe_spi,
+	.remove = st7789_remove_spi,
+};
+
+static int __init st7789_driver_module_init(void)
+{
+	int ret;
+
+	ret = spi_register_driver(&st7789_driver_spi_driver);
+
+	return ret;
+}
+
+static void __exit st7789_driver_module_exit(void)
+{
+	spi_unregister_driver(&st7789_driver_spi_driver);
+}
+
+module_init(st7789_driver_module_init);
+module_exit(st7789_driver_module_exit);
+
+MODULE_ALIAS("spi:" SPI_DRIVER_NAME);
+MODULE_ALIAS("platform:" SPI_DRIVER_NAME);
+MODULE_ALIAS("spi:st7789v");
+MODULE_ALIAS(SPI_DRIVER_NAME);
+
+MODULE_DESCRIPTION("SPI driver for the ST7789V LCD Controller");
+MODULE_AUTHOR("Christian Duenki");
+MODULE_LICENSE("GPL");
diff --git a/drivers/stromer/st1633.c b/drivers/stromer/st1633.c
new file mode 100644
index 000000000000..bff064bc6ad6
--- /dev/null
+++ b/drivers/stromer/st1633.c
@@ -0,0 +1,1147 @@
+/*
+ * Copyright (C) 2017 Christian Duenki, Escatec Switzerland AG
+ * christian.duenki@escatec.com
+ *
+ * This code is based on:
+ * drivers/input/touchscreen/sitronix_i2c_touch.c
+ *
+ * Touchscreen driver for Sitronix (I2C bus)
+ *
+ * Copyright (C) 2011 Sitronix Technology Co., Ltd.
+ *	Rudy Huang <rudy_huang@sitronix.com.tw>
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include "st1633.h"
+#include <linux/i2c.h>
+#include <linux/input.h>
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+ #include <linux/input/mt.h>
+#endif /* SITRONIX_SUPPORT_MT_SLOT */
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+
+#define DRIVER_AUTHOR           "Escatec Switzerland AG"
+#define DRIVER_NAME             "st1633i"
+#define DRIVER_DESC             "Sitronix I2C touch"
+#define DRIVER_DATE             "20170626"
+#define DRIVER_MAJOR            2
+#define DRIVER_MINOR         	9
+#define DRIVER_PATCHLEVEL       24
+
+#define IRQF_DISABLED           0
+
+#ifdef SITRONIX_SENSOR_KEY
+#define SITRONIX_NUMBER_SENSOR_KEY 3
+int sitronix_sensor_key[SITRONIX_NUMBER_SENSOR_KEY] = {
+	/* bit 0 */
+	KEY_BACK,
+	/* bit 1 */
+	KEY_HOME,
+	/* bit 2 */
+	KEY_MENU,
+};
+#endif /* SITRONIX_SENSOR_KEY */
+
+#ifdef SITRONIX_TOUCH_KEY
+#define SITRONIX_NUMBER_TOUCH_KEY 4
+
+#ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+#define SITRONIX_TOUCH_RESOLUTION_X 240 /* max of X value in display area */
+#define SITRONIX_TOUCH_RESOLUTION_Y 320 /* max of Y value in display area */
+#define SITRONIX_TOUCH_GAP_Y	10      /* Gap between bottom of display and top of touch key */
+#define SITRONIX_TOUCH_MAX_Y 915        /* resolution of y axis of touch ic */
+struct sitronix_AA_key sitronix_key_array[SITRONIX_NUMBER_TOUCH_KEY] = {
+	{15, 105, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_MENU},  /* MENU */
+	{135, 225, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_HOME},
+	{255, 345, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_BACK}, /* KEY_EXIT */
+	{375, 465, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_SEARCH},
+};
+#else
+#define SCALE_KEY_HIGH_Y 15
+struct sitronix_AA_key sitronix_key_array[SITRONIX_NUMBER_TOUCH_KEY] = {
+	{0, 0, 0, 0, KEY_MENU}, /* MENU */
+	{0, 0, 0, 0, KEY_HOME},
+	{0, 0, 0, 0, KEY_BACK}, /* KEY_EXIT */
+	{0, 0, 0, 0, KEY_SEARCH},
+};
+#endif /* SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY */
+#endif /* SITRONIX_TOUCH_KEY */
+
+struct sitronix_xy_data_s {
+	union {
+		struct {
+			uint8_t y_h:3;
+			uint8_t reserved:1;
+			uint8_t x_h:3;
+			uint8_t valid:1;
+		} fields;
+		uint8_t byte;
+	} xy_info;
+	uint8_t x_l;
+	uint8_t y_l;
+	uint8_t z;
+};
+
+struct stx_report_data_s {
+	uint8_t fingers:4;
+	uint8_t reserved:4;
+	uint8_t keys;
+	struct sitronix_xy_data_s xy_data[SITRONIX_MAX_SUPPORTED_POINT];
+};
+
+/**
+ * Struct containing all relevant data to implement touch function
+ */
+struct sitronix_ts_data_s {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+#if defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY)
+	struct input_dev *keyevent_input;
+#endif /* defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY) */
+	int use_irq;
+	struct hrtimer timer;
+#ifndef SITRONIX_INT_POLLING_MODE
+	struct work_struct  work;
+#else
+	struct delayed_work work;
+#endif /* SITRONIX_INT_POLLING_MODE */
+	void (*reset_ic)(void);
+	uint8_t fw_revision[4];
+	int resolution_x;
+	int resolution_y;
+	uint8_t max_touches;
+	uint8_t touch_protocol_type;
+	uint8_t pixel_length;
+	uint8_t chip_id;
+	uint8_t Num_X;
+	uint8_t Num_Y;
+	int suspend_state;
+	int irq_gpio;
+};
+
+static int i2cErrorCount = 0;
+
+static struct sitronix_ts_data_s *sitronix_ts_gpts = NULL;
+static int sitronix_ts_irq_on = 0;
+
+/**
+ * @brief Used to report a pen down event
+ * @param[out] input_dev Input device to send the event
+ * @param[in]  id        Id of the event
+ * @param[in]  x         X address
+ * @param[in]  y         Y address
+ */
+static inline void sitronix_ts_pen_down(struct input_dev *input_dev, int id, u16 x, u16 y);
+
+/**
+ * @brief Used to report a pen up event
+ * @param[out] input_dev Input device to send the event
+ * @param[in]  id        Id of the event
+ */
+static inline void sitronix_ts_pen_up(struct input_dev *input_dev, int id);
+
+/**
+ * @brief Local function to write data to i2c slave
+ * @param[in,out] client I2C client data
+ * @param[in] txbuf      Output data buffer
+ * @param[in] len        Data length
+ * @return Error code
+ */
+static int sitronix_i2c_write_bytes(struct i2c_client *client, u8 *txbuf, int len);
+
+/**
+ * @brief Local function to read data from i2c slave
+ * @param[in,out] client I2C client data
+ * @param[in] addr       Address to read data from slave
+ * @param[in] rxbuf      Input data buffer
+ * @param[in] len        Data length
+ * @return Error code
+ */
+static int sitronix_i2c_read_bytes(struct i2c_client *client, u8 addr, u8 *rxbuf, int len);
+
+/**
+ * @brief Reading out touch controller firmware revision
+ * @param[in,out] ts Internal touch data struct
+ * @return Error code
+ */
+static int sitronix_get_fw_revision(struct sitronix_ts_data_s *ts)
+{
+	int ret = 0;
+	uint8_t buffer[4];
+
+	ret = sitronix_i2c_read_bytes(ts->client, FIRMWARE_REVISION_3, buffer, 4);
+	if (ret < 0) {
+		printk("read fw revision error (%d)\n", ret);
+		return ret;
+	} else {
+		memcpy(ts->fw_revision, buffer, 4);
+		printk("fw revision (hex) = %x %x %x %x\n", buffer[0], buffer[1], buffer[2], buffer[3]);
+	}
+
+	ret = sitronix_i2c_read_bytes(ts->client, FIRMWARE_VERSION, buffer, 1);
+	if (ret < 0) {
+		printk("read fw version error (%d)\n", ret);
+		return ret;
+	} else {
+		printk("fw version (hex) = %x\n", buffer[0]);
+	}
+
+	return 0;
+}
+
+/**
+ * @brief Reading out Chip ID
+ * @param[in,out] ts Internal touch data struct
+ * @return Error code
+ */
+static int sitronix_ts_get_chip_id(struct sitronix_ts_data_s *ts)
+{
+	int ret = 0;
+	uint8_t buffer[3];
+
+	DbgMsg("%s\n", __FUNCTION__);
+
+	ret = sitronix_i2c_read_bytes(ts->client, CHIP_ID, buffer, 3);
+	if (ret < 0) {
+		printk("read Chip ID error (%d)\n", ret);
+		return ret;
+	} else {
+		if (buffer[0] == 0) {
+			if (buffer[1] + buffer[2] > 32) {
+				ts->chip_id = 2;
+			} else {
+				ts->chip_id = 0;
+			}
+		} else {
+			ts->chip_id = buffer[0];
+		}
+		ts->Num_X = buffer[1];
+		ts->Num_Y = buffer[2];
+		printk("Chip ID = %d\n", ts->chip_id);
+		printk("Num_X = %d\n", ts->Num_X);
+		printk("Num_Y = %d\n", ts->Num_Y);
+	}
+
+	return 0;
+}
+
+/**
+ * @brief Reading out maximum allowed touches
+ * @param[in,out] ts Internal touch data struct
+ * @return Error code
+ */
+static int sitronix_get_max_touches(struct sitronix_ts_data_s *ts)
+{
+	int ret = 0;
+	uint8_t buffer[1];
+
+	ret = sitronix_i2c_read_bytes(ts->client, MAX_NUM_TOUCHES, buffer, 1);
+	if (ret < 0) {
+		printk("read max touches error (%d)\n", ret);
+		return ret;
+	} else {
+		ts->max_touches = buffer[0];
+		if (ts->max_touches > SITRONIX_MAX_SUPPORTED_POINT) {
+			ts->max_touches = SITRONIX_MAX_SUPPORTED_POINT;
+		}
+		printk("max touches = %d \n",ts->max_touches);
+	}
+	return 0;
+}
+
+/**
+ * @brief Reading out touch controller i2c protocol type
+ * @param[in,out] ts Internal touch data struct
+ * @return Error code
+ */
+static int sitronix_get_protocol_type(struct sitronix_ts_data_s *ts)
+{
+	int ret = 0;
+	uint8_t buffer[1];
+
+	ret = sitronix_i2c_read_bytes(ts->client, I2C_PROTOCOL, buffer, 1);
+	if (ret < 0) {
+		printk("read i2c protocol error (%d)\n", ret);
+		return ret;
+	} else {
+		ts->touch_protocol_type = buffer[0] & I2C_PROTOCOL_BMSK;
+		if (ts->touch_protocol_type == SITRONIX_A_TYPE) {
+			ts->pixel_length = PIXEL_DATA_LENGTH_A;
+		} else if (ts->touch_protocol_type == SITRONIX_B_TYPE) {
+			ts->pixel_length = PIXEL_DATA_LENGTH_B;
+		} else {
+			ts->pixel_length = PIXEL_DATA_LENGTH_A;
+		}
+
+		printk("i2c protocol = %d \n", ts->touch_protocol_type);
+	}
+
+	return 0;
+}
+
+/**
+ * @brief Reading out touch screen resolution
+ * @param[in,out] ts Internal touch data struct
+ * @return Error code
+ */
+static int sitronix_get_resolution(struct sitronix_ts_data_s *ts)
+{
+	int ret = 0;
+	uint8_t buffer[3];
+
+	ret = sitronix_i2c_read_bytes(ts->client, XY_RESOLUTION_HIGH, buffer, 3);
+	if (ret < 0) {
+		DbgMsg("read resolution error (%d)\n", ret);
+		return ret;
+	} else {
+		ts->resolution_x = ((buffer[0] & (X_RES_H_BMSK << X_RES_H_SHFT)) << 4) | buffer[1];
+		ts->resolution_y = ((buffer[0] & Y_RES_H_BMSK) << 8) | buffer[2];
+		DbgMsg("resolution = %d x %d\n", ts->resolution_x, ts->resolution_y);
+	}
+
+	return 0;
+}
+
+/**
+ * @brief Set/Clear powerdown bit
+ * @param[in,out] ts Internal touch data struct
+ * @param[in] value  Value to be set
+ * @return Error code
+ */
+static int sitronix_ts_set_powerdown_bit(struct sitronix_ts_data_s *ts, int value)
+{
+	int ret = 0;
+	uint8_t buffer[2];
+
+	DbgMsg("%s, value = %d\n", __func__, value);
+	ret = sitronix_i2c_read_bytes(ts->client, DEVICE_CONTROL_REG, buffer, 1);
+	if (ret < 0){
+		printk("read device control status error (%d)\n", ret);
+		return ret;
+	} else {
+		DbgMsg("dev status = %d \n", buffer[0]);
+	}
+
+	if (value == 0) {
+		buffer[1] = buffer[0] & 0xfd;
+	} else {
+		buffer[1] = buffer[0] | 0x2;
+	}
+
+	buffer[0] = DEVICE_CONTROL_REG;
+	ret = i2c_master_send(ts->client, buffer, 2);
+	if (ret < 0) {
+		printk("write power down error (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * @brief Collect touch controller data
+ * @param[in,out] ts Internal touch data struct
+ * @return Error code
+ */
+static int sitronix_ts_get_touch_info(struct sitronix_ts_data_s *ts)
+{
+	int ret = 0;
+
+	ret = sitronix_get_resolution(ts);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = sitronix_ts_get_chip_id(ts);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = sitronix_get_fw_revision(ts);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = sitronix_get_protocol_type(ts);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = sitronix_get_max_touches(ts);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if ((ts->fw_revision[0] == 0) && (ts->fw_revision[1] == 0)) {
+		if (ts->touch_protocol_type == SITRONIX_RESERVED_TYPE_0) {
+			ts->touch_protocol_type = SITRONIX_B_TYPE;
+			printk("i2c protocol (revised) = %d \n", ts->touch_protocol_type);
+		}
+	}
+
+	if (ts->touch_protocol_type == SITRONIX_A_TYPE) {
+		ts->pixel_length = PIXEL_DATA_LENGTH_A;
+	} else if (ts->touch_protocol_type == SITRONIX_B_TYPE) {
+		ts->pixel_length = PIXEL_DATA_LENGTH_B;
+		ts->max_touches = 2;
+		printk("max touches (revised) = %d \n", ts->max_touches);
+	}
+
+	return 0;
+}
+
+/**
+ * @brief Read touch controller status
+ * @param[in,out] ts Internal touch data struct
+ * @param[out] dev_status Device status
+ * @return Error code
+ */
+static int sitronix_ts_get_device_status(struct sitronix_ts_data_s *ts, uint8_t *dev_status)
+{
+	int ret = 0;
+	uint8_t buffer[8];
+
+	DbgMsg("%s\n", __func__);
+	buffer[0] = STATUS_REG;
+	ret = i2c_master_send(ts->client, buffer, 1);
+	if (ret < 0){
+		printk("send status reg command error (%d)\n", ret);
+		return ret;
+	}
+
+	ret = i2c_master_recv(ts->client, buffer, 8);
+	if (ret < 0) {
+		printk("read status reg error (%d)\n", ret);
+		return ret;
+	} else {
+		DbgMsg("status reg = %d \n", buffer[0]);
+	}
+
+	*dev_status = buffer[0] & 0xf;
+
+	return 0;
+}
+
+/**
+ * @brief Read Enhanced function control register
+ * @param[in,out] ts Internal touch data struct
+ * @param[out] value Value to write data to
+ * @return Error code
+ */
+static int sitronix_ts_Enhance_Function_control(struct sitronix_ts_data_s *ts, uint8_t *value)
+{
+	int ret = 0;
+	uint8_t buffer[4];
+
+	DbgMsg("%s\n", __func__);
+	buffer[0] = 0xF0;
+	ret = i2c_master_send(ts->client, buffer, 1);
+	if (ret < 0) {
+		printk("send Enhance Function command error (%d)\n", ret);
+		return ret;
+	}
+
+	ret = i2c_master_recv(ts->client, buffer, 1);
+	if (ret < 0) {
+		printk("read Enhance Functions status error (%d)\n", ret);
+		return ret;
+	} else {
+		DbgMsg("Enhance Functions status = %d \n", buffer[0]);
+	}
+
+	*value = buffer[0] & 0x4;
+
+	return 0;
+}
+
+static int sitronix_ts_FW_Bank_Select(struct sitronix_ts_data_s *ts, uint8_t value)
+{
+	int ret = 0;
+	uint8_t buffer[2];
+
+	DbgMsg("%s\n", __func__);
+	buffer[0] = 0xF1;
+	ret = i2c_master_send(ts->client, buffer, 1);
+	if (ret < 0) {
+		printk("send FW Bank Select command error (%d)\n", ret);
+		return ret;
+	}
+
+	ret = i2c_master_recv(ts->client, buffer, 1);
+	if (ret < 0) {
+		printk("read FW Bank Select status error (%d)\n", ret);
+		return ret;
+	} else {
+		DbgMsg("FW Bank Select status = %d \n", buffer[0]);
+	}
+
+	buffer[1] = ((buffer[0] & 0xfc) | value);
+	buffer[0] = 0xF1;
+	ret = i2c_master_send(ts->client, buffer, 2);
+	if (ret < 0) {
+		printk("send FW Bank Select command error (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sitronix_get_id_info(struct sitronix_ts_data_s *ts, uint8_t *id_info)
+{
+	int ret = 0;
+	uint8_t buffer[4];
+
+	buffer[0] = 0x0C;
+	ret = i2c_master_send(ts->client, buffer, 1);
+	if (ret < 0) {
+		printk("send id info command error (%d)\n", ret);
+		return ret;
+	}
+	ret = i2c_master_recv(ts->client, buffer, 4);
+	if (ret < 0) {
+		printk("read id info error (%d)\n", ret);
+		return ret;
+	} else {
+		memcpy(id_info, buffer, 4);
+	}
+	return 0;
+}
+
+static int sitronix_ts_identify(struct sitronix_ts_data_s *ts)
+{
+	int ret = 0;
+	uint8_t id[4];
+	uint8_t Enhance_Function = 0;
+
+	ret = sitronix_ts_FW_Bank_Select(ts, 1);
+	if (ret < 0) {
+		return ret;
+	}
+	ret = sitronix_ts_Enhance_Function_control(ts, &Enhance_Function);
+	if (ret < 0) {
+		return ret;
+	}
+	if (Enhance_Function == 0x4) {
+		ret = sitronix_get_id_info(ts, &id[0]);
+		if (ret < 0) {
+			return ret;
+		}
+		printk("id (hex) = %x %x %x %x\n", id[0], id[1], id[2], id[3]);
+		if ((id[0] == 1)&&(id[1] == 2)&&(id[2] == 0xb)&&(id[3] == 1)) {
+			return 0;
+		} else {
+			printk("Error: It is not Sitronix IC\n");
+			return -1;
+		}
+	} else {
+		printk("Error: Can not get ID of Sitronix IC\n");
+		return -1;
+	}
+}
+
+static void sitronix_ts_work_func(struct work_struct *work)
+{
+	int i;
+	int ret;
+	uint16_t x, y;
+#ifndef SITRONIX_INT_POLLING_MODE
+	struct sitronix_ts_data_s *ts = \
+		container_of(work, struct sitronix_ts_data_s, work);
+#else
+	struct sitronix_ts_data_s *ts = \
+		container_of(to_delayed_work(work), struct sitronix_ts_data_s, work);
+#endif /* SITRONIX_INT_POLLING_MODE */
+	uint8_t buffer[2 + SITRONIX_MAX_SUPPORTED_POINT * PIXEL_DATA_LENGTH_A];
+	uint8_t PixelCount = 0;
+	struct sitronix_xy_data_s *p_xy_data = NULL;
+
+	DbgMsg("%s\n",  __func__);
+	if (ts->suspend_state) {
+		goto exit_invalid_data;
+	}
+
+	/* get touch data */
+	ret = sitronix_i2c_read_bytes(ts->client, KEYS_REG, buffer, 1 + ts->max_touches * ts->pixel_length);
+	if (ret < 0) {
+		printk("read finger error (%d)\n", ret);
+		i2cErrorCount++;
+		goto exit_invalid_data;
+	} else {
+		i2cErrorCount = 0;
+	}
+
+	p_xy_data = (struct sitronix_xy_data_s *)&buffer[1];
+	for (i = 0; i < ts->max_touches; i++) {
+		/* DbgMsg("Key %d: 0x%02x\n", i, p_xy_data[i].xy_info.byte); */
+		if (p_xy_data[i].xy_info.fields.valid == 1) {
+		/* if (buffer[1 + i * ts->pixel_length + XY_COORD_H] & 0x80) { */
+			x = 0 | (u16)p_xy_data[i].xy_info.fields.x_h << 8 | (u16)p_xy_data[i].x_l;
+			y = 0 | (u16)p_xy_data[i].xy_info.fields.y_h << 8 | (u16)p_xy_data[i].y_l;
+			/* DbgMsg("X: 0x%04x, Y: 0x%04x", x, y); */
+			PixelCount++;
+			sitronix_ts_pen_down(ts->input_dev, i, x, y);
+#ifdef SITRONIX_TOUCH_KEY
+ #ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+			if (y < SITRONIX_TOUCH_RESOLUTION_Y) {
+ #else
+			//if (y < (ts->resolution_y - ts->resolution_y / SCALE_KEY_HIGH_Y)) {
+ #endif /* SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY */
+				PixelCount++;
+				sitronix_ts_pen_down(ts->input_dev, i, x, y);
+				//DbgMsg("AREA_DISPLAY\n");
+			} else {
+				for (j = 0; j < (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)); j++) {
+					if((x >= sitronix_aa_key_array[j].x_low) &&
+					   (x <= sitronix_aa_key_array[j].x_high) &&
+					   (y >= sitronix_aa_key_array[j].y_low) &&
+					   (y <= sitronix_aa_key_array[j].y_high)) {
+						aa_key_status |= (1 << j);
+						//DbgMsg("AREA_KEY [%d]\n", j);
+						break;
+					}
+				}
+			}
+#endif
+		} else {
+			sitronix_ts_pen_up(ts->input_dev, i);
+		}
+	}
+	input_report_key(ts->input_dev, BTN_TOUCH, PixelCount > 0);
+	input_sync(ts->input_dev);
+
+exit_invalid_data:
+#ifdef SITRONIX_INT_POLLING_MODE
+	if (PixelCount > 0) {
+#ifdef SITRONIX_MONITOR_THREAD
+		if (ts->enable_monitor_thread == 1) {
+			atomic_set(&iMonitorThreadPostpone,1);
+		}
+#endif /* SITRONIX_MONITOR_THREAD */
+		schedule_delayed_work(&ts->work, msecs_to_jiffies(INT_POLLING_MODE_INTERVAL));
+	} else {
+#ifdef CONFIG_HARDIRQS_SW_RESEND
+		printk("Please not set HARDIRQS_SW_RESEND to prevent kernel from sending SW IRQ\n");
+#endif /* CONFIG_HARDIRQS_SW_RESEND */
+		if (ts->use_irq){
+			sitronix_ts_irq_on = 1;
+			/* atomic_set(&sitronix_ts_irq_on, 1); */
+			enable_irq(ts->client->irq);
+		}
+	}
+#endif /* SITRONIX_INT_POLLING_MODE */
+
+#if defined(SITRONIX_LEVEL_TRIGGERED)
+	if (ts->use_irq) {
+		sitronix_ts_irq_on = 1;
+		enable_irq(ts->client->irq);
+	}
+#endif // defined(SITRONIX_LEVEL_TRIGGERED)
+	if ((2 <= i2cErrorCount)) {
+		printk("I2C abnormal in work_func(), reset it!\n");
+		if(sitronix_ts_gpts->reset_ic) {
+			sitronix_ts_gpts->reset_ic();
+		}
+		i2cErrorCount = 0;
+	}
+}
+
+static irqreturn_t sitronix_ts_irq_handler(int irq, void *dev_id)
+{
+	struct sitronix_ts_data_s *ts = dev_id;
+
+	DbgMsg("%s\n", __func__);
+#if defined(SITRONIX_LEVEL_TRIGGERED) || defined(SITRONIX_INT_POLLING_MODE)
+	sitronix_ts_irq_on = 0;
+	disable_irq_nosync(ts->client->irq);
+#endif /* defined(SITRONIX_LEVEL_TRIGGERED) || defined(SITRONIX_INT_POLLING_MODE) */
+#ifndef SITRONIX_INT_POLLING_MODE
+	schedule_work(&ts->work);
+#else
+	schedule_delayed_work(&ts->work, msecs_to_jiffies(0));
+#endif /* SITRONIX_INT_POLLING_MODE */
+
+	return IRQ_HANDLED;
+}
+
+static int st1633_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+#if defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY)
+	int i;
+#endif /* defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY) */
+	struct sitronix_ts_data_s *ts;
+	int ret = 0;
+	uint16_t max_x = 0, max_y = 0;
+	struct sitronix_i2c_touch_platform_data *pdata;
+	uint8_t dev_status = 0;
+	int oftree = 0;
+
+	DbgMsg("Start probing ST1633 device.\n");
+
+	if (NULL == client) {
+		DbgMsg("ST1633 - invalid parameter!.\n");
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	ts = kzalloc(sizeof(struct sitronix_ts_data_s), GFP_KERNEL);
+	if (ts == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+
+	DbgMsg("ST1633 - create links between data.\n");
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+	pdata = client->dev.platform_data;
+
+	if (NULL == pdata) {
+		printk("No valid platform data available.\n");
+		oftree = 0;
+	} else {
+		DbgMsg("Switching to oftree mode.\n");
+		oftree = 1;
+	}
+
+	if (0 != oftree) {
+		/* Only of platform data is available */
+		if (pdata->reset_ic) {
+			ts->reset_ic = pdata->reset_ic;
+			pdata->reset_ic();
+			mdelay(SITRONIX_TS_CHANGE_MODE_DELAY);
+		}
+	} else {
+		ts->reset_ic = NULL;
+	}
+	sitronix_ts_gpts = ts;
+
+	printk("ST1633 - reading device status.\n");
+	ret = sitronix_ts_get_device_status(ts, &dev_status);
+	if ((ret < 0) || (dev_status == 0x6)) {
+		dev_err(dev, "ST1633 - invalid device status, probing failed\n");
+		goto err_device_info_error;
+	}
+
+	printk("ST1633 - reading touch info.\n");
+	ret = sitronix_ts_get_touch_info(ts);
+	if(ret < 0) {
+		goto err_device_info_error;
+	}
+
+	ret = sitronix_ts_identify(ts);
+
+	printk("ST1633 - Allocate input device.\n");
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		dev_err(dev, "Can not allocate memory for input device.\n");
+		ret = -ENOMEM;
+		goto err_input_dev_alloc_failed;
+	}
+
+#ifndef SITRONIX_INT_POLLING_MODE
+	DbgMsg("ST1633 - adding work.\n");
+	INIT_WORK(&ts->work, sitronix_ts_work_func);
+	DbgMsg(" done\n");
+#else
+	DbgMsg("ST1633 - adding delayed work...");
+	INIT_DELAYED_WORK(&ts->work, sitronix_ts_work_func);
+	DbgMsg(" done\n");
+#endif /* SITRONIX_INT_POLLING_MODE */
+
+	ts->input_dev->name = "sitronix-i2c-touch-mt";
+	__set_bit(EV_SYN, ts->input_dev->evbit);
+	__set_bit(EV_KEY, ts->input_dev->evbit);
+	__set_bit(EV_ABS, ts->input_dev->evbit);
+	__set_bit(BTN_TOUCH, ts->input_dev->keybit);
+
+#if defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY)
+	ts->keyevent_input = input_allocate_device();
+	if (ts->keyevent_input == NULL) {
+		dev_err(dev, "Can not allocate memory for key input device.\n");
+		ret = -ENOMEM;
+		goto err_input_dev_alloc_failed;
+	}
+	ts->keyevent_input->name  = "sitronix-i2c-touch-key";
+	set_bit(EV_KEY, ts->keyevent_input->evbit);
+#endif /* defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY) */
+#if defined(SITRONIX_SENSOR_KEY)
+	for (i = 0; i < SITRONIX_NUMBER_SENSOR_KEY; i++) {
+		set_bit(sitronix_sensor_key[i], ts->keyevent_input->keybit);
+	}
+#endif /* defined(SITRONIX_SENSOR_KEY) */
+
+#ifndef SITRONIX_TOUCH_KEY
+	max_x = ts->resolution_x;
+	max_y = ts->resolution_y;
+#else
+ #ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+	for (i = 0; i < SITRONIX_NUMBER_TOUCH_KEY; i++) {
+		set_bit(sitronix_key_array[i].code, ts->keyevent_input->keybit);
+	}
+	max_x = SITRONIX_TOUCH_RESOLUTION_X;
+	max_y = SITRONIX_TOUCH_RESOLUTION_Y;
+ #else
+	for (i = 0; i < SITRONIX_NUMBER_TOUCH_KEY; i++) {
+		sitronix_key_array[i].x_low = ((ts->resolution_x / SITRONIX_NUMBER_TOUCH_KEY ) * i ) + 15;
+		sitronix_key_array[i].x_high = ((ts->resolution_x / SITRONIX_NUMBER_TOUCH_KEY ) * (i + 1)) - 15;
+		sitronix_key_array[i].y_low = ts->resolution_y - ts->resolution_y / SCALE_KEY_HIGH_Y;
+		sitronix_key_array[i].y_high = ts->resolution_y;
+		DbgMsg("key[%d] %d, %d, %d, %d\n", i, sitronix_key_array[i].x_low, sitronix_key_array[i].x_high, sitronix_key_array[i].y_low, sitronix_key_array[i].y_high);
+		set_bit(sitronix_key_array[i].code, ts->keyevent_input->keybit);
+	}
+	max_x = ts->resolution_x;
+	max_y = ts->resolution_y - ts->resolution_y / SCALE_KEY_HIGH_Y;
+ #endif /* SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY */
+#endif /* SITRONIX_TOUCH_KEY */
+#if defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY)
+	ret = input_register_device(ts->keyevent_input);
+	if (ret < 0) {
+		dev_err(dev, "Can not register key input device.\n");
+		/* printk("Can not register key input device."); */
+		goto err_input_register_device_failed;
+	}
+#endif /* defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY) */
+
+#if defined(SITRONIX_SUPPORT_MT_SLOT)
+#ifndef SITRONIX_SWAP_XY
+	/* Single touch */
+	input_set_abs_params(ts->input_dev, ABS_X, 0, max_x, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, 0, max_y, 0, 0);
+
+	/* Multi touch */
+	input_mt_init_slots(ts->input_dev, ts->max_touches, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, max_x, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, max_y, 0, 0);
+#else
+	/* Single touch */
+	input_set_abs_params(ts->input_dev, ABS_X, 0, max_y, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, 0, max_x, 0, 0);
+
+	/* Multi touch */
+	input_mt_init_slots(ts->input_dev, ts->max_touches, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, max_y, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, max_x, 0, 0);
+#endif /* SITRONIX_SWAP_XY */
+#else
+	__set_bit(ABS_X, ts->input_dev->absbit);
+	__set_bit(ABS_Y, ts->input_dev->absbit);
+	__set_bit(ABS_MT_TOUCH_MAJOR, ts->input_dev->absbit);
+	__set_bit(ABS_MT_WIDTH_MAJOR, ts->input_dev->absbit);
+	__set_bit(ABS_MT_POSITION_X, ts->input_dev->absbit);
+	__set_bit(ABS_MT_POSITION_Y, ts->input_dev->absbit);
+	__set_bit(ABS_MT_TOOL_TYPE, ts->input_dev->absbit);
+	__set_bit(ABS_MT_BLOB_ID, ts->input_dev->absbit);
+	__set_bit(ABS_MT_TRACKING_ID, ts->input_dev->absbit);
+
+	input_set_abs_params(ts->input_dev, ABS_X, 0, max_x, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, 0, max_y, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0,  255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0,  255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, max_x, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, max_y, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0, ts->max_touches, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+#endif
+
+	ret = input_register_device(ts->input_dev);
+	if(ret < 0) {
+		dev_err(dev, "Can not register input device.\n");
+		goto err_input_register_device_failed;
+	}
+
+	ts->suspend_state = 0;
+	if (client->irq) {
+#ifdef SITRONIX_LEVEL_TRIGGERED
+		ret = request_irq(client->irq, sitronix_ts_irq_handler, IRQF_TRIGGER_LOW | IRQF_DISABLED, client->name, ts);
+#else
+		ret = request_irq(client->irq, sitronix_ts_irq_handler, IRQF_TRIGGER_FALLING | IRQF_DISABLED, client->name, ts);
+#endif /* SITRONIX_LEVEL_TRIGGERED */
+		if (ret == 0) {
+			sitronix_ts_irq_on = 1;
+			ts->use_irq = 1;
+		} else {
+			dev_err(&client->dev, "request_irq failed\n");
+		}
+	}
+	/* Get irq gpio */
+	if (dev->of_node) {
+		ts->irq_gpio = of_get_named_gpio(dev->of_node, "pendown-gpio", 0);
+		if (ts->irq_gpio > 100) {
+			dev_err(dev, "Unable to read GPIO from device tree\n");
+		}
+		ret = gpio_request_one(ts->irq_gpio, GPIOF_IN, "st1633i-irq_pin");
+		if (ret) {
+			dev_err(dev, "Failed to request/setup irq GPIO");
+		}
+	} else {
+		dev_err(dev, "Failed to request/setup irq GPIO");
+	}
+
+	return 0;
+
+err_input_register_device_failed:
+	input_free_device(ts->input_dev);
+#if defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY)
+	input_free_device(ts->keyevent_input);
+#endif /* defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY) */
+err_input_dev_alloc_failed:
+	kfree(ts);
+err_alloc_data_failed:
+err_check_functionality_failed:
+err_device_info_error:
+	return ret;
+}
+
+static inline void sitronix_ts_pen_down(struct input_dev *input_dev, int id, u16 x, u16 y)
+{
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+	input_mt_slot(input_dev, id);
+ #ifndef SITRONIX_SWAP_XY
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, x);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, y);
+	input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, true);
+ #else
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, y);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, x);
+	input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, true);
+ #endif /* SITRONIX_SWAP_XY */
+#else
+	input_report_abs(input_dev,  ABS_MT_TRACKING_ID, id);
+ #ifndef SITRONIX_SWAP_XY
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, x);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, y);
+ #else
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, y);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, x);
+ #endif /* SITRONIX_SWAP_XY */
+	input_report_abs(input_dev,  ABS_MT_TOUCH_MAJOR, 255);
+	input_report_abs(input_dev,  ABS_MT_WIDTH_MAJOR, 255);
+	input_report_abs(input_dev, ABS_MT_PRESSURE, 255);
+	input_mt_sync(input_dev);
+#endif /* SITRONIX_SUPPORT_MT_SLOT */
+	DbgMsg("[%d](%d, %d)+\n", id, x, y);
+}
+
+static inline void sitronix_ts_pen_up(struct input_dev *input_dev, int id)
+{
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+	input_mt_slot(input_dev, id);
+	input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, false);
+#else
+	input_report_abs(input_dev,  ABS_MT_TRACKING_ID, id);
+	input_report_abs(input_dev, ABS_MT_PRESSURE, 0);
+#endif /* SITRONIX_SUPPORT_MT_SLOT */
+	DbgMsg("[%d]-\n", id);
+}
+
+static int sitronix_i2c_read_bytes(struct i2c_client *client, u8 addr, u8 *rxbuf, int len)
+{
+	int ret = 0;
+	u8 txbuf = addr;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	struct i2c_msg msg[2] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &txbuf,
+		},
+		{
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = rxbuf,
+		},
+	};
+#endif /* defined(SITRONIX_I2C_COMBINED_MESSAGE) */
+
+	if(rxbuf == NULL)
+		return -1;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	ret = i2c_transfer(client->adapter, &msg[0], 2);
+#elif defined(SITRONIX_I2C_SINGLE_MESSAGE)
+	ret = i2c_master_send(client, &txbuf, 1);
+	if (ret < 0){
+		printk("write 0x%x error (%d)\n", addr, ret);
+		return ret;
+	}
+	ret = i2c_master_recv(client, rxbuf, len);
+#endif /* defined(SITRONIX_I2C_COMBINED_MESSAGE) */
+	if (ret < 0){
+		DbgMsg("read 0x%x error (%d)\n", addr, ret);
+		return ret;
+	}
+	return 0;
+}
+
+/**
+ * @brief Local function to write data to i2c slave
+ * @param[in,out] client I2C client data
+ * @param[in] txbuf      Output data buffer
+ * @param[in] len        Data length
+ * @return Error code
+ */
+static int sitronix_i2c_write_bytes(struct i2c_client *client, u8 *txbuf, int len)
+{
+	int ret = 0;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	struct i2c_msg msg[1] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = len,
+			.buf = txbuf,
+		},
+	};
+#endif /* defined(SITRONIX_I2C_COMBINED_MESSAGE) */
+
+	if(txbuf == NULL)
+		return -1;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	ret = i2c_transfer(client->adapter, &msg[0], 1);
+#elif defined(SITRONIX_I2C_SINGLE_MESSAGE)
+	ret = i2c_master_send(client, txbuf, len);
+#endif /* defined(SITRONIX_I2C_COMBINED_MESSAGE) */
+	if (ret < 0){
+		printk("write 0x%x error (%d)\n", *txbuf, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int st1633_i2c_remove(struct i2c_client *client)
+{
+	struct sitronix_ts_data_s *ts = i2c_get_clientdata(client);
+
+	/* Free IRQ */
+	if (ts->use_irq) {
+		free_irq(client->irq, ts);
+	} else {
+		hrtimer_cancel(&ts->timer);
+	}
+	/* Free IRQ gpio */
+	if (ts->irq_gpio != 0) {
+		gpio_free(ts->irq_gpio);
+	}
+
+	input_unregister_device(ts->input_dev);
+#if defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY)
+	input_unregister_device(ts->keyevent_input);
+#endif /* defined(SITRONIX_SENSOR_KEY) || defined (SITRONIX_TOUCH_KEY) */
+	kfree(ts);
+
+	return 0;
+}
+
+static int __maybe_unused st1633_i2c_suspend(struct device *dev)
+{
+	int ret;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sitronix_ts_data_s *ts = i2c_get_clientdata(client);
+
+	DbgMsg("%s\n", __func__);
+	if(ts->use_irq){
+		sitronix_ts_irq_on = 0;
+		disable_irq_nosync(ts->client->irq);
+	}
+	ts->suspend_state = 1;
+
+	ret = sitronix_ts_set_powerdown_bit(ts, 1);
+#ifdef SITRONIX_WAKE_UP_TOUCH_BY_INT
+	gpio_direction_output(ts->irq_gpio, 1);
+#endif /* SITRONIX_WAKE_UP_TOUCH_BY_INT */
+	DbgMsg("%s return\n", __func__);
+
+	return 0;
+}
+
+static int __maybe_unused st1633_i2c_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sitronix_ts_data_s *ts = i2c_get_clientdata(client);
+#ifdef SITRONIX_WAKE_UP_TOUCH_BY_INT
+	unsigned int gpio;
+#else
+	int ret;
+#endif /* SITRONIX_WAKE_UP_TOUCH_BY_INT */
+
+	DbgMsg("%s\n", __func__);
+#ifdef SITRONIX_WAKE_UP_TOUCH_BY_INT
+	gpio = ts->irq_gpio;
+	gpio_set_value(gpio, 0);
+	gpio_direction_input(gpio);
+#else
+	ret = sitronix_ts_set_powerdown_bit(ts, 0);
+#endif /* SITRONIX_WAKE_UP_TOUCH_BY_INT */
+
+	ts->suspend_state = 0;
+	if(ts->use_irq){
+		sitronix_ts_irq_on = 1;
+		enable_irq(ts->client->irq);
+	}
+	DbgMsg("%s return\n", __func__);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id st1633_of_match[] = {
+	{ .compatible = "stromer-st1633", .data = NULL},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, st1633_of_match);
+#endif
+
+static SIMPLE_DEV_PM_OPS(st1633_i2c_pm,
+			 st1633_i2c_suspend, st1633_i2c_resume);
+
+
+static const struct i2c_device_id st1633_i2c_id[] = {
+	{ .name="stromer-st1633", .driver_data = 0 },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, st1633_i2c_id);
+
+static struct i2c_driver st1633_i2c_driver = {
+	.driver = {
+		.name = "stromer-st1633",
+		.pm = &st1633_i2c_pm,
+	},
+	.id_table = st1633_i2c_id,
+	.probe = st1633_i2c_probe,
+	.remove = st1633_i2c_remove,
+};
+module_i2c_driver(st1633_i2c_driver);
+
+static int __init st1633_i2c_init(void)
+{
+	printk("Sitronix st1633 touch driver %d.%d.%d\n", DRIVER_MAJOR, DRIVER_MINOR, DRIVER_PATCHLEVEL);
+	printk("Release date: %s\n", DRIVER_DATE);
+	return i2c_add_driver(&st1633_i2c_driver);
+}
+
+static void __exit st1633_i2c_exit(void)
+{
+	i2c_del_driver(&st1633_i2c_driver);
+}
+
+MODULE_DESCRIPTION("Sitronix Multi-Touch Driver");
+MODULE_AUTHOR("Christian Duenki <christian.duenki@escatec.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/stromer/st1633.h b/drivers/stromer/st1633.h
new file mode 100644
index 000000000000..fed6fe788f35
--- /dev/null
+++ b/drivers/stromer/st1633.h
@@ -0,0 +1,237 @@
+/*
+ * drivers/stromer/st1633.h
+ *
+ * Touchscreen driver for Sitronix ST1633i touch controller
+ *
+ * Copyright (C) 2017 Christian Duenki, Escatec Switzerland AG
+ * christian.duenki@escatec.com
+ *
+ * This code is based on:
+ * drivers/input/touchscreen/sitronix_i2c_touch.h
+ *
+ * Touchscreen driver for Sitronix (I2C bus)
+ *
+ * Copyright (C) 2011 Sitronix Technology Co., Ltd.
+ *	Rudy Huang <rudy_huang@sitronix.com.tw>
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#ifndef __SITRONIX_I2C_TOUCH_h
+#define __SITRONIX_I2C_TOUCH_h
+
+#include <linux/ioctl.h> /* needed for the _IOW etc stuff used later */
+
+#define SITRONIX_TOUCH_DRIVER_VERSION 0x03
+#define SITRONIX_MAX_SUPPORTED_POINT 10
+//#define SITRONIX_MAX_SUPPORTED_POINT 5
+#define SITRONIX_I2C_TOUCH_DRV_NAME "sitronix"
+#define SITRONIX_I2C_TOUCH_DEV_NAME "sitronixDev"
+
+#define SITRONIX_WAKE_UP_TOUCH_BY_INT
+
+/*
+ * When enable_irq() is invoked, irq will be sent once while INT is not
+ * triggered if CONFIG_HARDIRQS_SW_RESEND is set. This behavior is implemented
+ * by linux kernel, it is used to prevent irq from losting when irq is
+ * edge-triggered mode.
+ */
+#define SITRONIX_LEVEL_TRIGGERED
+
+#ifndef SITRONIX_LEVEL_TRIGGERED
+#define SITRONIX_INT_POLLING_MODE
+#define INT_POLLING_MODE_INTERVAL 14
+#endif /* SITRONIX_LEVEL_TRIGGERED */
+#define SITRONIX_FINGER_COUNT_REG_ENABLE
+
+/*
+ * MT SLOT feature is implmented in linux kernel 2.6.38 and later.
+ * Make sure that version of your linux kernel before using this feature.
+ */
+#define SITRONIX_SUPPORT_MT_SLOT
+/* #define SITRONIX_SWAP_XY */
+
+/**
+ * Enable to used combined i2c function instead of single send/recv calls
+ */
+#define SITRONIX_I2C_COMBINED_MESSAGE
+#ifndef SITRONIX_I2C_COMBINED_MESSAGE
+#define SITRONIX_I2C_SINGLE_MESSAGE
+#endif /* SITRONIX_I2C_COMBINED_MESSAGE */
+
+/**
+ * Enable to allow printing debug messages to kernel log
+ */
+/* #define EnableDbgMsg */
+#ifdef EnableDbgMsg
+ #define DbgMsg(arg...) printk(arg)
+#else
+ #define DbgMsg(arg...)
+#endif
+
+/**
+ * Enumerates all required controller registers
+ */
+typedef enum {
+	/** Firmware version register */
+	FIRMWARE_VERSION = 0x00,
+	/** Status register */
+	STATUS_REG = 0x01,
+	/** Device control register */
+	DEVICE_CONTROL_REG = 0x02,
+	/** Timeout to Idle register */
+	TIMEOUT_TO_IDLE_REG = 0x03,
+	/** XY resolution high value register */
+	XY_RESOLUTION_HIGH = 0x04,
+	/** X resolution low register */
+	X_RESOLUTION_LOW = 0x05,
+	/** Y resolution low register */
+	Y_RESOLUTION_LOW = 0x06,
+	/** Sensing counter high register */
+	SENSING_COUNTER_HIGH = 0x07,
+	/** Sensing counter low register */
+	SENSING_COUNTER_LOW = 0x08,
+	/** Firmware revision register (byte 3) */
+	FIRMWARE_REVISION_3 = 0x0C,
+	/** Firmware revision register (byte 2) */
+	FIRMWARE_REVISION_2 = 0x0D,
+	/** Firmware revision register (byte 1) */
+	FIRMWARE_REVISION_1 = 0x0E,
+	/** Firmware revision register (byte 0) */
+	FIRMWARE_REVISION_0 = 0x0F,
+	/** Advanced touch information register */
+	FINGERS = 0x10,
+	/** Keys register */
+	KEYS_REG = 0x11,
+	/** XY0 Coordination high register */
+	XY0_COORD_H = 0x12,
+	/** X0 coordiantion low register */
+	X0_COORD_L = 0x13,
+	/** Y0 coordination low register */
+	Y0_COORD_L = 0x14,
+	/** XY1 Coordination high register */
+	YY1_COORD_H = 0x16,
+	/** X1 coordiantion low register */
+	X1_COORD_L = 0x17,
+	/** Y1 coordination low register */
+	Y1_COORD_L = 0x18,
+	/** XY2 Coordination high register */
+	XY2_COORD_H = 0x20,
+	/** X2 coordiantion low register */
+	X2_COORD_L = 0x21,
+	/** Y2 coordination low register */
+	Y2_COORD_L = 0x22,
+	/** I2C protocol register */
+	I2C_PROTOCOL = 0x3E,
+	/** Maximum number of contacts support register */
+	MAX_NUM_TOUCHES = 0x3F,
+	/** Chip ID register */
+	CHIP_ID = 0xF4,
+	/** Page selection register */
+	PAGE_REG = 0xff,
+} RegisterOffset;
+
+#define SITRONIX_TS_CHANGE_MODE_DELAY 150
+
+typedef enum stx_pixel_data_format_e {
+	XY_COORD_H,
+	X_COORD_L,
+	Y_COORD_L,
+	PIXEL_DATA_LENGTH_B,
+	PIXEL_DATA_LENGTH_A,
+} stx_pixel_data_format_t;
+
+#define X_RES_H_SHFT 4
+#define X_RES_H_BMSK 0xf
+#define Y_RES_H_SHFT 0
+#define Y_RES_H_BMSK 0xf
+#define FINGERS_SHFT 0
+#define FINGERS_BMSK 0xf
+#define X_COORD_VALID_SHFT 7
+#define X_COORD_VALID_BMSK 0x1
+#define X_COORD_H_SHFT 4
+#define X_COORD_H_BMSK 0x7
+#define Y_COORD_H_SHFT 0
+#define Y_COORD_H_BMSK 0x7
+
+typedef enum i2c_protcol_type_e {
+	SITRONIX_RESERVED_TYPE_0 = 0,
+	SITRONIX_A_TYPE = 1,
+	SITRONIX_B_TYPE = 2,
+} i2c_protcol_type_t;
+
+#define I2C_PROTOCOL_SHFT 0x0
+#define I2C_PROTOCOL_BMSK 0x3
+
+#define SMT_IOC_MAGIC   0xf1
+
+enum {
+	SMT_GET_DRIVER_REVISION = 1,
+	SMT_GET_FW_REVISION,
+	SMT_ENABLE_IRQ,
+	SMT_DISABLE_IRQ,
+	SMT_RESUME,
+	SMT_SUSPEND,
+	SMT_HW_RESET,
+	SMT_IOC_MAXNR,
+};
+
+#define IOCTL_SMT_GET_DRIVER_REVISION    _IOC(_IOC_READ, SMT_IOC_MAGIC, SMT_GET_DRIVER_REVISION, 1)
+#define IOCTL_SMT_GET_FW_REVISION        _IOC(_IOC_READ, SMT_IOC_MAGIC, SMT_GET_FW_REVISION,     4)
+#define IOCTL_SMT_ENABLE_IRQ             _IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_ENABLE_IRQ,          0)
+#define IOCTL_SMT_DISABLE_IRQ            _IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_DISABLE_IRQ,         0)
+#define IOCTL_SMT_RESUME                 _IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_RESUME,              0)
+#define IOCTL_SMT_SUSPEND                _IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_SUSPEND,             0)
+#define IOCTL_SMT_HW_RESET               _IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_HW_RESET,            0)
+
+/* #define SITRONIX_SENSOR_KEY */
+/* #define SITRONIX_TOUCH_KEY */
+/* #define SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY */
+
+typedef struct mtd_structure_s {
+	u16 Pixel_X;
+	u16 Pixel_Y;
+	u8 First_Pressed_area;   /* 0: no press; 1: display; 2: touch key */
+	u8 Current_Pressed_area; /* 0: no press; 1: display; 2: touch key */
+	unsigned int First_key_index;
+	unsigned int Current_key_index;
+} mtd_structure_t;
+
+#ifndef SITRONIX_TOUCH_KEY
+enum {
+	AREA_NONE,
+	AREA_DISPLAY,
+};
+#else
+enum {
+	AREA_NONE,
+	AREA_DISPLAY,
+	AREA_KEY,
+	AREA_INVALID,
+};
+
+struct sitronix_AA_key {
+	int x_low;
+	int x_high;
+	int y_low;
+	int y_high;
+	unsigned int code;
+};
+#endif /* SITRONIX_TOUCH_KEY */
+
+struct sitronix_i2c_touch_platform_data {
+	/*
+	 * Use this entry for panels with
+	 * (major << 8 | minor) version or above.
+	 * If non-zero another array entry follows
+	 */
+	uint32_t version;
+	int (*get_int_status)(void);
+	void (*reset_ic)(void);
+};
+
+#endif /* __SITRONIX_I2C_TOUCH_h */
