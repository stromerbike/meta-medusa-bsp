diff --git a/drivers/Kconfig b/drivers/Kconfig
index e1e2066..662b0ab 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -12,6 +12,8 @@ source "drivers/mtd/Kconfig"
 
 source "drivers/of/Kconfig"
 
+source "drivers/stromer/Kconfig"
+
 source "drivers/parport/Kconfig"
 
 source "drivers/pnp/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 53abb4a..0124cf0 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -8,6 +8,8 @@
 obj-y				+= irqchip/
 obj-y				+= bus/
 
+obj-y				+= stromer/
+
 obj-$(CONFIG_GENERIC_PHY)	+= phy/
 
 # GPIO must come after pinctrl as gpios may need to mux pins etc
diff --git a/drivers/stromer/Kconfig b/drivers/stromer/Kconfig
new file mode 100644
index 0000000..428465c
--- /dev/null
+++ b/drivers/stromer/Kconfig
@@ -0,0 +1,37 @@
+
+menuconfig STROMER_DP
+	tristate "myStromer SUI - Display und Touch driver"
+	---help---
+	  Framebuffer driver for the IMX6UL LCDIF periphery in combination
+	  with the ST7789 based display
+
+if STROMER_DP
+
+config ILI2116_TOUCH
+	tristate "ILI2116 touch controller driver"
+	default m
+	help
+	  ILI2116 Touch controller driver using I2C interfaces
+
+config ST1633_TOUCH
+	tristate "ST1633 touch controller driver"
+	default m
+	help
+	  ST1633 Touch controller driver using I2C interfaces
+
+config IMX6UL_LCDIF_ST7789
+	tristate "LCDIF peripheral driver for a ST7789 display"
+	default y
+	help
+	  LCDIF driver for IMX6UL for usage with a ST7789 based
+	  display
+
+config ST7789_SPI
+	tristate "ST7789 - Supports spi init functionality required for RGB interface"
+	default y
+	depends on IMX6UL_LCDIF_ST7789
+	help
+	  SPI driver for the ST7789 3-wire interface (1. SCL, 2. CS, 3. MISO/MOSI)
+	  providing functions to inititalize the display for RGB interface
+
+endif #STROMER_DP
diff --git a/drivers/stromer/Makefile b/drivers/stromer/Makefile
new file mode 100644
index 0000000..b4feb38
--- /dev/null
+++ b/drivers/stromer/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_ILI2116_TOUCH)        += ili2116.o
+obj-$(CONFIG_ST1633_TOUCH)         += st1633.o
+obj-$(CONFIG_IMX6UL_LCDIF_ST7789)  += fb_imx6_lcdif.o
+obj-$(CONFIG_ST7789_SPI)           += fb_imx6_st7789_spi.o
diff --git a/drivers/stromer/fb_imx6.h b/drivers/stromer/fb_imx6.h
new file mode 100644
index 0000000..3098c75
--- /dev/null
+++ b/drivers/stromer/fb_imx6.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2017 Christian Duenki, Escatec Switzerland AG
+ */
+
+#define DEBUG
+
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+/** SPI driver name */
+#define SPI_DRIVER_NAME "st7789v"
+
+/** Perform SPI init sequence */
+#define DO_SPI_INIT_SEQUENCE
+/** Do panning in spi driver */
+#define DO_SPI_PAN
+/** Register SPI device */
+#define DO_REGISTER_SPI_DEVICE
+/** Do panning in lcdif driver */
+//#define DO_LCDIF_PAN
+
+/** Reset pin responsibility */
+/* define RESET_DONE_BY_LCDIF */
+
+#if defined (RESET_DONE_BY_LCDIF)
+ #define GPIO_LCDIF_RESET  (int)68
+#else
+ #define GPIO_SPI_RESET    (int)68
+#endif
+
+#define NUMARGS(...) (sizeof((int[]){__VA_ARGS__})/sizeof(int))
+
+#define st7789_write_reg(...)				\
+	st7789_write_register(NUMARGS(__VA_ARGS__), __VA_ARGS__)
+
+struct mxsfb_info {
+	struct fb_info fb_info;
+	struct platform_device *pdev;
+	struct clk *clk;
+	struct clk *clk_axi;
+	struct clk *clk_disp_axi;
+	void __iomem *base;	/* registers */
+	unsigned allocated_size;
+	int enabled;
+	unsigned ld_intf_width;
+	unsigned dotclk_delay;
+	const struct mxsfb_devdata *devdata;
+	u32 sync;
+	struct regulator *reg_lcd;
+#if defined (GPIO_LCDIF_RESET)
+	int gpio_reset;
+#endif
+};
diff --git a/drivers/stromer/fb_imx6_lcdif.c b/drivers/stromer/fb_imx6_lcdif.c
new file mode 100644
index 0000000..0062520
--- /dev/null
+++ b/drivers/stromer/fb_imx6_lcdif.c
@@ -0,0 +1,1015 @@
+/*
+ * Copyright (C) 2017 Christian Duenki, Escatec Switzerland AG
+ *
+ * This code is based on:
+ * Author: Juefgen Beisert, Pengutronix
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ */
+/**
+ * @file
+ * @brief LCDIF driver for i.MX6UL (based on mxsfb.c)
+ *
+ * Only the Dotclock mode of the LCDIF is implemented (RGB interface)
+ *
+ * This driver depends on a correct setup of the pins used for this purpose
+ * (platform specific).
+ *
+ * For the developer: Don't forget to set the data bus width to the display
+ * in the imx_fb_videomode structure. You will else end up with ugly colours.
+ * If you fight against jitter you can vary the clock delay. This is a feature
+ * of the i.MX6 and you can vary it between 2 ns ... 8 ns in 2 ns steps. Give
+ * the required value in the imx_fb_videomode structure.
+ */
+
+#include "fb_imx6.h"
+
+#define DRIVER_NAME "mxsfb_st7789"
+
+/* LCDIF part */
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/regulator/consumer.h>
+#include <video/of_display_timing.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+#include <linux/export.h>
+#if defined (GPIO_LCDIF_RESET)
+ #include <linux/gpio.h>
+ #include <linux/delay.h>
+#endif
+
+/* SPI */
+#include <linux/spi/spi.h>
+
+#define REG_SET	4
+#define REG_CLR	8
+
+#define LCDC_CTRL			0x00
+#define LCDC_CTRL1			0x10
+#define LCDC_V4_CTRL2			0x20
+#define LCDC_V4_TRANSFER_COUNT		0x30
+#define LCDC_V4_CUR_BUF			0x40
+#define LCDC_V4_NEXT_BUF		0x50
+#define LCDC_TIMING			0x60
+#define LCDC_VDCTRL0			0x70
+#define LCDC_VDCTRL1			0x80
+#define LCDC_VDCTRL2			0x90
+#define LCDC_VDCTRL3			0xa0
+#define LCDC_VDCTRL4			0xb0
+#define LCDC_DVICTRL0			0xc0
+#define LCDC_DVICTRL1			0xd0
+#define LCDC_DVICTRL2			0xe0
+#define LCDC_DVICTRL3			0xf0
+#define LCDC_DVICTRL4			0x100
+#define LCDC_V4_DATA			0x180
+#define LCDC_V4_DEBUG0			0x1d0
+
+#define CTRL_SFTRST			(1 << 31)
+#define CTRL_CLKGATE			(1 << 30)
+#define CTRL_BYPASS_COUNT		(1 << 19)
+#define CTRL_VSYNC_MODE			(1 << 18)
+#define CTRL_DOTCLK_MODE		(1 << 17)
+#define CTRL_DATA_SELECT		(1 << 16)
+#define CTRL_SET_BUS_WIDTH(x)		(((x) & 0x3) << 10)
+#define CTRL_GET_BUS_WIDTH(x)		(((x) >> 10) & 0x3)
+#define CTRL_SET_WORD_LENGTH(x)		(((x) & 0x3) << 8)
+#define CTRL_GET_WORD_LENGTH(x)		(((x) >> 8) & 0x3)
+#define CTRL_MASTER			(1 << 5)
+#define CTRL_DF16			(1 << 3)
+#define CTRL_DF18			(1 << 2)
+#define CTRL_DF24			(1 << 1)
+#define CTRL_RUN			(1 << 0)
+
+#define CTRL1_FIFO_CLEAR		(1 << 21)
+#define CTRL1_SET_BYTE_PACKAGING(x)	(((x) & 0xf) << 16)
+#define CTRL1_GET_BYTE_PACKAGING(x)	(((x) >> 16) & 0xf)
+
+#define TRANSFER_COUNT_SET_VCOUNT(x)	(((x) & 0xffff) << 16)
+#define TRANSFER_COUNT_GET_VCOUNT(x)	(((x) >> 16) & 0xffff)
+#define TRANSFER_COUNT_SET_HCOUNT(x)	((x) & 0xffff)
+#define TRANSFER_COUNT_GET_HCOUNT(x)	((x) & 0xffff)
+
+#define VDCTRL0_ENABLE_PRESENT		(1 << 28)
+#define VDCTRL0_VSYNC_ACT_HIGH		(1 << 27)
+#define VDCTRL0_HSYNC_ACT_HIGH		(1 << 26)
+#define VDCTRL0_DOTCLK_ACT_FALLING	(1 << 25)
+#define VDCTRL0_ENABLE_ACT_HIGH		(1 << 24)
+#define VDCTRL0_VSYNC_PERIOD_UNIT	(1 << 21)
+#define VDCTRL0_VSYNC_PULSE_WIDTH_UNIT	(1 << 20)
+#define VDCTRL0_HALF_LINE		(1 << 19)
+#define VDCTRL0_HALF_LINE_MODE		(1 << 18)
+#define VDCTRL0_SET_VSYNC_PULSE_WIDTH(x) ((x) & 0x3ffff)
+#define VDCTRL0_GET_VSYNC_PULSE_WIDTH(x) ((x) & 0x3ffff)
+
+#define VDCTRL2_SET_HSYNC_PERIOD(x)	((x) & 0x3ffff)
+#define VDCTRL2_GET_HSYNC_PERIOD(x)	((x) & 0x3ffff)
+
+#define VDCTRL3_MUX_SYNC_SIGNALS	(1 << 29)
+#define VDCTRL3_VSYNC_ONLY		(1 << 28)
+#define SET_HOR_WAIT_CNT(x)		(((x) & 0xfff) << 16)
+#define GET_HOR_WAIT_CNT(x)		(((x) >> 16) & 0xfff)
+#define SET_VERT_WAIT_CNT(x)		((x) & 0xffff)
+#define GET_VERT_WAIT_CNT(x)		((x) & 0xffff)
+
+#define VDCTRL4_SET_DOTCLK_DLY(x)	(((x) & 0x7) << 29)
+#define VDCTRL4_GET_DOTCLK_DLY(x)	(((x) >> 29) & 0x7)
+#define VDCTRL4_SYNC_SIGNALS_ON		(1 << 18)
+#define SET_DOTCLK_H_VALID_DATA_CNT(x)	((x) & 0x3ffff)
+
+#define DEBUG0_HSYNC			(1 < 26)
+#define DEBUG0_VSYNC			(1 < 25)
+
+#define MIN_XRES			120
+#define MIN_YRES			120
+
+#define RED 0
+#define GREEN 1
+#define BLUE 2
+#define TRANSP 3
+
+#define STMLCDIF_8BIT  1 /** pixel data bus to the display is of 8 bit width */
+#define STMLCDIF_16BIT 0 /** pixel data bus to the display is of 16 bit width */
+#define STMLCDIF_18BIT 2 /** pixel data bus to the display is of 18 bit width */
+#define STMLCDIF_24BIT 3 /** pixel data bus to the display is of 24 bit width */
+
+#define MXSFB_SYNC_DATA_ENABLE_HIGH_ACT	(1 << 6)
+#define MXSFB_SYNC_DOTCLK_FALLING_ACT	(1 << 7) /* negtive edge sampling */
+
+//#define SPI_BUS_SPEED 6500000 /* Max read clock cycle 150 ns -> 6.5 MHz */
+#define SPI_BUS_SPEED 1000000
+#define SPI_BUS 0 /** Bus used for display initialization */
+#define SPI_DISP_CS 0 /** CS on selected SPI bus to access display */
+
+/* CPU dependent register offsets */
+struct mxsfb_devdata {
+	unsigned transfer_count;
+	unsigned cur_buf;
+	unsigned next_buf;
+	unsigned debug0;
+	unsigned hs_wdth_mask;
+	unsigned hs_wdth_shift;
+};
+
+static const struct mxsfb_devdata mxsfb_devdata = {
+	.transfer_count = LCDC_V4_TRANSFER_COUNT,
+	.cur_buf = LCDC_V4_CUR_BUF,
+	.next_buf = LCDC_V4_NEXT_BUF,
+	.debug0 = LCDC_V4_DEBUG0,
+	.hs_wdth_mask = 0x3fff,
+	.hs_wdth_shift = 18,
+};
+
+#define to_imxfb_host(x) (container_of(x, struct mxsfb_info, fb_info))
+
+/* mask and shift depends on architecture */
+static inline u32 set_hsync_pulse_width(struct mxsfb_info *host, unsigned val)
+{
+	return (val & host->devdata->hs_wdth_mask) <<
+		host->devdata->hs_wdth_shift;
+}
+
+static inline u32 get_hsync_pulse_width(struct mxsfb_info *host, unsigned val)
+{
+	return (val >> host->devdata->hs_wdth_shift) &
+		host->devdata->hs_wdth_mask;
+}
+
+static const struct fb_bitfield def_rgb565[] = {
+	[RED] = {
+		.offset = 11,
+		.length = 5,
+	},
+	[GREEN] = {
+		.offset = 5,
+		.length = 6,
+	},
+	[BLUE] = {
+		.offset = 0,
+		.length = 5,
+	},
+	[TRANSP] = {	/* no support for transparency */
+		.length = 0,
+	}
+};
+
+static const struct fb_bitfield def_rgb888[] = {
+	[RED] = {
+		.offset = 16,
+		.length = 8,
+	},
+	[GREEN] = {
+		.offset = 8,
+		.length = 8,
+	},
+	[BLUE] = {
+		.offset = 0,
+		.length = 8,
+	},
+	[TRANSP] = {	/* no support for transparency */
+		.length = 0,
+	}
+};
+
+static inline unsigned chan_to_field(unsigned chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int mxsfb_check_var(struct fb_var_screeninfo *var,
+		struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	const struct fb_bitfield *rgb = NULL;
+
+	if (var->xres < MIN_XRES)
+		var->xres = MIN_XRES;
+	if (var->yres < MIN_YRES)
+		var->yres = MIN_YRES;
+
+	var->xres_virtual = var->xres;
+
+	var->yres_virtual = var->yres;
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		/* always expect RGB 565 */
+		rgb = def_rgb565;
+		break;
+	case 32:
+		switch (host->ld_intf_width) {
+		case STMLCDIF_8BIT:
+			pr_debug("Unsupported LCD bus width mapping\n");
+			break;
+		case STMLCDIF_16BIT:
+		case STMLCDIF_18BIT:
+		case STMLCDIF_24BIT:
+			/* real 24 bit */
+			rgb = def_rgb888;
+			break;
+		}
+		break;
+	default:
+		pr_err("Unsupported colour depth: %u\n", var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	/*
+	 * Copy the RGB parameters for this display
+	 * from the machine specific parameters.
+	 */
+	var->red    = rgb[RED];
+	var->green  = rgb[GREEN];
+	var->blue   = rgb[BLUE];
+	var->transp = rgb[TRANSP];
+
+	return 0;
+}
+
+static inline void mxsfb_enable_axi_clk(struct mxsfb_info *host)
+{
+	if (host->clk_axi)
+		clk_prepare_enable(host->clk_axi);
+}
+
+static inline void mxsfb_disable_axi_clk(struct mxsfb_info *host)
+{
+	if (host->clk_axi)
+		clk_disable_unprepare(host->clk_axi);
+}
+
+void mxsfb_enable_controller(struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	u32 reg;
+	int ret;
+
+	dev_dbg(&host->pdev->dev, "%s\n", __func__);
+
+	if (host->reg_lcd) {
+		ret = regulator_enable(host->reg_lcd);
+		if (ret) {
+			dev_err(&host->pdev->dev,
+				"lcd regulator enable failed:	%d\n", ret);
+			return;
+		}
+	}
+
+	if (host->clk_disp_axi)
+		clk_prepare_enable(host->clk_disp_axi);
+	clk_prepare_enable(host->clk);
+	clk_set_rate(host->clk, PICOS2KHZ(fb_info->var.pixclock) * 1000U);
+
+	mxsfb_enable_axi_clk(host);
+
+	/* if it was disabled, re-enable the mode again */
+	writel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_SET);
+
+	/* enable the SYNC signals first, then the DMA engine */
+	reg = readl(host->base + LCDC_VDCTRL4);
+	reg |= VDCTRL4_SYNC_SIGNALS_ON;
+	writel(reg, host->base + LCDC_VDCTRL4);
+
+	writel(CTRL_RUN, host->base + LCDC_CTRL + REG_SET);
+
+	host->enabled = 1;
+}
+EXPORT_SYMBOL(mxsfb_enable_controller);
+
+void mxsfb_disable_controller(struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	unsigned loop;
+	u32 reg;
+	int ret;
+
+	dev_dbg(&host->pdev->dev, "%s\n", __func__);
+
+	/*
+	 * Even if we disable the controller here, it will still continue
+	 * until its FIFOs are running out of data
+	 */
+	writel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_CLR);
+
+	loop = 1000;
+	while (loop) {
+		reg = readl(host->base + LCDC_CTRL);
+		if (!(reg & CTRL_RUN))
+			break;
+		loop--;
+	}
+
+	reg = readl(host->base + LCDC_VDCTRL4);
+	writel(reg & ~VDCTRL4_SYNC_SIGNALS_ON, host->base + LCDC_VDCTRL4);
+
+	mxsfb_disable_axi_clk(host);
+
+	clk_disable_unprepare(host->clk);
+	if (host->clk_disp_axi)
+		clk_disable_unprepare(host->clk_disp_axi);
+
+	host->enabled = 0;
+
+	if (host->reg_lcd) {
+		ret = regulator_disable(host->reg_lcd);
+		if (ret)
+			dev_err(&host->pdev->dev,
+				"lcd regulator disable failed: %d\n", ret);
+	}
+}
+EXPORT_SYMBOL(mxsfb_disable_controller);
+
+static int mxsfb_set_par(struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	u32 ctrl, vdctrl0, vdctrl4;
+	int line_size, fb_size;
+	int reenable = 0;
+
+	line_size =  fb_info->var.xres * (fb_info->var.bits_per_pixel >> 3);
+	fb_size = fb_info->var.yres_virtual * line_size;
+
+	if (fb_size > fb_info->fix.smem_len)
+		return -ENOMEM;
+
+	fb_info->fix.line_length = line_size;
+
+	/*
+	 * It seems, you can't re-program the controller if it is still running.
+	 * This may lead into shifted pictures (FIFO issue?).
+	 * So, first stop the controller and drain its FIFOs
+	 */
+	if (host->enabled) {
+		reenable = 1;
+		mxsfb_disable_controller(fb_info);
+	}
+
+	mxsfb_enable_axi_clk(host);
+
+	/* clear the FIFOs */
+	writel(CTRL1_FIFO_CLEAR, host->base + LCDC_CTRL1 + REG_SET);
+
+	ctrl = CTRL_BYPASS_COUNT | CTRL_MASTER |
+		CTRL_SET_BUS_WIDTH(host->ld_intf_width);
+
+	switch (fb_info->var.bits_per_pixel) {
+	case 16:
+		dev_dbg(&host->pdev->dev, "Setting up RGB565 mode\n");
+		ctrl |= CTRL_SET_WORD_LENGTH(0);
+		writel(CTRL1_SET_BYTE_PACKAGING(0xf), host->base + LCDC_CTRL1);
+		break;
+	case 32:
+		dev_dbg(&host->pdev->dev, "Setting up RGB888/666 mode\n");
+		ctrl |= CTRL_SET_WORD_LENGTH(3);
+		switch (host->ld_intf_width) {
+		case STMLCDIF_8BIT:
+			mxsfb_disable_axi_clk(host);
+			dev_err(&host->pdev->dev,
+					"Unsupported LCD bus width mapping\n");
+			return -EINVAL;
+		case STMLCDIF_16BIT:
+		case STMLCDIF_18BIT:
+		case STMLCDIF_24BIT:
+			/* real 24 bit */
+			break;
+		}
+		/* do not use packed pixels = one pixel per word instead */
+		writel(CTRL1_SET_BYTE_PACKAGING(0x7), host->base + LCDC_CTRL1);
+		break;
+	default:
+		mxsfb_disable_axi_clk(host);
+		dev_err(&host->pdev->dev, "Unhandled color depth of %u\n",
+				fb_info->var.bits_per_pixel);
+		return -EINVAL;
+	}
+
+	writel(ctrl, host->base + LCDC_CTRL);
+
+	writel(TRANSFER_COUNT_SET_VCOUNT(fb_info->var.yres) |
+			TRANSFER_COUNT_SET_HCOUNT(fb_info->var.xres),
+			host->base + host->devdata->transfer_count);
+
+	vdctrl0 = VDCTRL0_ENABLE_PRESENT |	/* always in DOTCLOCK mode */
+		VDCTRL0_VSYNC_PERIOD_UNIT |
+		VDCTRL0_VSYNC_PULSE_WIDTH_UNIT |
+		VDCTRL0_SET_VSYNC_PULSE_WIDTH(fb_info->var.vsync_len);
+	if (fb_info->var.sync & FB_SYNC_HOR_HIGH_ACT)
+		vdctrl0 |= VDCTRL0_HSYNC_ACT_HIGH;
+	if (fb_info->var.sync & FB_SYNC_VERT_HIGH_ACT)
+		vdctrl0 |= VDCTRL0_VSYNC_ACT_HIGH;
+	if (host->sync & MXSFB_SYNC_DATA_ENABLE_HIGH_ACT)
+		vdctrl0 |= VDCTRL0_ENABLE_ACT_HIGH;
+	if (host->sync & MXSFB_SYNC_DOTCLK_FALLING_ACT)
+		vdctrl0 |= VDCTRL0_DOTCLK_ACT_FALLING;
+
+	writel(vdctrl0, host->base + LCDC_VDCTRL0);
+
+	/* frame length in lines */
+	writel(fb_info->var.upper_margin + fb_info->var.vsync_len +
+		fb_info->var.lower_margin + fb_info->var.yres,
+		host->base + LCDC_VDCTRL1);
+
+	/* line length in units of clocks or pixels */
+	writel(set_hsync_pulse_width(host, fb_info->var.hsync_len) |
+		VDCTRL2_SET_HSYNC_PERIOD(fb_info->var.left_margin +
+		fb_info->var.hsync_len + fb_info->var.right_margin +
+		fb_info->var.xres),
+		host->base + LCDC_VDCTRL2);
+
+	writel(SET_HOR_WAIT_CNT(fb_info->var.left_margin +
+		fb_info->var.hsync_len) |
+		SET_VERT_WAIT_CNT(fb_info->var.upper_margin +
+			fb_info->var.vsync_len),
+		host->base + LCDC_VDCTRL3);
+
+	vdctrl4 = SET_DOTCLK_H_VALID_DATA_CNT(fb_info->var.xres);
+	vdctrl4 |= VDCTRL4_SET_DOTCLK_DLY(host->dotclk_delay);
+	writel(vdctrl4, host->base + LCDC_VDCTRL4);
+
+	writel(fb_info->fix.smem_start +
+			fb_info->fix.line_length * fb_info->var.yoffset,
+			host->base + host->devdata->next_buf);
+
+	mxsfb_disable_axi_clk(host);
+
+	if (reenable)
+		mxsfb_enable_controller(fb_info);
+
+	return 0;
+}
+
+static int mxsfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+		u_int transp, struct fb_info *fb_info)
+{
+	unsigned int val;
+	int ret = -EINVAL;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (fb_info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+					7471 * blue) >> 16;
+
+	switch (fb_info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 12 or 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fb_info->pseudo_palette;
+
+			val  = chan_to_field(red, &fb_info->var.red);
+			val |= chan_to_field(green, &fb_info->var.green);
+			val |= chan_to_field(blue, &fb_info->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+static int mxsfb_blank(int blank, struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		if (host->enabled)
+			mxsfb_disable_controller(fb_info);
+		break;
+
+	case FB_BLANK_UNBLANK:
+		if (!host->enabled)
+			mxsfb_enable_controller(fb_info);
+		break;
+	}
+	return 0;
+}
+
+int mxsfb_pan_display(struct fb_var_screeninfo *var,
+					  struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	unsigned offset;
+
+	if (var->xoffset != 0)
+		return -EINVAL;
+
+	offset = fb_info->fix.line_length * var->yoffset;
+
+	mxsfb_enable_axi_clk(host);
+
+	/* update on next VSYNC */
+	writel(fb_info->fix.smem_start + offset,
+			host->base + host->devdata->next_buf);
+
+	mxsfb_disable_axi_clk(host);
+
+	return 0;
+}
+EXPORT_SYMBOL(mxsfb_pan_display);
+
+static struct fb_ops mxsfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = mxsfb_check_var,
+	.fb_set_par = mxsfb_set_par,
+	.fb_setcolreg = mxsfb_setcolreg,
+	.fb_blank = mxsfb_blank,
+	.fb_pan_display = mxsfb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+};
+
+static int mxsfb_restore_mode(struct mxsfb_info *host,
+			struct fb_videomode *vmode)
+{
+	struct fb_info *fb_info = &host->fb_info;
+	unsigned line_count;
+	unsigned period;
+	unsigned long pa, fbsize;
+	int bits_per_pixel, ofs, ret = 0;
+	u32 transfer_count, vdctrl0, vdctrl2, vdctrl3, vdctrl4, ctrl;
+
+	mxsfb_enable_axi_clk(host);
+
+	/* Only restore the mode when the controller is running */
+	ctrl = readl(host->base + LCDC_CTRL);
+	if (!(ctrl & CTRL_RUN)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	vdctrl0 = readl(host->base + LCDC_VDCTRL0);
+	vdctrl2 = readl(host->base + LCDC_VDCTRL2);
+	vdctrl3 = readl(host->base + LCDC_VDCTRL3);
+	vdctrl4 = readl(host->base + LCDC_VDCTRL4);
+
+	transfer_count = readl(host->base + host->devdata->transfer_count);
+
+	vmode->xres = TRANSFER_COUNT_GET_HCOUNT(transfer_count);
+	vmode->yres = TRANSFER_COUNT_GET_VCOUNT(transfer_count);
+
+	switch (CTRL_GET_WORD_LENGTH(ctrl)) {
+	case 0:
+		bits_per_pixel = 16;
+		break;
+	case 3:
+		bits_per_pixel = 32;
+		break;
+	case 1:
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	fb_info->var.bits_per_pixel = bits_per_pixel;
+
+	vmode->pixclock = KHZ2PICOS(clk_get_rate(host->clk) / 1000U);
+	vmode->hsync_len = get_hsync_pulse_width(host, vdctrl2);
+	vmode->left_margin = GET_HOR_WAIT_CNT(vdctrl3) - vmode->hsync_len;
+	vmode->right_margin = VDCTRL2_GET_HSYNC_PERIOD(vdctrl2) -
+		vmode->hsync_len - vmode->left_margin - vmode->xres;
+	vmode->vsync_len = VDCTRL0_GET_VSYNC_PULSE_WIDTH(vdctrl0);
+	period = readl(host->base + LCDC_VDCTRL1);
+	vmode->upper_margin = GET_VERT_WAIT_CNT(vdctrl3) - vmode->vsync_len;
+	vmode->lower_margin = period - vmode->vsync_len -
+		vmode->upper_margin - vmode->yres;
+
+	vmode->vmode = FB_VMODE_NONINTERLACED;
+
+	vmode->sync = 0;
+	if (vdctrl0 & VDCTRL0_HSYNC_ACT_HIGH)
+		vmode->sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (vdctrl0 & VDCTRL0_VSYNC_ACT_HIGH)
+		vmode->sync |= FB_SYNC_VERT_HIGH_ACT;
+
+	pr_debug("Reconstructed video mode:\n");
+	pr_debug("%dx%d, hsync: %u left: %u, right: %u, vsync: %u, upper: %u, lower: %u\n",
+		vmode->xres, vmode->yres, vmode->hsync_len, vmode->left_margin,
+		vmode->right_margin, vmode->vsync_len, vmode->upper_margin,
+		vmode->lower_margin);
+	pr_debug("pixclk: %ldkHz\n", PICOS2KHZ(vmode->pixclock));
+
+	host->ld_intf_width = CTRL_GET_BUS_WIDTH(ctrl);
+	host->dotclk_delay = VDCTRL4_GET_DOTCLK_DLY(vdctrl4);
+
+	fb_info->fix.line_length = vmode->xres * (bits_per_pixel >> 3);
+
+	pa = readl(host->base + host->devdata->cur_buf);
+	fbsize = fb_info->fix.line_length * vmode->yres;
+	if (pa < fb_info->fix.smem_start) {
+		ret = -EINVAL;
+		goto err;
+	}
+	if (pa + fbsize > fb_info->fix.smem_start + fb_info->fix.smem_len) {
+		ret = -EINVAL;
+		goto err;
+	}
+	ofs = pa - fb_info->fix.smem_start;
+	if (ofs) {
+		memmove(fb_info->screen_base, fb_info->screen_base + ofs, fbsize);
+		writel(fb_info->fix.smem_start, host->base + host->devdata->next_buf);
+	}
+
+	line_count = fb_info->fix.smem_len / fb_info->fix.line_length;
+	fb_info->fix.ypanstep = 1;
+
+	clk_prepare_enable(host->clk);
+	host->enabled = 1;
+
+err:
+	if (ret)
+		mxsfb_disable_axi_clk(host);
+
+	return ret;
+}
+
+static int mxsfb_init_fbinfo_dt(struct mxsfb_info *host,
+				struct fb_videomode *vmode)
+{
+	struct fb_info *fb_info = &host->fb_info;
+	struct fb_var_screeninfo *var = &fb_info->var;
+	struct device *dev = &host->pdev->dev;
+	struct device_node *np = host->pdev->dev.of_node;
+	struct device_node *display_np;
+	struct videomode vm;
+	u32 width;
+	int ret;
+
+	display_np = of_parse_phandle(np, "display", 0);
+	if (!display_np) {
+		dev_err(dev, "failed to find display phandle\n");
+		return -ENOENT;
+	}
+
+	ret = of_property_read_u32(display_np, "bus-width", &width);
+	if (ret < 0) {
+		dev_err(dev, "failed to get property bus-width\n");
+		goto put_display_node;
+	}
+
+	switch (width) {
+	case 8:
+		host->ld_intf_width = STMLCDIF_8BIT;
+		break;
+	case 16:
+		host->ld_intf_width = STMLCDIF_16BIT;
+		break;
+	case 18:
+		host->ld_intf_width = STMLCDIF_18BIT;
+		break;
+	case 24:
+		host->ld_intf_width = STMLCDIF_24BIT;
+		break;
+	default:
+		dev_err(dev, "invalid bus-width value\n");
+		ret = -EINVAL;
+		goto put_display_node;
+	}
+
+	ret = of_property_read_u32(display_np, "bits-per-pixel",
+				   &var->bits_per_pixel);
+	if (ret < 0) {
+		dev_err(dev, "failed to get property bits-per-pixel\n");
+		goto put_display_node;
+	}
+
+	ret = of_get_videomode(display_np, &vm, OF_USE_NATIVE_MODE);
+	if (ret) {
+		dev_err(dev, "failed to get videomode from DT\n");
+		goto put_display_node;
+	}
+
+	ret = fb_videomode_from_videomode(&vm, vmode);
+	if (ret < 0)
+		goto put_display_node;
+
+	if (vm.flags & DISPLAY_FLAGS_DE_HIGH)
+		host->sync |= MXSFB_SYNC_DATA_ENABLE_HIGH_ACT;
+	if (vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)
+		host->sync |= MXSFB_SYNC_DOTCLK_FALLING_ACT;
+
+put_display_node:
+	of_node_put(display_np);
+	return ret;
+}
+
+static int mxsfb_init_fbinfo(struct mxsfb_info *host,
+			struct fb_videomode *vmode)
+{
+	int ret;
+	struct fb_info *fb_info = &host->fb_info;
+	struct fb_var_screeninfo *var = &fb_info->var;
+	dma_addr_t fb_phys;
+	void *fb_virt;
+	unsigned fb_size;
+
+	fb_info->fbops = &mxsfb_ops;
+	fb_info->flags = FBINFO_FLAG_DEFAULT | FBINFO_READS_FAST;
+	strlcpy(fb_info->fix.id, "mxs", sizeof(fb_info->fix.id));
+	fb_info->fix.type = FB_TYPE_PACKED_PIXELS;
+	fb_info->fix.ypanstep = 1;
+	fb_info->fix.visual = FB_VISUAL_TRUECOLOR,
+	fb_info->fix.accel = FB_ACCEL_NONE;
+
+	ret = mxsfb_init_fbinfo_dt(host, vmode);
+	if (ret)
+		return ret;
+
+	var->nonstd = 0;
+	var->activate = FB_ACTIVATE_NOW;
+	var->accel_flags = 0;
+	var->vmode = FB_VMODE_NONINTERLACED;
+
+	/* Memory allocation for framebuffer */
+	fb_size = ((var->xres * var->yres) / 8) * 3;
+	fb_virt = alloc_pages_exact(fb_size, GFP_DMA);
+	if (!fb_virt)
+		return -ENOMEM;
+
+	fb_phys = virt_to_phys(fb_virt);
+
+	fb_info->fix.smem_start = fb_phys;
+	fb_info->screen_base = fb_virt;
+	fb_info->screen_size = fb_info->fix.smem_len = fb_size;
+
+	if (mxsfb_restore_mode(host, vmode))
+		memset(fb_virt, 0, fb_size);
+
+	return 0;
+}
+
+static void mxsfb_free_videomem(struct mxsfb_info *host)
+{
+	struct fb_info *fb_info = &host->fb_info;
+
+	free_pages_exact(fb_info->screen_base, fb_info->fix.smem_len);
+}
+
+static const struct platform_device_id mxsfb_devtype[] = {
+	{
+		.name = "imx6ul-fb",
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(platform, mxsfb_devtype);
+
+static const struct of_device_id mxsfb_dt_ids[] = {
+	{ .compatible = "fsl,imx6ul-lcdif", .data = &mxsfb_devtype, },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, mxsfb_dt_ids);
+
+/** Used for control and initialize the display */
+static struct spi_board_info spi_if;
+
+static int mxsfb_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id =
+			of_match_device(mxsfb_dt_ids, &pdev->dev);
+	struct resource *res;
+	struct mxsfb_info *host;
+	struct fb_info *fb_info;
+	struct fb_videomode *mode;
+#if defined (DO_REGISTER_SPI_DEVICE)
+	struct spi_board_info *spi = &spi_if;
+#endif
+	int ret;
+
+	if (of_id)
+		pdev->id_entry = of_id->data;
+
+	fb_info = framebuffer_alloc(sizeof(struct mxsfb_info), &pdev->dev);
+	if (!fb_info) {
+		dev_err(&pdev->dev, "Failed to allocate fbdev\n");
+		return -ENOMEM;
+	}
+
+	mode = devm_kzalloc(&pdev->dev, sizeof(struct fb_videomode),
+			GFP_KERNEL);
+	if (mode == NULL)
+		return -ENOMEM;
+
+	host = to_imxfb_host(fb_info);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	host->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(host->base)) {
+		ret = PTR_ERR(host->base);
+		goto fb_release;
+	}
+
+	host->pdev = pdev;
+	platform_set_drvdata(pdev, host);
+
+	host->devdata = &mxsfb_devdata;
+
+#if defined (GPIO_LCDIF_RESET)
+	ret = gpio_request_one(GPIO_LCDIF_RESET, GPIOF_OUT_INIT_LOW, "st7789v_reset");
+	if (ret) {
+		dev_err(&host->pdev->dev, "Failed to get the reset pin\n");
+		return ret;
+	}
+	/* Generate display reset sequence */
+	gpio_set_value(host->gpio_reset, 1);
+	mdelay(1);
+	gpio_set_value(host->gpio_reset, 0);
+	mdelay(10);
+	gpio_set_value(host->gpio_reset, 1);
+#endif
+#if defined (DO_REGISTER_SPI_DEVICE)
+	/* Fill SPI information to board info struct */
+	strncpy(spi->modalias, SPI_DRIVER_NAME, SPI_NAME_SIZE);
+	spi->chip_select = (u16)SPI_DISP_CS;
+	spi->bus_num = (u16)SPI_BUS;
+	spi->max_speed_hz = (u32)SPI_BUS_SPEED;
+	spi->mode = SPI_MODE_0;
+	spi->controller_data = (void *)fb_info;
+	/* Registrer new device */
+	dev_dbg(&pdev->dev, "Registering SPI device: %s", spi->modalias);
+	ret = spi_register_board_info(spi, 1);
+
+	if (ret) {
+		pr_err("failed to register SPI device\n");
+		return ret;
+	} else {
+		dev_dbg(&pdev->dev, "Successfully registered SPI device");
+	}
+#endif
+	host->clk = devm_clk_get(&host->pdev->dev, NULL);
+	if (IS_ERR(host->clk)) {
+		ret = PTR_ERR(host->clk);
+		goto fb_release;
+	}
+
+	host->clk_axi = devm_clk_get(&host->pdev->dev, "axi");
+	if (IS_ERR(host->clk_axi))
+		host->clk_axi = NULL;
+
+	host->clk_disp_axi = devm_clk_get(&host->pdev->dev, "disp_axi");
+	if (IS_ERR(host->clk_disp_axi))
+		host->clk_disp_axi = NULL;
+
+	host->reg_lcd = devm_regulator_get(&pdev->dev, "lcd");
+	if (IS_ERR(host->reg_lcd))
+		host->reg_lcd = NULL;
+
+	fb_info->pseudo_palette = devm_kzalloc(&pdev->dev, sizeof(u32) * 16,
+					       GFP_KERNEL);
+	if (!fb_info->pseudo_palette) {
+		ret = -ENOMEM;
+		goto fb_release;
+	}
+
+	ret = mxsfb_init_fbinfo(host, mode);
+	if (ret != 0)
+		goto fb_release;
+
+	fb_videomode_to_var(&fb_info->var, mode);
+
+	/* init the color fields */
+	mxsfb_check_var(&fb_info->var, fb_info);
+#if defined (DO_LCDIF_PAN)
+	fb_info->var.xoffset = 0;
+	fb_info->var.yoffset = 0;
+	/* mxsfb_pan_display(&fb_info->var, fb_info); */
+#endif
+
+	platform_set_drvdata(pdev, fb_info);
+
+	ret = register_framebuffer(fb_info);
+	if (ret != 0) {
+		dev_err(&pdev->dev,"Failed to register framebuffer\n");
+		goto fb_destroy;
+	}
+
+	if (!host->enabled) {
+		mxsfb_enable_axi_clk(host);
+		writel(0, host->base + LCDC_CTRL);
+		mxsfb_disable_axi_clk(host);
+		mxsfb_set_par(fb_info);
+		mxsfb_enable_controller(fb_info);
+	}
+	dev_info(&pdev->dev, "initialized\n");
+
+	return 0;
+
+fb_destroy:
+	if (host->enabled)
+		clk_disable_unprepare(host->clk);
+fb_release:
+	framebuffer_release(fb_info);
+
+	return ret;
+}
+
+static int mxsfb_remove(struct platform_device *pdev)
+{
+	struct fb_info *fb_info = platform_get_drvdata(pdev);
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+
+	if (host->enabled)
+		mxsfb_disable_controller(fb_info);
+
+	unregister_framebuffer(fb_info);
+	mxsfb_free_videomem(host);
+
+	framebuffer_release(fb_info);
+
+	return 0;
+}
+
+static void mxsfb_shutdown(struct platform_device *pdev)
+{
+	struct fb_info *fb_info = platform_get_drvdata(pdev);
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+
+	mxsfb_enable_axi_clk(host);
+
+	/*
+	 * Force stop the LCD controller as keeping it running during reboot
+	 * might interfere with the BootROM's boot mode pads sampling.
+	 */
+	writel(CTRL_RUN, host->base + LCDC_CTRL + REG_CLR);
+
+	mxsfb_disable_axi_clk(host);
+}
+
+static struct platform_driver mxsfb_driver = {
+	.probe = mxsfb_probe,
+	.remove = mxsfb_remove,
+	.shutdown = mxsfb_shutdown,
+	.id_table = mxsfb_devtype,
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .of_match_table = mxsfb_dt_ids,
+	},
+};
+
+module_platform_driver(mxsfb_driver);
+
+MODULE_DESCRIPTION("Freescale mxs framebuffer driver");
+MODULE_AUTHOR("Christian Duenki, Escatec Switzerland AG");
+MODULE_LICENSE("GPL");
diff --git a/drivers/stromer/fb_imx6_st7789_spi.c b/drivers/stromer/fb_imx6_st7789_spi.c
new file mode 100644
index 0000000..8dad043
--- /dev/null
+++ b/drivers/stromer/fb_imx6_st7789_spi.c
@@ -0,0 +1,468 @@
+/*
+ * Copyright (C) 2017 Christian Duenki, Escatec Switzerland AG
+ *
+ * This driver is inspired by:
+ *   fbtft, Copyright (C) 2013 Noralf Tronnes
+ *   fb_st7789v, Copyright (C) 2015 Dennis Menschel
+ */
+
+#include "fb_imx6.h"
+
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <video/mipi_display.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+
+#define DEFAULT_GAMMA \
+	"70 2C 2E 15 10 09 48 33 53 0B 19 18 20 25\n" \
+	"70 2C 2E 15 10 09 48 33 53 0B 19 18 20 25"
+
+/**
+ * enum st7789v_command - ST7789V display controller commands
+ *
+ * @PORCTRL: porch setting
+ * @GCTRL: gate control
+ * @VCOMS: VCOM setting
+ * @VDVVRHEN: VDV and VRH command enable
+ * @VRHS: VRH set
+ * @VDVS: VDV set
+ * @VCMOFSET: VCOM offset set
+ * @PWCTRL1: power control 1
+ * @PVGAMCTRL: positive voltage gamma control
+ * @NVGAMCTRL: negative voltage gamma control
+ *
+ * The command names are the same as those found in the datasheet to ease
+ * looking up their semantics and usage.
+ *
+ * Note that the ST7789V display controller offers quite a few more commands
+ * which have been omitted from this list as they are not used at the moment.
+ * Furthermore, commands that are compliant with the MIPI DCS have been left
+ * out as well to avoid duplicate entries.
+ */
+
+enum st7789v_command {
+	RAMWR = 0x2C,
+	RAMCTRL = 0xB0,
+	RGBCTRL = 0xB1,
+	PORCTRL = 0xB2,
+	GCTRL = 0xB7,
+	VCOMS = 0xBB,
+	LCMCTRL = 0xC0,
+	VDVVRHEN = 0xC2,
+	VRHS = 0xC3,
+	VDVS = 0xC4,
+	VCMOFSET = 0xC5,
+	FRCTRL2 = 0xC6,
+	PWCTRL1 = 0xD0,
+	PVGAMCTRL = 0xE0,
+	NVGAMCTRL = 0xE1,
+};
+
+struct st7789_driver_par {
+	struct spi_device *spi;
+	struct fb_info *p_fb_info;
+#if defined (GPIO_SPI_RESET)
+	int gpio_reset;
+#endif
+	u8 *buf;
+};
+
+#define MADCTL_BGR BIT(3) /* bitmask for RGB/BGR order */
+#define MADCTL_MV BIT(5) /* bitmask for page/column order */
+#define MADCTL_MX BIT(6) /* bitmask for column address order */
+#define MADCTL_MY BIT(7) /* bitmask for page address order */
+
+extern void mxsfb_enable_controller(struct fb_info *fb_info);
+extern void mxsfb_disable_controller(struct fb_info *fb_info);
+extern int mxsfb_pan_display(struct fb_var_screeninfo *var,
+							 struct fb_info *fb_info);
+
+void st7789_write_register(int len, ...);
+int st7789_write_spi(void *buf, size_t len);
+int st7789_trx_spi(void *buf_out, void *buf_in, size_t trx_len);
+int st7789_init_display(void);
+
+/** Local driver information */
+static struct st7789_driver_par disp;
+
+void st7789_write_register(int len, ...)
+{
+	va_list args;
+	u16 *buf = NULL;
+	int res, cnt = 0;
+
+	buf = (u16*)kmalloc((size_t)(len * sizeof(u16)), GFP_NOIO);
+
+	va_start(args, len);
+	for (cnt = 0; cnt < len; cnt++) {
+		buf[cnt] = (u16)(((u16)va_arg(args, unsigned int) & 0x00ff) | 0x0100);
+	}
+	va_end(args);
+
+	/* Set data(!command) bit of forst byte */
+	buf[0] &= 0x00ff;
+#if defined (DEBUG)
+	pr_debug("SPI Data: 0x%04x", buf[0]);
+	for (cnt = 1; cnt < len; cnt++) {
+		pr_debug(", 0x%04x", buf[cnt]);
+	}
+	pr_debug("\n");
+#endif
+
+	res = st7789_write_spi(buf, (size_t)(sizeof(u16) * len));
+
+	kfree(buf);
+
+	return;
+}
+
+/**
+ * @brief Transmit spi messages to the stromer-display
+ *
+ * @param buf[in] Data to be sent
+ * @param len[in] Length of message
+ * @return Success
+ */
+int st7789_write_spi(void *buf, size_t len)
+{
+	struct spi_device *spi = disp.spi;
+	struct spi_message m;
+	struct spi_transfer t = {
+		.tx_buf = buf,
+		.len = len,
+	};
+
+	if (!spi) {
+		pr_err("%s: spi is unexpectedly NULL\n", __func__);
+		return PTR_ERR(spi);
+	}
+
+	spi_message_init(&m);
+
+	spi_message_add_tail(&t, &m);
+	return spi_sync(spi, &m);
+}
+/* EXPORT_SYMBOL(st7789_write_spi); */
+
+/**
+ * @brief Transmit and receive spi messages
+ *
+ * @param buf_out[in] Buffer containing data to be sent
+ * @param buf_in[out] Buffer to store received data
+ * @param trx_len[in] Length of transmitt and receive (sum)
+ * @return zero on success, else a negative error code
+ */
+int st7789_trx_spi(void *buf_out, void *buf_in,
+				   size_t trx_len)
+{
+	struct spi_device *spi = disp.spi;
+	struct spi_message m;
+	struct spi_transfer t = {
+		.tx_buf = buf_out,
+		.rx_buf = buf_in,
+		.len = trx_len,
+	};
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+
+	return spi_sync(spi, &m);
+}
+/* EXPORT_SYMBOL(st7789_trx_spi); */
+
+#if 0
+/**
+ * blank() - blank the display
+ *
+ * @on: whether to enable or disable blanking the display
+ *
+ * Return: 0 on success, < 0 if error occurred.
+ */
+static int st7789_spi_blank(bool on)
+{
+	if (on)
+		st7789_write_reg(MIPI_DCS_SET_DISPLAY_OFF);
+	else
+		st7789_write_reg(MIPI_DCS_SET_DISPLAY_ON);
+	return 0;
+}
+/* EXPORT_SYMBOL(st7789_spi_blank); */
+#endif
+
+/**
+ * init_display() - initialize the display controller
+ *
+ * Most of the commands in this init function set their parameters to the
+ * same default values which are already in place after the display has been
+ * powered up. (The main exception to this rule is the pixel format which
+ * would default to 18 instead of 16 bit per pixel.)
+ * Nonetheless, this sequence can be used as a template for concrete
+ * displays which usually need some adjustments.
+ *
+ * Return: 0 on success, < 0 if error occurred.
+ */
+int st7789_init_display(void)
+{
+#if defined (GPIO_SPI_RESET)
+	/* Apply reset sequence */
+	if (gpio_is_valid(disp.gpio_reset)) {
+		/* dummy write to activate spi lines */
+		st7789_write_reg(MIPI_DCS_EXIT_SLEEP_MODE);
+
+		/* Apply clean reset sequence */
+		gpio_set_value(disp.gpio_reset, 1);
+		pr_debug("Set Display reset\n");
+		mdelay(1);
+		gpio_set_value(disp.gpio_reset, 0);
+		pr_debug("Clear Display reset\n");
+		mdelay(10);
+		gpio_set_value(disp.gpio_reset, 1);
+		pr_debug("Set Display reset\n");
+		mdelay(120);
+	}
+#endif
+	/* turn off sleep mode */
+	st7789_write_reg(MIPI_DCS_EXIT_SLEEP_MODE);
+	mdelay(120);
+
+	/* Memory data access contrl */
+	st7789_write_reg(MIPI_DCS_SET_ADDRESS_MODE, 0x00);
+
+	/* Porch settings */
+	st7789_write_reg(PORCTRL, 0x0c, 0x0c, 0x00,  0x33, 0x33);
+
+	/* Gate control
+	 * VGH = 13.26V
+	 * VGL = -10.43V
+	 */
+	st7789_write_reg(GCTRL, 0x35);
+
+	/* VCOM = 1.425 V */
+	st7789_write_reg(VCOMS, 0x35);
+
+	/* LCMCTRL */
+	st7789_write_reg(LCMCTRL, 0x2C);
+
+	/*
+	 * VDV and VRH register values come from command write
+	 * (instead of NVM)
+	 */
+	st7789_write_reg(VDVVRHEN, 0x01);
+
+	/*
+	 * VAP =  4.4V + (VCOM + VCOM offset + 0.5 * VDV)
+	 * VAN = -4.4V + (VCOM + VCOM offset + 0.5 * VDV)
+	 */
+	st7789_write_reg(VRHS, 0x11);
+
+	/* VDV = 0V */
+	st7789_write_reg(VDVS, 0x20);
+
+	/* Frame rate control */
+	st7789_write_reg(FRCTRL2, 0x0F);
+
+	/*
+	 * AVDD = 6.8V
+	 * AVCL = -4.8V
+	 * VDS = 2.3V
+	 */
+	st7789_write_reg(PWCTRL1, 0xA4, 0xA1);
+
+	/* Positive voltage gamma control */
+	st7789_write_reg(PVGAMCTRL, 0xD0, 0x00, 0x06, 0x09, 0x0b, 0x2a, 0x3c, 0x55,
+					 0x4b, 0x08, 0x16, 0x14, 0x19, 0x20);
+
+	/* Negative voltage gamma control */
+	st7789_write_reg(NVGAMCTRL, 0xD0, 0x00, 0x06, 0x09, 0x0b, 0x29, 0x36, 0x54,
+					 0x4b, 0x0d, 0x16, 0x14, 0x21, 0x20);
+
+	/* RAM control */
+	st7789_write_reg(RAMCTRL, 0x11, 0x00, 0x00);
+
+	/* RGB Interface control */
+	st7789_write_reg(RGBCTRL, 0x40, 0x04, 0x0A);
+
+	/* set pixel format to RGB-565 */
+	st7789_write_reg(MIPI_DCS_SET_PIXEL_FORMAT, 0x55); //<-- 0x50 proposed?
+
+	/* Frame rate control */
+	st7789_write_reg(MIPI_DCS_SET_COLUMN_ADDRESS, 0x00, 0x00, 0x00, 0xEF);
+
+	/* Display function control */
+	st7789_write_reg(MIPI_DCS_SET_PAGE_ADDRESS, 0x00, 0x00, 0x01, 0x3F);
+
+	/* Display on */
+	st7789_write_reg(MIPI_DCS_SET_DISPLAY_ON);
+
+	/* Memory write control */
+	st7789_write_reg(RAMWR);
+
+	pr_debug("Display init done...\n");
+
+	return 0;
+}
+/* EXPORT_SYMBOL(st7789_init_display); */
+
+#if 0
+/**
+ * set_gamma() - set gamma curves
+ *
+ * @curves: gamma curves
+ *
+ * Before the gamma curves are applied, they are preprocessed with a bitmask
+ * to ensure syntactically correct input for the display controller.
+ * This implies that the curves input parameter might be changed by this
+ * function and that illegal gamma values are auto-corrected and not
+ * reported as errors.
+ *
+ * Return: 0 on success, < 0 if error occurred.
+ */
+static int set_gamma(unsigned long *curves)
+{
+	/* int i; */
+	/* int j; */
+	/* int c; /\* curve index offset *\/ */
+
+	/* /\* */
+	/*  * Bitmasks for gamma curve command parameters. */
+	/*  * The masks are the same for both positive and negative voltage */
+	/*  * gamma curves. */
+	/*  *\/ */
+	/* const u8 gamma_par_mask[] = { */
+	/* 	0xFF, /\* V63[3:0], V0[3:0]*\/ */
+	/* 	0x3F, /\* V1[5:0] *\/ */
+	/* 	0x3F, /\* V2[5:0] *\/ */
+	/* 	0x1F, /\* V4[4:0] *\/ */
+	/* 	0x1F, /\* V6[4:0] *\/ */
+	/* 	0x3F, /\* J0[1:0], V13[3:0] *\/ */
+	/* 	0x7F, /\* V20[6:0] *\/ */
+	/* 	0x77, /\* V36[2:0], V27[2:0] *\/ */
+	/* 	0x7F, /\* V43[6:0] *\/ */
+	/* 	0x3F, /\* J1[1:0], V50[3:0] *\/ */
+	/* 	0x1F, /\* V57[4:0] *\/ */
+	/* 	0x1F, /\* V59[4:0] *\/ */
+	/* 	0x3F, /\* V61[5:0] *\/ */
+	/* 	0x3F, /\* V62[5:0] *\/ */
+	/* }; */
+
+	/* for (i = 0; i < par->gamma.num_curves; i++) { */
+	/* 	c = i * par->gamma.num_values; */
+	/* 	for (j = 0; j < par->gamma.num_values; j++) */
+	/* 		curves[c + j] &= gamma_par_mask[j]; */
+	/* 	st7789_write_reg( */
+	/* 		par, PVGAMCTRL + i, */
+	/* 		curves[c + 0], curves[c + 1], curves[c + 2], */
+	/* 		curves[c + 3], curves[c + 4], curves[c + 5], */
+	/* 		curves[c + 6], curves[c + 7], curves[c + 8], */
+	/* 		curves[c + 9], curves[c + 10], curves[c + 11], */
+	/* 		curves[c + 12], curves[c + 13]); */
+	/* } */
+	return 0;
+}
+#endif
+
+int st7789_probe_spi(struct spi_device *spi)
+{
+	int ret = 0;
+	struct fb_info *fb_info;
+#if defined (DO_SPI_PAN)
+	struct fb_var_screeninfo *var;
+#endif
+	if (NULL == spi) {
+		return PTR_ERR(spi);
+	}
+
+	/* dev_dbg(spi, "Probing STROMER-ST7789v device"); */
+	pr_debug("Probing STROMER-ST7789v device");
+
+	/* store spi device locally */
+	disp.spi = spi;
+	/* Set mode to 9-Bit */
+	spi->bits_per_word = 9;
+#if defined (GPIO_SPI_RESET)
+	/* Try getting the reset pin */
+	ret = gpio_request_one(GPIO_SPI_RESET, GPIOF_OUT_INIT_LOW, "st7789v_reset");
+	if (ret) {
+		pr_debug("Failed to get the reset pin");
+		return ret;
+	}
+	disp.gpio_reset = GPIO_SPI_RESET;
+#endif
+
+	/* Disable lcdif during initialization */
+	if (!spi->controller_data) {
+		pr_err("No LCDIF controller data!\n");
+		return -1;
+	}
+#if defined (DO_SPI_INIT_SEQUENCE)
+	fb_info = (struct fb_info *)spi->controller_data;
+	mxsfb_disable_controller(fb_info);
+	/* Init and configure display */
+	pr_debug("Configuring display...\n");
+	ret = st7789_init_display();
+ #if defined (DO_SPI_PAN)
+	pr_debug("Do panning\n");
+	var = &(fb_info->var);
+
+	var->xoffset = 0;
+	var->yoffset = 0;
+	mxsfb_pan_display(var, fb_info);
+ #endif
+	mxsfb_enable_controller(fb_info);
+#endif
+	return ret;
+}
+
+int st7789_remove_spi(struct spi_device *spi)
+{
+	/* ToDo! */
+	return 0;
+}
+
+static const struct of_device_id dt_ids[] = {
+	{ .compatible = "st7789v" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, dt_ids);
+
+static struct spi_driver st7789_driver_spi_driver = {
+	.driver = {
+		.name   = "st7789v",
+		/* .of_match_table = of_match_ptr(dt_ids), */
+		.owner = THIS_MODULE,
+	},
+	.probe  = st7789_probe_spi,
+	.remove = st7789_remove_spi,
+};
+
+static int __init st7789_driver_module_init(void)
+{
+	int ret;
+
+	ret = spi_register_driver(&st7789_driver_spi_driver);
+
+	return ret;
+}
+
+static void __exit st7789_driver_module_exit(void)
+{
+	spi_unregister_driver(&st7789_driver_spi_driver);
+}
+
+module_init(st7789_driver_module_init);
+module_exit(st7789_driver_module_exit);
+
+MODULE_ALIAS("spi:" SPI_DRIVER_NAME);
+MODULE_ALIAS("platform:" SPI_DRIVER_NAME);
+MODULE_ALIAS("spi:st7789v");
+MODULE_ALIAS(SPI_DRIVER_NAME);
+
+MODULE_DESCRIPTION("SPI driver for the ST7789V LCD Controller");
+MODULE_AUTHOR("Christian Duenki");
+MODULE_LICENSE("GPL");
diff --git a/drivers/stromer/ili2116.c b/drivers/stromer/ili2116.c
new file mode 100644
index 0000000..ae5014c
--- /dev/null
+++ b/drivers/stromer/ili2116.c
@@ -0,0 +1,469 @@
+#define DEBUG
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/device.h>
+#include "ili2116.h"
+
+#define MAX_TOUCHES		10
+#define DEFAULT_POLL_PERIOD	20
+
+/* Touchscreen commands */
+#define REG_TOUCHDATA		0x10
+#define REG_TOUCH_REPORT    0x11
+#define REG_PANEL_INFO		0x20
+#define REG_FIRMWARE_VERSION	0x40
+#define REG_PROTOCOL_VERSION	0x42
+#define REG_CALIBRATE		0xcc
+
+struct finger {
+	u8 x_low;
+	u8 x_high;
+	u8 y_low;
+	u8 y_high;
+} __packed;
+
+struct finger_read {
+	u8 status;
+	u8 x_high;
+	u8 x_low;
+	u8 y_high;
+	u8 y_low;
+} __packed;
+
+struct touchdata {
+	u8 status;
+	struct finger_read finger[MAX_TOUCHES];
+} __packed;
+
+struct panel_info {
+	/* struct panel_info_finger finger_max; */
+	struct finger finger_max;
+	u8 xchannel_num;
+	u8 ychannel_num;
+	u8 max_report_points;
+	u8 channel_num;
+} __packed;
+
+struct firmware_version {
+	u8 id;
+	u8 major;
+	u8 minor;
+} __packed;
+
+struct protocol_vesion {
+	u8 major;
+	u8 minor;
+	u8 release;
+} __packed;
+
+struct ili2116 {
+	struct i2c_client *client;
+	struct input_dev *input;
+	int gpio_pendown;
+	bool (*get_pendown_state)(struct ili2116 *priv);
+	unsigned int poll_period;
+	unsigned int max_channels;
+	struct delayed_work dwork;
+};
+
+static int ili2116_read_reg(struct i2c_client *client, u8 reg, void *buf,
+			    size_t len)
+{
+	struct i2c_msg msg[2] = {
+		{
+			.addr	= client->addr,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= &reg,
+		},
+		{
+			.addr	= client->addr,
+			.flags	= I2C_M_RD,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+
+	if (i2c_transfer(client->adapter, msg, 2) != 2) {
+		dev_err(&client->dev, "i2c transfer failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void ili2116_report_events(struct input_dev *input,
+								  const struct touchdata *touchdata,
+								  unsigned int num_of_events,
+								  unsigned int num_of_max_events)
+{
+	int i;
+	bool touch;
+	unsigned int x, y;
+	const struct finger_read *finger;
+
+	for (i = 0; i < num_of_max_events; i++) {
+		input_mt_slot(input, i);
+
+		if (i < num_of_events) {
+			finger = &(touchdata->finger)[i];
+			touch = ((finger->status & 0xC0) == 0x80);
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
+			if (touch) {
+				x = finger->x_low | (finger->x_high << 8);
+				y = finger->y_low | (finger->y_high << 8);
+
+				input_report_abs(input, ABS_MT_POSITION_X, x);
+				input_report_abs(input, ABS_MT_POSITION_Y, y);
+			}
+		} else {
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, false);
+		}
+		input_mt_report_pointer_emulation(input, false);
+	}
+
+	input_sync(input);
+}
+
+static void ili2116_work(struct work_struct *work)
+{
+	struct ili2116 *priv = container_of(work, struct ili2116,
+					    dwork.work);
+	struct i2c_client *client = priv->client;
+	struct touchdata touchdata;
+	int error;
+	int cnt;
+
+	error = ili2116_read_reg(client, REG_TOUCHDATA,
+				 &touchdata.status, sizeof(touchdata.status));
+	if (error) {
+		dev_err(&client->dev,
+			"Unable to get touch report, err = %d\n", error);
+		return;
+	}
+	for (cnt = 0; cnt < touchdata.status; cnt++) {
+		error = ili2116_read_reg(client, REG_TOUCH_REPORT,
+								 &touchdata.finger[cnt], sizeof(struct finger_read));
+		if (error) {
+			dev_err(&client->dev,
+					"Unable to get touch report, err = %d\n", error);
+			return;
+		}
+		if (cnt >= MAX_TOUCHES) {
+			break;
+		}
+	}
+
+	ili2116_report_events(priv->input, &touchdata,
+						  touchdata.status, priv->max_channels);
+
+	if ((touchdata.status > 0) || priv->get_pendown_state(priv)) {
+		schedule_delayed_work(&priv->dwork,
+				      msecs_to_jiffies(priv->poll_period));
+	}
+}
+
+static irqreturn_t ili2116_irq(int irq, void *irq_data)
+{
+	struct ili2116 *priv = irq_data;
+
+	schedule_delayed_work(&priv->dwork, 0);
+
+	return IRQ_HANDLED;
+}
+
+static ssize_t ili2116_calibrate(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili2116 *priv = i2c_get_clientdata(client);
+	unsigned long calibrate;
+	int rc;
+	u8 cmd = REG_CALIBRATE;
+
+	if (kstrtoul(buf, 10, &calibrate))
+		return -EINVAL;
+
+	if (calibrate > 1)
+		return -EINVAL;
+
+	if (calibrate) {
+		rc = i2c_master_send(priv->client, &cmd, sizeof(cmd));
+		if (rc != sizeof(cmd))
+			return -EIO;
+	}
+
+	return count;
+}
+static DEVICE_ATTR(calibrate, S_IWUSR, NULL, ili2116_calibrate);
+
+static struct attribute *ili2116_attributes[] = {
+	&dev_attr_calibrate.attr,
+	NULL,
+};
+
+static const struct attribute_group ili2116_attr_group = {
+	.attrs = ili2116_attributes,
+};
+
+static bool ili2116_get_pendown_state(struct ili2116 *priv)
+{
+	bool state = false;
+
+	if (!gpio_get_value(priv->gpio_pendown)) {
+		state = true;
+	}
+
+	return state;
+}
+
+static int ili2116_setup_pendown(struct device *dev,
+				 struct ili2116 *priv)
+{
+	int err;
+
+	err = gpio_request_one(priv->gpio_pendown, GPIOF_IN,
+				       "ili2116_pendown");
+	if (err) {
+		dev_err(dev,
+				"failed to request/setup pendown GPIO%d: %d\n",
+				priv->gpio_pendown, err);
+		return err;
+	}
+
+	return 0;
+}
+
+static int ili2116_i2c_probe(struct i2c_client *client,
+				       const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	const struct ili2116_platform_data *pdata = dev_get_platdata(dev);
+	struct ili2116 *priv;
+	struct input_dev *input;
+	struct panel_info panel;
+	struct protocol_vesion protocol;
+	struct firmware_version firmware;
+	int xmax, ymax;
+	int error;
+	int oftree = 0;
+	dev_dbg(dev, "Probing for ILI2116 I2C Touschreen driver");
+
+	if (!pdata) {
+		dev_err(dev, "No platform data, switching to device tree\n");
+		oftree = 1;
+		/* return -EINVAL; */
+	}
+
+	if (client->irq <= 0) {
+		dev_err(dev, "No IRQ!\n");
+		return -EINVAL;
+	}
+
+	/* Get firmware version */
+	dev_dbg(dev, "Try to read firmware version...");
+	error = ili2116_read_reg(client, REG_FIRMWARE_VERSION,
+				 &firmware, sizeof(firmware));
+	if (error) {
+		dev_err(dev, "Failed to get firmware version, err: %d\n",
+			error);
+		return error;
+	} else {
+			dev_dbg(dev, "Read firmware version");
+	}
+
+	/* get panel info */
+	dev_dbg(dev, "Try to read panel info...");
+	error = ili2116_read_reg(client, REG_PANEL_INFO, &panel, sizeof(panel));
+	if (error) {
+		dev_err(dev, "Failed to get panel information, err: %d\n",
+			error);
+		return error;
+	} else {
+			dev_dbg(dev, "Read panel infos");
+	}
+
+	/* get panel protocol version */
+	dev_dbg(dev, "Try to read protocol version...");
+	error = ili2116_read_reg(client, REG_PROTOCOL_VERSION, &protocol, sizeof(protocol));
+	if (error) {
+		dev_err(dev, "Failed to get panel protocol version, err: %d\n",	error);
+		return error;
+	} else {
+		dev_dbg(dev, "Read panel protocol version 0x%02x 0x%02x 0x%02xh",
+				protocol.major, protocol.minor, protocol.release);
+	}
+
+	xmax = panel.finger_max.x_low | (panel.finger_max.x_high << 8);
+	ymax = panel.finger_max.y_low | (panel.finger_max.y_high << 8);
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	input = input_allocate_device();
+	if (!priv || !input) {
+		error = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	if (oftree) {
+		priv->gpio_pendown = of_get_named_gpio(dev->of_node, "pendown-gpio", 0);
+		if (100 < priv->gpio_pendown) {
+			dev_err(dev, "Unable to read pendown-gpio from device tree\n");
+			return -EINVAL;
+		} else {
+			dev_dbg(dev, "Got Pendown gpio: %d from device tree", priv->gpio_pendown);
+		}
+	}
+	error = ili2116_setup_pendown(dev, priv);
+
+	priv->client = client;
+	priv->input = input;
+	priv->get_pendown_state = ili2116_get_pendown_state;
+	priv->poll_period = DEFAULT_POLL_PERIOD;
+	INIT_DELAYED_WORK(&priv->dwork, ili2116_work);
+
+	/* Setup input device */
+	input->name = "Ili2116 Touchscreen";
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = dev;
+
+	__set_bit(EV_SYN, input->evbit);
+	__set_bit(EV_KEY, input->evbit);
+	__set_bit(EV_ABS, input->evbit);
+	__set_bit(BTN_TOUCH, input->keybit);
+
+	/* Single touch */
+	input_set_abs_params(input, ABS_X, 0, xmax, 0, 0);
+	input_set_abs_params(input, ABS_Y, 0, ymax, 0, 0);
+
+	/* Multi touch */
+	input_mt_init_slots(input, (unsigned int)panel.max_report_points, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_X, 0, xmax, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, ymax, 0, 0);
+
+	/* Add data to private struct */
+	priv->max_channels = panel.max_report_points;
+
+	input_set_drvdata(input, priv);
+	i2c_set_clientdata(client, priv);
+
+	error = request_irq(client->irq, ili2116_irq, (IRQF_TRIGGER_FALLING | IRQF_ONESHOT),
+			    client->name, priv);
+	if (error) {
+		dev_err(dev, "Unable to request touchscreen IRQ, err: %d\n",
+			error);
+		goto err_free_mem;
+	}
+
+	error = sysfs_create_group(&dev->kobj, &ili2116_attr_group);
+	if (error) {
+		dev_err(dev, "Unable to create sysfs attributes, err: %d\n",
+			error);
+		goto err_free_irq;
+	}
+
+	error = input_register_device(priv->input);
+	if (error) {
+		dev_err(dev, "Cannot register input device, err: %d\n", error);
+		goto err_remove_sysfs;
+	}
+
+	device_init_wakeup(&client->dev, 1);
+
+	dev_dbg(dev,
+		"Ili2116 initialized (IRQ: %d), firmware version %d.%d.%d",
+		client->irq, firmware.id, firmware.major, firmware.minor);
+
+	return 0;
+
+err_remove_sysfs:
+	sysfs_remove_group(&dev->kobj, &ili2116_attr_group);
+err_free_irq:
+	free_irq(client->irq, priv);
+err_free_mem:
+	input_free_device(input);
+	kfree(priv);
+	return error;
+}
+
+static int ili2116_i2c_remove(struct i2c_client *client)
+{
+	struct ili2116 *priv = i2c_get_clientdata(client);
+
+	gpio_free(priv->gpio_pendown);
+	sysfs_remove_group(&client->dev.kobj, &ili2116_attr_group);
+	free_irq(priv->client->irq, priv);
+	cancel_delayed_work_sync(&priv->dwork);
+	input_unregister_device(priv->input);
+	kfree(priv);
+
+	return 0;
+}
+
+static int __maybe_unused ili2116_i2c_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (device_may_wakeup(&client->dev))
+		enable_irq_wake(client->irq);
+
+	return 0;
+}
+
+static int __maybe_unused ili2116_i2c_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (device_may_wakeup(&client->dev))
+		disable_irq_wake(client->irq);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(ili2116_i2c_pm,
+			 ili2116_i2c_suspend, ili2116_i2c_resume);
+
+static const struct ili2116_platform_data stromer_ili2116 = {
+	.irq_flags = (IRQF_TRIGGER_FALLING | IRQF_ONESHOT),
+	.poll_period = DEFAULT_POLL_PERIOD,
+};
+
+static const struct i2c_device_id ili2116_i2c_id[] = {
+	{ .name="stromer-ili2116", .driver_data = (long)&stromer_ili2116 },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(i2c, ili2116_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id ili2116_of_match[] = {
+	{ .compatible = "stromer-ili2116", .data = &stromer_ili2116 },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ili2116_of_match);
+#endif
+
+static struct i2c_driver ili2116_ts_driver = {
+	.driver = {
+		.name = "stromer-ili2116",
+		.pm = &ili2116_i2c_pm,
+	},
+	.id_table = ili2116_i2c_id,
+	.probe = ili2116_i2c_probe,
+	.remove = ili2116_i2c_remove,
+};
+
+module_i2c_driver(ili2116_ts_driver);
+
+MODULE_AUTHOR("Christian Duenki <christian.duenki@escatec.com>");
+MODULE_DESCRIPTION("ILI2116 I2C Touchscreen Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/stromer/ili2116.h b/drivers/stromer/ili2116.h
new file mode 100644
index 0000000..dad4765
--- /dev/null
+++ b/drivers/stromer/ili2116.h
@@ -0,0 +1,11 @@
+#ifndef _ILI2116_H
+#define _ILI2116_H
+
+/* struct ili2116_platform_data { */
+struct ili2116_platform_data {
+	unsigned long irq_flags;
+	unsigned int poll_period;
+	bool (*get_pendown_state)(void);
+};
+
+#endif
diff --git a/drivers/stromer/st1633.c b/drivers/stromer/st1633.c
new file mode 100644
index 0000000..45ee7ca
--- /dev/null
+++ b/drivers/stromer/st1633.c
@@ -0,0 +1,3022 @@
+/*
+ * drivers/input/touchscreen/sitronix_i2c_touch.c
+ *
+ * Touchscreen driver for Sitronix (I2C bus)
+ *
+ * Copyright (C) 2011 Sitronix Technology Co., Ltd.
+ *	Rudy Huang <rudy_huang@sitronix.com.tw>
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#ifdef CONFIG_ARCH_SC8810
+#include <linux/init.h>
+#include <mach/ldo.h>
+#include <mach/eic.h>
+#endif // CONFIG_ARCH_SC8810
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif // CONFIG_HAS_EARLYSUSPEND
+#include "st1633.h"
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+#include <linux/cdev.h>
+#include <asm/uaccess.h>
+#ifdef SITRONIX_PERMISSION_THREAD
+#include <linux/fs.h>
+#include <linux/fcntl.h>
+#include <linux/syscalls.h>
+#endif // SITRONIX_PERMISSION_THREAD
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+#include <linux/i2c.h>
+#include <linux/input.h>
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+#include <linux/input/mt.h>
+#endif // SITRONIX_SUPPORT_MT_SLOT
+#include <linux/interrupt.h>
+#include <linux/slab.h> // to be compatible with linux kernel 3.2.15
+#include <linux/gpio.h>
+/* #include <mach/gpio.h> */
+#ifdef SITRONIX_MONITOR_THREAD
+#include <linux/kthread.h>
+#endif // SITRONIX_MONITOR_THREAD
+
+
+#include <linux/kthread.h>
+#include <linux/path.h>
+#include <linux/namei.h>
+
+#ifdef SITRONIX_MULTI_SLAVE_ADDR
+#if defined(CONFIG_MACH_OMAP4_PANDA)
+#include <plat/gpio.h>
+#endif //defined(CONFIG_MACH_OMAP4_PANDA)
+#endif // SITRONIX_MULTI_SLAVE_ADDR
+
+#define DRIVER_AUTHOR           "Sitronix, Inc."
+#define DRIVER_NAME             "sitronix"
+#define DRIVER_DESC             "Sitronix I2C touch"
+#define DRIVER_DATE             "20161104"
+#define DRIVER_MAJOR            2
+#define DRIVER_MINOR         	9
+#define DRIVER_PATCHLEVEL       23
+
+MODULE_AUTHOR("Petitk Kao<petitk_kao@sitronix.com.tw>,Rudy Huang <rudy_huang@sitronix.com.tw>");
+MODULE_DESCRIPTION("Sitronix I2C multitouch panels");
+MODULE_LICENSE("GPL");
+
+char sitronix_sensor_key_status = 0;
+struct sitronix_sensor_key_t sitronix_sensor_key_array[] = {
+	{KEY_BACK}, // bit 0
+	{KEY_HOME}, // bit 1
+	{KEY_MENU}, // bit 2
+};
+#ifdef SITRONIX_AA_KEY
+char sitronix_aa_key_status = 0;
+
+#ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+#define SITRONIX_TOUCH_RESOLUTION_X 480 /* max of X value in display area */
+#define SITRONIX_TOUCH_RESOLUTION_Y 854 /* max of Y value in display area */
+#define SITRONIX_TOUCH_GAP_Y	10  /* Gap between bottom of display and top of touch key */
+#define SITRONIX_TOUCH_MAX_Y 915  /* resolution of y axis of touch ic */
+struct sitronix_AA_key sitronix_aa_key_array[] = {
+	{15, 105, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_MENU}, /* MENU */
+	{135, 225, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_HOME},
+	{255, 345, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_BACK}, /* KEY_EXIT */
+	{375, 465, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_SEARCH},
+};
+#else
+#define SCALE_KEY_HIGH_Y 15
+struct sitronix_AA_key sitronix_aa_key_array[] = {
+	{0, 0, 0, 0, KEY_MENU}, /* MENU */
+	{0, 0, 0, 0, KEY_HOME},
+	{0, 0, 0, 0, KEY_BACK}, /* KEY_EXIT */
+	{0, 0, 0, 0, KEY_SEARCH},
+};
+#endif // SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+#endif // SITRONIX_AA_KEY
+struct sitronix_ts_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct input_dev *keyevent_input;
+	int use_irq;
+#ifndef SITRONIX_INT_POLLING_MODE
+	struct work_struct  work;
+#else
+	struct delayed_work work;
+#endif // SITRONIX_INT_POLLING_MODE
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif // CONFIG_HAS_EARLYSUSPEND
+	uint8_t fw_revision[4];
+	int resolution_x;
+	int resolution_y;
+	uint8_t max_touches;
+	uint8_t touch_protocol_type;
+	uint8_t pixel_length;
+	uint8_t chip_id;
+#ifdef SITRONIX_MONITOR_THREAD
+	uint8_t enable_monitor_thread;
+	uint8_t RawCRC_enabled;
+	int (*sitronix_mt_fp)(void *);
+#endif // SITRONIX_MONITOR_THREAD
+	uint8_t Num_X;
+	uint8_t Num_Y;
+	uint8_t sensing_mode;
+	int suspend_state;
+};
+
+static int i2cErrorCount = 0;
+
+#ifdef SITRONIX_MONITOR_THREAD
+static struct task_struct * SitronixMonitorThread = NULL;
+static int gMonitorThreadSleepInterval = 300; // 0.3 sec
+static atomic_t iMonitorThreadPostpone = ATOMIC_INIT(0);
+
+static uint8_t PreCheckData[4] ;
+static int StatusCheckCount = 0;
+static int sitronix_ts_delay_monitor_thread_start = DELAY_MONITOR_THREAD_START_PROBE; 
+#endif // SITRONIX_MONITOR_THREAD
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void sitronix_ts_early_suspend(struct early_suspend *h);
+static void sitronix_ts_late_resume(struct early_suspend *h);
+#endif // CONFIG_HAS_EARLYSUSPEND
+
+static struct sitronix_ts_data sitronix_ts_gpts = {0};
+static atomic_t sitronix_ts_irq_on = ATOMIC_INIT(0);
+static atomic_t sitronix_ts_in_int = ATOMIC_INIT(0);
+#ifdef SITRONIX_SYSFS
+static bool sitronix_ts_sysfs_created = false;
+static bool sitronix_ts_sysfs_using = false;
+#endif // SITRONIX_SYSFS
+
+static void sitronix_ts_reset_ic(void);
+static int sitronix_ts_disable_int(struct sitronix_ts_data *ts, uint8_t value);
+
+#ifdef ST_UPGRADE_FIRMWARE
+extern int st_upgrade_fw(void);
+#endif //ST_UPGRADE_FIRMWARE
+
+#ifdef ST_TEST_RAW
+extern int st_drv_test_raw();
+#endif //ST_TEST_RAW
+
+#ifdef ST_PEN_SWITCH
+extern int sitronix_ts_pen_switch(struct i2c_client *client,int ison);
+#endif //ST_PEN_SWITCH
+
+#ifdef CONFIG_ARCH_SC8810
+extern int sprd_3rdparty_gpio_tp_rst ;
+extern int sprd_3rdparty_gpio_tp_irq ;
+extern int sprd_3rdparty_tp_ldo_id ;
+extern int sprd_3rdparty_tp_ldo_level;
+
+
+static void sitronix_ts_pwron(void)
+{
+	LDO_SetVoltLevel(LDO_LDO_SIM2, LDO_VOLT_LEVEL0);
+	LDO_TurnOnLDO(LDO_LDO_SIM2);
+	msleep(20);
+}
+
+static int  sitronix_ts_config_pins(void)
+{
+	int irq;
+	sitronix_ts_pwron();
+	gpio_direction_input(sprd_3rdparty_gpio_tp_irq);
+	irq = sprd_alloc_eic_irq(EIC_ID_2);
+
+	sitronix_ts_reset_ic();
+
+	return irq;
+}
+
+static int  sitronix_ts_hw_init(void)
+{
+	int irq;
+	irq = sitronix_ts_config_pins();
+	return irq;
+}
+#endif // CONFIG_ARCH_SC8810
+
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+#ifdef SITRONIX_PERMISSION_THREAD
+SYSCALL_DEFINE3(fchmodat, int, dfd, const char __user *, filename, mode_t, mode);
+static struct task_struct * SitronixPermissionThread = NULL;
+static int sitronix_ts_delay_permission_thread_start = 1000;
+
+static int sitronix_ts_permission_thread(void *data)
+{
+	int ret = 0;
+	int retry = 0;
+	mm_segment_t fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	DbgMsg("%s start\n", __FUNCTION__);
+	do{
+		DbgMsg("delay %d ms\n", sitronix_ts_delay_permission_thread_start);
+		msleep(sitronix_ts_delay_permission_thread_start);
+		ret = sys_fchmodat(AT_FDCWD, "/dev/"SITRONIX_I2C_TOUCH_DEV_NAME , 0666);
+		if(ret < 0)
+			printk("fail to execute sys_fchmodat, ret = %d\n", ret);
+		if(retry++ > 10)
+			break;
+	}while(ret == -ENOENT);
+	set_fs(fs);
+	DbgMsg("%s exit\n", __FUNCTION__);
+	return 0;
+}
+#endif // SITRONIX_PERMISSION_THREAD
+
+int      sitronix_release(struct inode *, struct file *);
+int      sitronix_open(struct inode *, struct file *);
+ssize_t  sitronix_write(struct file *file, const char *buf, size_t count, loff_t *ppos);
+ssize_t  sitronix_read(struct file *file, char *buf, size_t count, loff_t *ppos);
+long	 sitronix_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+static struct cdev sitronix_cdev;
+static struct class *sitronix_class;
+static int sitronix_major = 0;
+
+int  sitronix_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+EXPORT_SYMBOL(sitronix_open);
+
+int  sitronix_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+EXPORT_SYMBOL(sitronix_release);
+
+ssize_t  sitronix_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+	int ret;
+	char *tmp;
+
+	if(!(sitronix_ts_gpts.client))
+		return -EIO;
+
+	if (count > 8192)
+		count = 8192;
+
+	tmp = (char *)kmalloc(count,GFP_KERNEL);
+	if (tmp==NULL)
+		return -ENOMEM;
+	if (copy_from_user(tmp,buf,count)) {
+		kfree(tmp);
+		return -EFAULT;
+	}
+	UpgradeMsg("writing %zu bytes.\n", count);
+
+	ret = i2c_master_send(sitronix_ts_gpts.client, tmp, count);
+	kfree(tmp);
+	return ret;
+}
+EXPORT_SYMBOL(sitronix_write);
+
+ssize_t  sitronix_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	char *tmp;
+	int ret;
+
+	if(!(sitronix_ts_gpts.client))
+		return -EIO;
+
+	if (count > 8192)
+		count = 8192;
+
+	tmp = (char *)kmalloc(count,GFP_KERNEL);
+	if (tmp==NULL)
+		return -ENOMEM;
+
+	UpgradeMsg("reading %zu bytes.\n", count);
+
+	ret = i2c_master_recv(sitronix_ts_gpts.client, tmp, count);
+	if (ret >= 0)
+		ret = copy_to_user(buf,tmp,count)?-EFAULT:ret;
+	kfree(tmp);
+	return ret;
+}
+EXPORT_SYMBOL(sitronix_read);
+
+static int sitronix_ts_resume(struct i2c_client *client);
+static int sitronix_ts_suspend(struct i2c_client *client, pm_message_t mesg);
+void sitronix_ts_reprobe(void);
+long	 sitronix_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	int retval = 0;
+	uint8_t temp[4];
+
+	if (!(sitronix_ts_gpts.client))
+		return -EIO;
+
+	if (_IOC_TYPE(cmd) != SMT_IOC_MAGIC) return -ENOTTY;
+	if (_IOC_NR(cmd) > SMT_IOC_MAXNR) return -ENOTTY;
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE,(void __user *)arg,\
+				 _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err =  !access_ok(VERIFY_READ,(void __user *)arg,\
+				  _IOC_SIZE(cmd));
+	if (err) return -EFAULT;
+
+	switch(cmd) {
+		case IOCTL_SMT_GET_DRIVER_REVISION:
+			UpgradeMsg("IOCTL_SMT_GET_DRIVER_REVISION\n");
+			temp[0] = SITRONIX_TOUCH_DRIVER_VERSION;
+			if(copy_to_user((uint8_t __user *)arg, &temp[0], 1)){
+				UpgradeMsg("fail to get driver version\n");
+				retval = -EFAULT;
+			}
+			break;
+		case IOCTL_SMT_GET_FW_REVISION:
+			UpgradeMsg("IOCTL_SMT_GET_FW_REVISION\n");
+			if(copy_to_user((uint8_t __user *)arg, &(sitronix_ts_gpts.fw_revision[0]), 4))
+					retval = -EFAULT;
+			break;
+		case IOCTL_SMT_ENABLE_IRQ:
+			UpgradeMsg("IOCTL_SMT_ENABLE_IRQ\n");
+			//sitronix_ts_disable_int(&sitronix_ts_gpts, 0);
+			if(!atomic_read(&sitronix_ts_in_int)){
+				if(!atomic_read(&sitronix_ts_irq_on)){
+					atomic_set(&sitronix_ts_irq_on, 1);
+					enable_irq(sitronix_ts_gpts.client->irq);
+#ifdef SITRONIX_MONITOR_THREAD
+					if(sitronix_ts_gpts.enable_monitor_thread == 1){
+						if(!SitronixMonitorThread){
+							atomic_set(&iMonitorThreadPostpone,1);
+							SitronixMonitorThread = kthread_run(sitronix_ts_gpts.sitronix_mt_fp,"Sitronix","Monitorthread");
+							if(IS_ERR(SitronixMonitorThread))
+								SitronixMonitorThread = NULL;
+						}
+					}
+#endif // SITRONIX_MONITOR_THREAD
+				}
+			}
+			break;
+		case IOCTL_SMT_DISABLE_IRQ:
+			UpgradeMsg("IOCTL_SMT_DISABLE_IRQ\n");
+			//sitronix_ts_disable_int(&sitronix_ts_gpts, 1);
+#ifndef SITRONIX_INT_POLLING_MODE
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+			flush_work_sync(&sitronix_ts_gpts.work);
+#endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+#else
+			cancel_delayed_work_sync(&sitronix_ts_gpts.work);
+#endif
+			if(atomic_read(&sitronix_ts_irq_on)){
+				atomic_set(&sitronix_ts_irq_on, 0);
+				disable_irq_nosync(sitronix_ts_gpts.client->irq);
+#ifdef SITRONIX_MONITOR_THREAD
+				if(sitronix_ts_gpts.enable_monitor_thread == 1){
+					if(SitronixMonitorThread){
+						kthread_stop(SitronixMonitorThread);
+						SitronixMonitorThread = NULL;
+					}
+				}
+#endif // SITRONIX_MONITOR_THREAD
+			}
+			break;
+		case IOCTL_SMT_RESUME:
+			UpgradeMsg("IOCTL_SMT_RESUME\n");
+			sitronix_ts_resume(sitronix_ts_gpts.client);
+			break;
+		case IOCTL_SMT_SUSPEND:
+			UpgradeMsg("IOCTL_SMT_SUSPEND\n");
+			sitronix_ts_suspend(sitronix_ts_gpts.client, PMSG_SUSPEND);
+			break;
+		case IOCTL_SMT_HW_RESET:
+			UpgradeMsg("IOCTL_SMT_HW_RESET\n");
+			sitronix_ts_reset_ic();
+			break;
+		case IOCTL_SMT_REPROBE:
+			UpgradeMsg("IOCTL_SMT_REPROBE\n");
+			sitronix_ts_reprobe();
+			break;
+#ifdef ST_TEST_RAW			
+		case IOCTL_SMT_RAW_TEST:
+			UpgradeMsg("IOCTL_SMT_RAW_TEST\n");
+			retval = - st_drv_test_raw();			
+			break;
+#endif
+#ifdef ST_PEN_SWITCH
+		case IOCTL_SMT_PEN_ON:
+			UpgradeMsg("IOCTL_SMT_PEN_ON\n");
+			retval = sitronix_ts_pen_switch(sitronix_ts_gpts.client,1);
+			break;
+		case IOCTL_SMT_PEN_OFF:
+			UpgradeMsg("IOCTL_SMT_PEN_OFF\n");
+			retval = sitronix_ts_pen_switch(sitronix_ts_gpts.client,0);
+			break;
+#endif			
+		default:
+			retval = -ENOTTY;
+	}
+
+	return retval;
+}
+EXPORT_SYMBOL(sitronix_ioctl);
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+
+static void sitronix_ts_reset_ic(void)
+{
+	printk("%s\n", __FUNCTION__);
+
+#ifdef CONFIG_ARCH_MSM
+	gpio_set_value(SITRONIX_RESET_GPIO, 0);
+	msleep(1);
+	gpio_set_value(SITRONIX_RESET_GPIO, 1);
+#elif defined(CONFIG_ARCH_SC8810)
+	gpio_direction_output(sprd_3rdparty_gpio_tp_rst, 1);
+	msleep(3);
+	gpio_set_value(sprd_3rdparty_gpio_tp_rst, 0);
+	msleep(10);
+	gpio_set_value(sprd_3rdparty_gpio_tp_rst,1);
+#else
+#ifndef CONFIG_MACH_CARDHU
+	gpio_request(SITRONIX_RESET_GPIO, "Multitouch Reset");
+	gpio_direction_output(SITRONIX_RESET_GPIO, 1);
+	gpio_set_value(SITRONIX_RESET_GPIO, 0);
+	msleep(1);
+	gpio_set_value(SITRONIX_RESET_GPIO, 1);
+	//gpio_free(SITRONIX_RESET_GPIO);
+#endif // CONFIG_MACH_CARDHU
+#endif // CONFIG_ARCH_MSM
+
+	msleep(SITRONIX_TS_CHANGE_MODE_DELAY);
+}
+
+static int sitronix_i2c_read_bytes(struct i2c_client *client, u8 addr, u8 *rxbuf, int len)
+{
+	int ret = 0;
+	u8 txbuf = addr;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	struct i2c_msg msg[2] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &txbuf,
+		},
+		{
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = rxbuf,
+		},
+	};
+#endif // defined(SITRONIX_I2C_COMBINED_MESSAGE)
+
+	if(rxbuf == NULL)
+		return -1;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	ret = i2c_transfer(client->adapter, &msg[0], 2);
+#elif defined(SITRONIX_I2C_SINGLE_MESSAGE)
+	ret = i2c_master_send(client, &txbuf, 1);
+	if (ret < 0){
+		printk("write 0x%x error (%d)\n", addr, ret);
+		return ret;
+	}
+	ret = i2c_master_recv(client, rxbuf, len);
+#endif // defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	if (ret < 0){
+		DbgMsg("read 0x%x error (%d)\n", addr, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int sitronix_i2c_write_bytes(struct i2c_client *client, u8 *txbuf, int len)
+{
+	int ret = 0;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	struct i2c_msg msg[1] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = len,
+			.buf = txbuf,
+		},
+	};
+#endif // defined(SITRONIX_I2C_COMBINED_MESSAGE)
+
+	if(txbuf == NULL)
+		return -1;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	ret = i2c_transfer(client->adapter, &msg[0], 1);
+#elif defined(SITRONIX_I2C_SINGLE_MESSAGE)
+	ret = i2c_master_send(client, txbuf, len);
+#endif // defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	if (ret < 0){
+		printk("write 0x%x error (%d)\n", *txbuf, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int sitronix_get_fw_revision(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[4];
+
+	ret = sitronix_i2c_read_bytes(ts->client, FIRMWARE_REVISION_3, buffer, 4);
+	if (ret < 0){
+		printk("read fw revision error (%d)\n", ret);
+		return ret;
+	}else{
+		memcpy(ts->fw_revision, buffer, 4);
+		printk("fw revision (hex) = %x %x %x %x\n", buffer[0], buffer[1], buffer[2], buffer[3]);
+	}
+	
+	ret = sitronix_i2c_read_bytes(ts->client, FIRMWARE_VERSION, buffer, 1);
+	if (ret < 0){
+		printk("read fw version error (%d)\n", ret);
+		return ret;
+	}else{		
+		printk("fw version (hex) = %x\n", buffer[0]);
+	}
+	
+	
+	return 0;
+}
+static int sitronix_get_max_touches(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[1];
+
+	ret = sitronix_i2c_read_bytes(ts->client, MAX_NUM_TOUCHES, buffer, 1);
+	if (ret < 0){
+		printk("read max touches error (%d)\n", ret);
+		return ret;
+	}else{
+		ts->max_touches = buffer[0];
+		if (ts->max_touches > SITRONIX_MAX_SUPPORTED_POINT)
+			ts->max_touches = SITRONIX_MAX_SUPPORTED_POINT;
+		printk("max touches = %d \n",ts->max_touches);
+	}
+	return 0;
+}
+
+static int sitronix_get_protocol_type(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[1];
+
+	if(ts->chip_id <= 3){
+		ret = sitronix_i2c_read_bytes(ts->client, I2C_PROTOCOL, buffer, 1);
+		if (ret < 0){
+			printk("read i2c protocol error (%d)\n", ret);
+			return ret;
+		}else{
+			ts->touch_protocol_type = buffer[0] & I2C_PROTOCOL_BMSK;
+			printk("i2c protocol = %d \n", ts->touch_protocol_type);
+			ts->sensing_mode = (buffer[0] & (ONE_D_SENSING_CONTROL_BMSK << ONE_D_SENSING_CONTROL_SHFT)) >> ONE_D_SENSING_CONTROL_SHFT;
+			printk("sensing mode = %d \n", ts->sensing_mode);
+		}
+	}else{
+		ts->touch_protocol_type = SITRONIX_A_TYPE;
+		printk("i2c protocol = %d \n", ts->touch_protocol_type);
+		ret = sitronix_i2c_read_bytes(ts->client, 0xf0, buffer, 1);
+		if (ret < 0){
+			printk("read sensing mode error (%d)\n", ret);
+			return ret;
+		}else{
+			ts->sensing_mode = (buffer[0] & ONE_D_SENSING_CONTROL_BMSK);
+			printk("sensing mode = %d \n", ts->sensing_mode);
+		}
+	}
+	return 0;
+}
+
+static int sitronix_get_resolution(struct sitronix_ts_data *ts)
+{
+	/*
+	int ret = 0;
+	uint8_t buffer[4];
+	int newResX = 800;
+	int newResY = 480;
+	
+	buffer[0] = XY_RESOLUTION_HIGH;
+	buffer[1] = (newResX>>8)<<4 | (newResY>>8);
+	buffer[2] = (newResX&0xFF);
+	buffer[3] = (newResY&0xFF);
+	
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 4);
+	if (ret < 0){
+		printk("set resolution error (%d)\n", ret);
+		return ret;
+	}else{
+		ts->resolution_x = newResX;
+		ts->resolution_y = newResY;
+		printk("resolution = %d x %d\n", ts->resolution_x, ts->resolution_y);
+	}
+	*/
+	int ret = 0;
+	uint8_t buffer[4];
+	
+	ret = sitronix_i2c_read_bytes(ts->client, XY_RESOLUTION_HIGH, buffer, 3);
+	if (ret < 0){
+		printk("read resolution error (%d)\n", ret);
+		return ret;
+	}else{
+		ts->resolution_x = ((buffer[0] & (X_RES_H_BMSK << X_RES_H_SHFT)) << 4) | buffer[1];
+		ts->resolution_y = ((buffer[0] & Y_RES_H_BMSK) << 8) | buffer[2];
+		printk("resolution = %d x %d\n", ts->resolution_x, ts->resolution_y);
+	}
+	return 0;
+	
+}
+
+static int sitronix_ts_get_CHIP_ID(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[3];
+
+	DbgMsg("%s\n", __FUNCTION__);
+
+	ret = sitronix_i2c_read_bytes(ts->client, CHIP_ID, buffer, 3);
+	if (ret < 0){
+		printk("read Chip ID error (%d)\n", ret);
+		return ret;
+	}else{
+		if(buffer[0] == 0){
+			if(buffer[1] + buffer[2] > 32)
+				ts->chip_id = 2;
+			else
+				ts->chip_id = 0;
+		}else
+			ts->chip_id = buffer[0];
+		ts->Num_X = buffer[1];
+		ts->Num_Y = buffer[2];
+		printk("Chip ID = %d\n", ts->chip_id);
+		printk("Num_X = %d\n", ts->Num_X);
+		printk("Num_Y = %d\n", ts->Num_Y);
+	}
+
+	return 0;
+}
+
+static int sitronix_ts_set_powerdown_bit(struct sitronix_ts_data *ts, int value)
+{
+	int ret = 0;
+	uint8_t buffer[2];
+
+	DbgMsg("%s, value = %d\n", __FUNCTION__, value);
+	ret = sitronix_i2c_read_bytes(ts->client, DEVICE_CONTROL_REG, buffer, 1);
+	if (ret < 0){
+		printk("read device control status error (%d)\n", ret);
+		return ret;
+	}else{
+		DbgMsg("dev status = %d \n", buffer[0]);
+	}
+
+	if(value == 0)
+		buffer[1] = buffer[0] & 0xfd;
+	else
+		buffer[1] = buffer[0] | 0x2;
+
+	buffer[0] = DEVICE_CONTROL_REG;
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 2);
+	if (ret < 0){
+		printk("write power down error (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sitronix_ts_disable_int(struct sitronix_ts_data *ts, uint8_t value)
+{
+	int ret = 0;
+	uint8_t buffer[2];
+	sitronix_i2c_protocol_map *i2c_ptcl;
+
+	DbgMsg("%s, value = %d\n", __FUNCTION__, value);
+	i2c_ptcl = (ts->chip_id > 3)? &sitronix_i2c_ptcl_v2 : &sitronix_i2c_ptcl_v1;
+
+	ret = sitronix_i2c_read_bytes(ts->client, i2c_ptcl->dis_coord_flag.offset, buffer, 1);
+	if (ret < 0){
+		printk("read disable coord. flag error (%d)\n", ret);
+		return ret;
+	}
+
+	buffer[1] = buffer[0] & ~(i2c_ptcl->dis_coord_flag.bmsk << i2c_ptcl->dis_coord_flag.shft);
+	buffer[1] |= value;
+
+	buffer[0] = i2c_ptcl->dis_coord_flag.offset;
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 2);
+	if (ret < 0){
+		printk("write disable coord. flag error (%d)\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int sitronix_ts_get_touch_info(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	ret = sitronix_get_resolution(ts);
+	if(ret < 0)
+		return ret;
+	ret = sitronix_ts_get_CHIP_ID(ts);
+	if(ret < 0)
+		return ret;
+	ret = sitronix_get_fw_revision(ts);
+	if(ret < 0)
+		return ret;
+	ret = sitronix_get_protocol_type(ts);
+	if(ret < 0)
+		return ret;
+	ret = sitronix_get_max_touches(ts);
+	if(ret < 0)
+		return ret;
+
+	if((ts->fw_revision[0] == 0) && (ts->fw_revision[1] == 0)){
+		if(ts->touch_protocol_type == SITRONIX_RESERVED_TYPE_0){
+			ts->touch_protocol_type = SITRONIX_B_TYPE;
+			printk("i2c protocol (revised) = %d \n", ts->touch_protocol_type);
+		}
+	}
+	if(ts->touch_protocol_type == SITRONIX_A_TYPE)
+		ts->pixel_length = PIXEL_DATA_LENGTH_A;
+	else if(ts->touch_protocol_type == SITRONIX_B_TYPE){
+		ts->pixel_length = PIXEL_DATA_LENGTH_B;
+		ts->max_touches = 2;
+		printk("max touches (revised) = %d \n", ts->max_touches);
+	}
+
+#ifdef SITRONIX_MONITOR_THREAD
+	ts->RawCRC_enabled = 0;
+	if(ts->chip_id > 3){
+		ts->enable_monitor_thread = 1;
+		ts->RawCRC_enabled = 1;
+	}else if(ts->chip_id == 3){
+		ts->enable_monitor_thread = 1;		
+		//if(((ts->fw_revision[2] << 8) | ts->fw_revision[3]) >= (9 << 8 | 3))
+		if(((ts->fw_revision[2] << 8) | ts->fw_revision[3]) >= (6 << 8 | 3))
+			ts->RawCRC_enabled = 1;
+	}else
+		ts->enable_monitor_thread = 0;
+#endif // SITRONIX_MONITOR_THREAD
+
+	return 0;
+}
+
+static int sitronix_ts_get_device_status(struct i2c_client *client, uint8_t *err_code, uint8_t *dev_status)
+{
+	int ret = 0;
+	uint8_t buffer[8];
+
+	DbgMsg("%s\n", __FUNCTION__);
+	ret = sitronix_i2c_read_bytes(client, STATUS_REG, buffer, 8);
+	if (ret < 0){
+		printk("read status reg error (%d)\n", ret);
+		return ret;
+	}else{
+		printk("status reg = %d \n", buffer[0]);
+	}
+
+	*err_code = (buffer[0] & 0xf0) >> 4;
+	*dev_status = buffer[0] & 0xf;
+
+	return 0;
+}
+
+#ifdef SITRONIX_IDENTIFY_ID
+static int sitronix_ts_Enhance_Function_control(struct sitronix_ts_data *ts, uint8_t *value)
+{
+	int ret = 0;
+	uint8_t buffer[1];
+
+	DbgMsg("%s\n", __FUNCTION__);
+	ret = sitronix_i2c_read_bytes(ts->client, 0xF0, buffer, 1);
+	if (ret < 0){
+		printk("read Enhance Functions status error (%d)\n", ret);
+		return ret;
+	}else{
+		DbgMsg("Enhance Functions status = %d \n", buffer[0]);
+	}
+
+	*value = buffer[0] & 0x4;
+
+	return 0;
+}
+
+static int sitronix_ts_FW_Bank_Select(struct sitronix_ts_data *ts, uint8_t value)
+{
+	int ret = 0;
+	uint8_t buffer[2];
+
+	DbgMsg("%s\n", __FUNCTION__);
+	ret = sitronix_i2c_read_bytes(ts->client, 0xF1, buffer, 1);
+	if (ret < 0){
+		printk("read FW Bank Select status error (%d)\n", ret);
+		return ret;
+	}else{
+		DbgMsg("FW Bank Select status = %d \n", buffer[0]);
+	}
+
+	buffer[1] = ((buffer[0] & 0xfc) | value);
+	buffer[0] = 0xF1;
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 2);
+	if (ret < 0){
+		printk("send FW Bank Select command error (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sitronix_get_id_info(struct sitronix_ts_data *ts, uint8_t *id_info)
+{
+	int ret = 0;
+	uint8_t buffer[4];
+
+	ret = sitronix_i2c_read_bytes(ts->client, 0x0C, buffer, 4);
+	if (ret < 0){
+		printk("read id info error (%d)\n", ret);
+		return ret;
+	}else{
+		memcpy(id_info, buffer, 4);
+	}
+	return 0;
+}
+
+static int sitronix_ts_identify(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t id[4];
+	uint8_t Enhance_Function = 0;
+
+	ret = sitronix_ts_FW_Bank_Select(ts, 1);
+	if(ret < 0)
+		return ret;
+	ret = sitronix_ts_Enhance_Function_control(ts, &Enhance_Function);
+	if(ret < 0)
+		return ret;
+	if(Enhance_Function == 0x4){
+		ret = sitronix_get_id_info(ts, &id[0]);
+		if(ret < 0)
+			return ret;
+		printk("id (hex) = %x %x %x %x\n", id[0], id[1], id[2], id[3]);
+		if((id[0] == 1)&&(id[1] == 2)&&(id[2] == 0xb)&&(id[3] == 1)){
+			return 0;
+		}else{
+			printk("Error: It is not Sitronix IC\n");
+			return -1;
+		}
+	}else{
+		printk("Error: Can not get ID of Sitronix IC\n");
+		return -1;
+	}
+}
+#endif // SITRONIX_IDENTIFY_ID
+
+#ifdef SITRONIX_MONITOR_THREAD
+static int sitronix_set_raw_data_type(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[2] = {0};
+
+	ret = sitronix_i2c_read_bytes(ts->client, DEVICE_CONTROL_REG, buffer, 1);
+	if (ret < 0){
+		DbgMsg("read DEVICE_CONTROL_REG error (%d)\n", ret);
+		return ret;
+	}else{
+		DbgMsg("read DEVICE_CONTROL_REG status = %d \n", buffer[0]);
+	}
+	if(ts->sensing_mode == SENSING_BOTH_NOT){
+		buffer[1] = ((buffer[0] & 0xf3) | (0x01 << 2));
+	}else{
+		buffer[1] = (buffer[0] & 0xf3);
+	}
+	buffer[0] = DEVICE_CONTROL_REG;
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 2);
+	if (ret < 0){
+		DbgMsg("write DEVICE_CONTROL_REG error (%d)\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int sitronix_ts_monitor_thread(void *data)
+{
+	int ret = 0;
+	uint8_t buffer[4] = { 0, 0, 0, 0 };
+	int result = 0;
+	int once = 1;
+	uint8_t raw_data_ofs = 0;
+
+	DbgMsg("%s:\n", __FUNCTION__);
+
+	printk("delay %d ms\n", sitronix_ts_delay_monitor_thread_start);
+	msleep(sitronix_ts_delay_monitor_thread_start);
+	while(!kthread_should_stop()){
+		DbgMsg("%s:\n", "Sitronix_ts_monitoring 2222");
+		if(atomic_read(&iMonitorThreadPostpone)){
+		 		atomic_set(&iMonitorThreadPostpone,0);
+		}else{
+			if(once == 1){
+				ret = sitronix_set_raw_data_type(&sitronix_ts_gpts);
+				if (ret < 0)
+					goto exit_i2c_invalid;
+
+				if((sitronix_ts_gpts.sensing_mode == SENSING_BOTH) || (sitronix_ts_gpts.sensing_mode == SENSING_X_ONLY)){
+					raw_data_ofs = 0x40;
+				}else if(sitronix_ts_gpts.sensing_mode == SENSING_Y_ONLY){
+					raw_data_ofs = 0x40 + sitronix_ts_gpts.Num_X * 2; 
+				}else{
+					raw_data_ofs = 0x40;
+				}
+
+				once = 0;
+			}
+			if(raw_data_ofs != 0x40){
+				ret = sitronix_i2c_read_bytes(sitronix_ts_gpts.client, 0x40, buffer, 1);
+				if (ret < 0){
+					DbgMsg("read raw data error (%d)\n", ret);
+					result = 0;
+					goto exit_i2c_invalid;
+				}
+			}
+			ret = sitronix_i2c_read_bytes(sitronix_ts_gpts.client, raw_data_ofs, buffer, 4);
+			if (ret < 0){
+				DbgMsg("read raw data error (%d)\n", ret);
+				result = 0;
+				goto exit_i2c_invalid;
+			}else{
+				DbgMsg("%dD data h%x-%x = 0x%02x, 0x%02x, 0x%02x, 0x%02x\n", (sitronix_ts_gpts.sensing_mode == SENSING_BOTH_NOT ? 2:1), raw_data_ofs, raw_data_ofs + 3, buffer[0], buffer[1], buffer[2], buffer[3]);
+				//printk("%dD data h%x-%x = 0x%02x, 0x%02x, 0x%02x, 0x%02x\n", (sitronix_ts_gpts.sensing_mode == SENSING_BOTH_NOT ? 2:1), raw_data_ofs, raw_data_ofs + 3, buffer[0], buffer[1], buffer[2], buffer[3]);
+				result = 1;
+				if ((PreCheckData[0] == buffer[0]) && (PreCheckData[1] == buffer[1]) && 
+				(PreCheckData[2] == buffer[2]) && (PreCheckData[3] == buffer[3]))
+					StatusCheckCount ++;
+				else
+					StatusCheckCount =0;
+				PreCheckData[0] = buffer[0];
+				PreCheckData[1] = buffer[1];
+				PreCheckData[2] = buffer[2];
+				PreCheckData[3] = buffer[3];
+				if (3 <= StatusCheckCount){
+					DbgMsg("IC Status doesn't update! \n");
+					result = -1;
+					StatusCheckCount = 0;
+				}
+			}
+			if (-1 == result){
+				printk("Chip abnormal, reset it!\n");
+				sitronix_ts_reset_ic();
+		   		i2cErrorCount = 0;
+		   		StatusCheckCount = 0;
+				if(sitronix_ts_gpts.RawCRC_enabled == 0){
+					ret = sitronix_set_raw_data_type(&sitronix_ts_gpts);
+					if (ret < 0)
+						goto exit_i2c_invalid;
+				}
+			}
+exit_i2c_invalid:
+			if(0 == result){
+				i2cErrorCount ++;
+				if ((2 <= i2cErrorCount)){
+					printk("I2C abnormal, reset it!\n");
+					sitronix_ts_reset_ic();
+					if(sitronix_ts_gpts.RawCRC_enabled == 0)
+						sitronix_set_raw_data_type(&sitronix_ts_gpts);
+		    			i2cErrorCount = 0;
+		    			StatusCheckCount = 0;
+		    		}
+		    	}else
+		    		i2cErrorCount = 0;
+		}
+		msleep(gMonitorThreadSleepInterval);
+	}
+	DbgMsg("%s exit\n", __FUNCTION__);
+	return 0;
+}
+
+static int sitronix_ts_monitor_thread_v2(void *data)
+{
+	int ret = 0;
+	uint8_t buffer[1] = {0};
+	int result = 0;
+
+	DbgMsg("%s:\n", __FUNCTION__);
+
+	printk("delay %d ms\n", sitronix_ts_delay_monitor_thread_start);	
+	msleep(sitronix_ts_delay_monitor_thread_start);
+	while(!kthread_should_stop()){
+		DbgMsg("%s:\n", "Sitronix_ts_monitoring");
+		if(atomic_read(&iMonitorThreadPostpone)){
+		 		atomic_set(&iMonitorThreadPostpone,0);
+		}else{
+			ret = sitronix_i2c_read_bytes(sitronix_ts_gpts.client, 0xA, buffer, 1);
+			if (ret < 0){
+				DbgMsg("read Raw CRC error (%d)\n", ret);
+				result = 0;
+				goto exit_i2c_invalid;
+			}else{
+				DbgMsg("Raw CRC = 0x%02x\n", buffer[0]);
+				//printk("Raw CRC = 0x%02x\n", buffer[0]);
+				result = 1;
+				if (PreCheckData[0] == buffer[0])
+					StatusCheckCount ++;
+				else
+					StatusCheckCount =0;
+				PreCheckData[0] = buffer[0];
+				if (3 <= StatusCheckCount){
+					DbgMsg("IC Status doesn't update! \n");
+					result = -1;
+					StatusCheckCount = 0;
+				}
+			}
+			if (-1 == result){
+				printk("Chip abnormal, reset it!\n");
+				sitronix_ts_reset_ic();
+		   		i2cErrorCount = 0;
+		   		StatusCheckCount = 0;
+			}
+exit_i2c_invalid:
+			if(0 == result){
+				i2cErrorCount ++;
+				if ((2 <= i2cErrorCount)){
+					printk("I2C abnormal, reset it!\n");
+					sitronix_ts_reset_ic();
+		    			i2cErrorCount = 0;
+		    			StatusCheckCount = 0;
+		    		}
+		    	}else
+		    		i2cErrorCount = 0;
+		}
+		msleep(gMonitorThreadSleepInterval);
+	}
+	DbgMsg("%s exit\n", __FUNCTION__);
+	return 0;
+}
+#endif // SITRONIX_MONITOR_THREAD
+
+static inline void sitronix_ts_pen_down(struct input_dev *input_dev, int id, u16 x, u16 y)
+{
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+	input_mt_slot(input_dev, id);
+	input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, true);
+#ifndef SITRONIX_SWAP_XY
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, x);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, y);
+#else
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, y);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, x);
+#endif // SITRONIX_SWAP_XY
+#else
+	input_report_abs(input_dev,  ABS_MT_TRACKING_ID, id);
+#ifndef SITRONIX_SWAP_XY
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, x);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, y);
+#else
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, y);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, x);
+#endif // SITRONIX_SWAP_XY
+	input_report_abs(input_dev,  ABS_MT_TOUCH_MAJOR, 255);
+	input_report_abs(input_dev,  ABS_MT_WIDTH_MAJOR, 255);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	input_report_abs(input_dev, ABS_MT_PRESSURE, 255);
+#endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	input_mt_sync(input_dev);
+#endif // SITRONIX_SUPPORT_MT_SLOT
+	DbgMsg("[%d](%d, %d)+\n", id, x, y);
+}
+
+static inline void sitronix_ts_pen_up(struct input_dev *input_dev, int id)
+{
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+	input_mt_slot(input_dev, id);
+	input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, false);
+#else
+	input_report_abs(input_dev,  ABS_MT_TRACKING_ID, id);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	input_report_abs(input_dev, ABS_MT_PRESSURE, 0);
+#else	// for android 2.1	
+	input_report_abs(input_dev,  ABS_MT_TOUCH_MAJOR, 0);
+	input_report_abs(input_dev,  ABS_MT_WIDTH_MAJOR, 0);
+#endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+#endif // SITRONIX_SUPPORT_MT_SLOT
+	DbgMsg("[%d]-\n", id);
+}
+
+static inline void sitronix_ts_handle_sensor_key(struct input_dev *input_dev, struct sitronix_sensor_key_t *key_array, char *pre_key_status, char cur_key_status, int key_count)
+{
+	
+	int i = 0;
+	for(i = 0; i < key_count; i++){
+		if(cur_key_status & (1 << i)){
+			DbgMsg("sensor key[%d] down\n", i);
+			//printk("kkk down now key %d \n",cur_key_status);
+			input_report_key(input_dev, key_array[i].code, 1);
+
+			input_sync(input_dev);
+		}else{
+			if(*pre_key_status & (1 << i)){
+				//printk("kkk up now key %d \n",cur_key_status);
+				DbgMsg("sensor key[%d] up\n", i);
+				input_report_key(input_dev, key_array[i].code, 0);				
+				input_sync(input_dev);
+			}
+		}
+	}
+	*pre_key_status = cur_key_status;
+}
+
+#ifdef SITRONIX_AA_KEY
+static inline void sitronix_ts_handle_aa_key(struct input_dev *input_dev, struct sitronix_AA_key *key_array, char *pre_key_status, char cur_key_status, int key_count)
+{
+	
+	int i = 0;
+	for(i = 0; i < key_count; i++){
+		if(cur_key_status & (1 << i)){
+			DbgMsg("aa key[%d] down\n", i);
+			input_report_key(input_dev, key_array[i].code, 1);
+			input_sync(input_dev);
+		}else{
+			if(*pre_key_status & (1 << i)){
+				DbgMsg("aa key[%d] up\n", i);
+				input_report_key(input_dev, key_array[i].code, 0);
+				input_sync(input_dev);
+			}
+		}
+	}
+	*pre_key_status = cur_key_status;
+}
+#endif // SITRONIX_AA_KEY
+
+#ifdef SITRONIX_GESTURE
+
+static void sitronix_gesture_func(struct input_dev *input_dev,int id)
+{
+	if(id == G_PALM)
+	{
+		printk("Gesture for Palm to suspend \n");
+		input_report_key(input_dev,KEY_POWER,1);// KEY_LEFT, 1);
+		input_sync(input_dev);
+		input_report_key(input_dev, KEY_POWER, 0);
+		input_sync(input_dev);				
+	}
+}
+
+
+
+#endif
+
+#ifdef SITRONIX_SMART_WAKE_UP
+static int swk_flag = 0;
+static void sitronix_swk_set_swk_enable(struct sitronix_ts_data *ts)
+{
+	
+	int ret = 0;
+	unsigned char buffer[2] = {0};
+	ret = sitronix_i2c_read_bytes(ts->client, MISC_CONTROL, buffer, 1);
+	if(ret == 0)
+	{
+		buffer[1] = buffer[0] | 0x80;
+		buffer[0] = MISC_CONTROL;
+		sitronix_i2c_write_bytes(ts->client, buffer, 2);
+				
+		msleep(500);
+	}
+	
+	
+}
+static void sitronix_swk_func(struct input_dev *input_dev, int id)
+{
+	if(id == DOUBLE_CLICK || id == SINGLE_CLICK)
+	{
+		if(swk_flag == 1)
+		{
+			//do wake up here
+			printk("Smark Wake Up by Double click! \n");
+			input_report_key(input_dev, KEY_POWER, 1);
+			input_sync(input_dev);
+			input_report_key(input_dev, KEY_POWER, 0);
+			input_sync(input_dev);
+			swk_flag = 0;
+		}
+	}
+	else if(id == TOP_TO_DOWN_SLIDE)
+	{
+		printk("Smark Wake Up by TOP_TO_DOWN_SLIDE \n");
+		//do wake up here		
+	}
+	else if(id == DOWN_TO_UP_SLIDE)
+	{
+		printk("Smark Wake Up by DOWN_TO_UP_SLIDE \n");
+		//do wake up here
+			}
+	else if(id == LEFT_TO_RIGHT_SLIDE)
+	{
+		printk("Smark Wake Up by LEFT_TO_RIGHT_SLIDE \n");
+		//do wake up here
+	}
+	else if(id == RIGHT_TO_LEFT_SLIDE)
+	{
+		printk("Smark Wake Up by RIGHT_TO_LEFT_SLIDE \n");
+		//do wake up here
+	} 
+}
+#endif	//SITRONIX_SMART_WAKE_UP
+
+static void sitronix_ts_work_func(struct work_struct *work)
+{
+	int i;
+#ifdef SITRONIX_AA_KEY
+	int j;
+	char aa_key_status = 0;
+#endif // SITRONIX_AA_KEY
+	int ret;
+#ifndef SITRONIX_INT_POLLING_MODE
+	struct sitronix_ts_data *ts = container_of(work, struct sitronix_ts_data, work);
+#else
+	struct sitronix_ts_data *ts = container_of(to_delayed_work(work), struct sitronix_ts_data, work);
+#endif // SITRONIX_INT_POLLING_MODE
+	u16 x, y;
+	uint8_t buffer[1+ SITRONIX_MAX_SUPPORTED_POINT * PIXEL_DATA_LENGTH_A] = {0};
+	uint8_t PixelCount = 0;
+
+	DbgMsg("%s\n",  __FUNCTION__);
+	atomic_set(&sitronix_ts_in_int, 1);
+
+#ifdef SITRONIX_GESTURE
+	if(!ts->suspend_state)
+	{
+		ret = sitronix_i2c_read_bytes(ts->client, FINGERS, buffer, 1);
+		printk("SITRONIX_GESTURE ret:%d ,value:0x%X\n",ret,buffer[0]);
+		buffer[0] &= 0xF;		
+		if((ret == 0 && buffer[0] == G_PALM))
+		{
+			sitronix_gesture_func(ts->keyevent_input,buffer[0]);
+                   	goto exit_invalid_data;
+		}
+	}
+#endif		
+
+#ifdef 	SITRONIX_SMART_WAKE_UP	
+	if(ts->suspend_state){
+//2.9.15 petitk add 
+		ret = sitronix_i2c_read_bytes(ts->client, SMART_WAKE_UP_REG, buffer, 1);
+		if(ret ==0 && buffer[0] !=SWK_NO)
+		{			
+			sitronix_swk_func(ts->keyevent_input, buffer[0]);
+			goto exit_invalid_data;
+		}				
+	}
+#endif	//SITRONIX_SMART_WAKE_UP	
+
+	ret = sitronix_i2c_read_bytes(ts->client, KEYS_REG, buffer, 1 + ts->max_touches * ts->pixel_length);
+	if (ret < 0) {
+		printk("read finger error (%d)\n", ret);
+   		i2cErrorCount++;
+		goto exit_invalid_data;
+	}
+
+	for(i = 0; i < ts->max_touches; i++){
+		if(buffer[1 + i * ts->pixel_length + XY_COORD_H] & 0x80){			
+			
+			x = (u16)(buffer[1 + i * ts->pixel_length + XY_COORD_H] & 0x70) << 4 | buffer[1 + i * ts->pixel_length + X_COORD_L];
+			y = (u16)(buffer[1 + i * ts->pixel_length + XY_COORD_H] & 0x07) << 8 | buffer[1 + i * ts->pixel_length + Y_COORD_L];
+#ifndef SITRONIX_AA_KEY
+			PixelCount++;
+			sitronix_ts_pen_down(ts->input_dev, i, x, y);
+#else
+#ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+			if(y < SITRONIX_TOUCH_RESOLUTION_Y){
+#else
+			if(y < (ts->resolution_y - ts->resolution_y / SCALE_KEY_HIGH_Y)){
+#endif // SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+				PixelCount++;
+				sitronix_ts_pen_down(ts->input_dev, i, x, y);
+				//DbgMsg("AREA_DISPLAY\n");
+			}else{
+				for(j = 0; j < (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)); j++){
+					if((x >= sitronix_aa_key_array[j].x_low) &&
+					(x <= sitronix_aa_key_array[j].x_high) &&
+					(y >= sitronix_aa_key_array[j].y_low) &&
+					(y <= sitronix_aa_key_array[j].y_high)){
+						aa_key_status |= (1 << j);
+						//DbgMsg("AREA_KEY [%d]\n", j);
+						break;
+					}
+				}
+			}
+#endif // SITRONIX_AA_KEY
+		}else{
+			sitronix_ts_pen_up(ts->input_dev, i);
+		}
+	}
+	input_report_key(ts->input_dev, BTN_TOUCH, PixelCount > 0);
+	input_sync(ts->input_dev);	
+
+	//////
+	//if(PixelCount ==0)
+	//	st_upgrade_fw();
+	//////
+	sitronix_ts_handle_sensor_key(ts->keyevent_input, sitronix_sensor_key_array, &sitronix_sensor_key_status, buffer[0], (sizeof(sitronix_sensor_key_array)/sizeof(struct sitronix_sensor_key_t)));
+#ifdef SITRONIX_AA_KEY
+	sitronix_ts_handle_aa_key(ts->keyevent_input, sitronix_aa_key_array, &sitronix_aa_key_status, aa_key_status, (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)));
+#endif // SITRONIX_AA_KEY
+
+exit_invalid_data:
+#ifdef SITRONIX_INT_POLLING_MODE
+	if(PixelCount > 0){
+#ifdef SITRONIX_MONITOR_THREAD
+		if(ts->enable_monitor_thread == 1){
+			atomic_set(&iMonitorThreadPostpone,1);
+		}
+#endif // SITRONIX_MONITOR_THREAD
+		schedule_delayed_work(&ts->work, msecs_to_jiffies(INT_POLLING_MODE_INTERVAL));
+	}else{
+#ifdef CONFIG_HARDIRQS_SW_RESEND
+		printk("Please not set HARDIRQS_SW_RESEND to prevent kernel from sending SW IRQ\n");
+#endif // CONFIG_HARDIRQS_SW_RESEND
+		if (ts->use_irq){
+			atomic_set(&sitronix_ts_irq_on, 1);
+			enable_irq(ts->client->irq);
+		}
+	}
+#endif // SITRONIX_INT_POLLING_MODE
+#if defined(SITRONIX_LEVEL_TRIGGERED)
+	if (ts->use_irq){
+		atomic_set(&sitronix_ts_irq_on, 1);
+		enable_irq(ts->client->irq);
+	}
+#endif // defined(SITRONIX_LEVEL_TRIGGERED)
+	if ((2 <= i2cErrorCount)){
+		printk("I2C abnormal in work_func(), reset it!\n");
+		sitronix_ts_reset_ic();
+   		i2cErrorCount = 0;
+#ifdef SITRONIX_MONITOR_THREAD
+		if(ts->enable_monitor_thread == 1){
+			StatusCheckCount = 0;
+			if(ts->RawCRC_enabled == 0)
+				sitronix_set_raw_data_type(&sitronix_ts_gpts);
+		}
+#endif // SITRONIX_MONITOR_THREAD
+	}
+	atomic_set(&sitronix_ts_in_int, 0);
+}
+
+static irqreturn_t sitronix_ts_irq_handler(int irq, void *dev_id)
+{
+	struct sitronix_ts_data *ts = dev_id;
+
+	DbgMsg("%s\n", __FUNCTION__);
+	atomic_set(&sitronix_ts_in_int, 1);
+#if defined(SITRONIX_LEVEL_TRIGGERED) || defined(SITRONIX_INT_POLLING_MODE)
+	atomic_set(&sitronix_ts_irq_on, 0);
+	disable_irq_nosync(ts->client->irq);
+#endif // defined(SITRONIX_LEVEL_TRIGGERED) || defined(SITRONIX_INT_POLLING_MODE)
+#ifdef SITRONIX_MONITOR_THREAD
+	if(ts->enable_monitor_thread == 1){
+		atomic_set(&iMonitorThreadPostpone,1);
+	}
+#endif // SITRONIX_MONITOR_THREAD
+#ifndef SITRONIX_INT_POLLING_MODE
+	schedule_work(&ts->work);
+#else
+	schedule_delayed_work(&ts->work, msecs_to_jiffies(0));
+#endif // SITRONIX_INT_POLLING_MODE
+	return IRQ_HANDLED;
+}
+
+#ifdef SITRONIX_SYSFS
+static ssize_t sitronix_ts_reprobe_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	printk("sitronix_ts_reprobe_store!!!!!\n");
+	sitronix_ts_sysfs_using = true;
+	sitronix_ts_reprobe();
+	sitronix_ts_sysfs_using = false;
+	return count;
+}
+
+static DEVICE_ATTR(reprobe, 0222, NULL, sitronix_ts_reprobe_store);
+
+static struct attribute *sitronix_ts_attrs_v0[] = {
+	&dev_attr_reprobe.attr,
+	NULL,
+};
+
+static struct attribute_group sitronix_ts_attr_group_v0 = {
+	.name = "sitronix_ts_attrs",
+	.attrs = sitronix_ts_attrs_v0,
+};
+
+static int sitronix_ts_create_sysfs_entry(struct i2c_client *client)
+{
+	int err;
+
+	err = sysfs_create_group(&(client->dev.kobj), &sitronix_ts_attr_group_v0);
+	if (err) {
+		dev_warn(&client->dev, "%s(%u): sysfs_create_group() failed!\n", __FUNCTION__, __LINE__);
+	}
+	return err;
+}
+
+static void sitronix_ts_destroy_sysfs_entry(struct i2c_client *client)
+{
+	sysfs_remove_group(&(client->dev.kobj), &sitronix_ts_attr_group_v0);
+
+	return;
+}
+#endif // SITRONIX_SYSFS
+
+static int sitronix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int i;
+	int ret = 0;
+	uint16_t max_x = 0, max_y = 0;
+	uint8_t err_code = 0;
+	uint8_t dev_status = 0;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+#ifdef CONFIG_ARCH_MSM
+	gpio_tlmm_config(GPIO_CFG(SITRONIX_RESET_GPIO, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+#endif // CONFIG_ARCH_MSM
+#ifdef CONFIG_ARCH_SC8810
+	client->irq = sitronix_ts_hw_init();
+#else
+	sitronix_ts_reset_ic();
+#endif // CONFIG_ARCH_SC8810
+
+
+	sitronix_ts_gpts.client = client;
+#ifdef ST_UPGRADE_FIRMWARE
+#ifdef ST_FIREWARE_FILE
+	kthread_run(st_upgrade_fw, "Sitronix", "sitronix_update");
+#else
+	st_upgrade_fw();
+#endif //ST_FIREWARE_FILE
+	 
+#endif //ST_UPGRADE_FIRMWARE
+
+	if(((ret = sitronix_ts_get_device_status(client, &err_code, &dev_status)) < 0) || (dev_status == 0x6) || ((err_code == 0x8)&&(dev_status == 0x0))){
+		if((dev_status == 0x6) || ((err_code == 0x8)&&(dev_status == 0x0))){
+			sitronix_ts_gpts.client = client;
+		}
+		ret = -EPERM;
+		goto err_device_info_error;
+	}
+
+	
+	sitronix_ts_gpts.suspend_state = 0;
+	i2c_set_clientdata(client, &sitronix_ts_gpts);
+	if((ret = sitronix_ts_get_touch_info(&sitronix_ts_gpts)) < 0)
+		goto err_device_info_error;
+
+#ifdef SITRONIX_IDENTIFY_ID
+	if((ret = sitronix_ts_identify(&sitronix_ts_gpts)) < 0)
+		goto err_device_info_error;
+#endif // SITRONIX_IDENTIFY_ID
+
+#ifndef SITRONIX_INT_POLLING_MODE
+	INIT_WORK(&(sitronix_ts_gpts.work), sitronix_ts_work_func);
+#else
+	INIT_DELAYED_WORK(&(sitronix_ts_gpts.work), sitronix_ts_work_func);
+#endif // SITRONIX_INT_POLLING_MODE
+
+#ifdef SITRONIX_MONITOR_THREAD
+	if(sitronix_ts_gpts.enable_monitor_thread == 1){
+		//== Add thread to monitor chip
+		atomic_set(&iMonitorThreadPostpone,1);
+		sitronix_ts_gpts.sitronix_mt_fp = sitronix_ts_gpts.RawCRC_enabled? sitronix_ts_monitor_thread_v2 : sitronix_ts_monitor_thread;
+		SitronixMonitorThread = kthread_run(sitronix_ts_gpts.sitronix_mt_fp,"Sitronix","Monitorthread");
+		if(IS_ERR(SitronixMonitorThread))
+			SitronixMonitorThread = NULL;
+	}
+#endif // SITRONIX_MONITOR_THREAD
+
+	sitronix_ts_gpts.input_dev = input_allocate_device();
+	if (sitronix_ts_gpts.input_dev == NULL){
+		printk("Can not allocate memory for input device.");
+		ret = -ENOMEM;
+		goto err_input_dev_alloc_failed;
+	}
+
+	sitronix_ts_gpts.input_dev->name = SITRONIX_I2C_TOUCH_MT_INPUT_DEV_NAME;
+	sitronix_ts_gpts.input_dev->dev.parent = &client->dev;
+	sitronix_ts_gpts.input_dev->id.bustype = BUS_I2C;
+
+	set_bit(EV_KEY, sitronix_ts_gpts.input_dev->evbit);
+	set_bit(BTN_TOUCH, sitronix_ts_gpts.input_dev->keybit);
+	set_bit(EV_ABS, sitronix_ts_gpts.input_dev->evbit);
+
+	sitronix_ts_gpts.keyevent_input = input_allocate_device();
+	if (sitronix_ts_gpts.keyevent_input == NULL){
+		printk("Can not allocate memory for key input device.");
+		ret = -ENOMEM;
+		goto err_input_dev_alloc_failed;
+	}
+	sitronix_ts_gpts.keyevent_input->name  = SITRONIX_I2C_TOUCH_KEY_INPUT_DEV_NAME;
+	sitronix_ts_gpts.keyevent_input->dev.parent = &client->dev;
+	set_bit(EV_KEY, sitronix_ts_gpts.keyevent_input->evbit);
+	for(i = 0; i < (sizeof(sitronix_sensor_key_array)/sizeof(struct sitronix_sensor_key_t)); i++){
+		set_bit(sitronix_sensor_key_array[i].code, sitronix_ts_gpts.keyevent_input->keybit);
+	}
+#ifdef SITRONIX_SMART_WAKE_UP
+	set_bit(KEY_POWER, sitronix_ts_gpts.keyevent_input->keybit);
+#endif	//SITRONIX_SMART_WAKE_UP
+
+#ifndef SITRONIX_AA_KEY
+	max_x = sitronix_ts_gpts.resolution_x;
+	max_y = sitronix_ts_gpts.resolution_y;
+#else
+#ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+	for(i = 0; i < (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)); i++){
+		set_bit(sitronix_aa_key_array[i].code, sitronix_ts_gpts.keyevent_input->keybit);
+	}
+	max_x = SITRONIX_TOUCH_RESOLUTION_X;
+	max_y = SITRONIX_TOUCH_RESOLUTION_Y;
+#else
+	for(i = 0; i < (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)); i++){
+		sitronix_aa_key_array[i].x_low = ((sitronix_ts_gpts.resolution_x / (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)) ) * i ) + 15;
+		sitronix_aa_key_array[i].x_high = ((sitronix_ts_gpts.resolution_x / (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)) ) * (i + 1)) - 15;
+		sitronix_aa_key_array[i].y_low = sitronix_ts_gpts.resolution_y - sitronix_ts_gpts.resolution_y / SCALE_KEY_HIGH_Y;
+		sitronix_aa_key_array[i].y_high = sitronix_ts_gpts.resolution_y;
+		DbgMsg("key[%d] %d, %d, %d, %d\n", i, sitronix_aa_key_array[i].x_low, sitronix_aa_key_array[i].x_high, sitronix_aa_key_array[i].y_low, sitronix_aa_key_array[i].y_high);
+		set_bit(sitronix_aa_key_array[i].code, sitronix_ts_gpts.keyevent_input->keybit);
+	}
+	max_x = sitronix_ts_gpts.resolution_x;
+	max_y = sitronix_ts_gpts.resolution_y - sitronix_ts_gpts.resolution_y / SCALE_KEY_HIGH_Y;
+#endif // SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+#endif // SITRONIX_AA_KEY
+	ret = input_register_device(sitronix_ts_gpts.keyevent_input);
+	if(ret < 0){
+		printk("Can not register key input device.\n");
+		goto err_input_register_device_failed;
+	}	
+
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+	input_mt_init_slots(sitronix_ts_gpts.input_dev, sitronix_ts_gpts.max_touches);
+#else
+	__set_bit(ABS_X, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_Y, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_TOUCH_MAJOR, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_WIDTH_MAJOR, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_POSITION_X, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_POSITION_Y, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_TOOL_TYPE, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_BLOB_ID, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_TRACKING_ID, sitronix_ts_gpts.input_dev->absbit);
+
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_TOUCH_MAJOR, 0,  255, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_WIDTH_MAJOR, 0,  255, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_TRACKING_ID, 0, sitronix_ts_gpts.max_touches, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+#endif // SITRONIX_SUPPORT_MT_SLOT
+#ifndef SITRONIX_SWAP_XY
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_X, 0, max_x, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_Y, 0, max_y, 0, 0);
+#else
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_X, 0, max_y, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_Y, 0, max_x, 0, 0);
+#endif // SITRONIX_SWAP_XY
+
+	ret = input_register_device(sitronix_ts_gpts.input_dev);
+	if(ret < 0){
+		printk("Can not register input device.\n");
+		goto err_input_register_device_failed;
+	}
+
+#ifdef CONFIG_ARCH_MSM
+	gpio_tlmm_config(GPIO_CFG(SITRONIX_INT_GPIO, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+#endif // CONFIG_ARCH_MSM
+
+#ifdef SITRONIX_MULTI_SLAVE_ADDR
+#if defined(CONFIG_MACH_OMAP4_PANDA)
+	client->irq = OMAP_GPIO_IRQ(SITRONIX_INT_GPIO);
+#endif //defined(CONFIG_MACH_OMAP4_PANDA)
+#endif // SITRONIX_MULTI_SLAVE_ADDR
+	if (client->irq){
+		dev_info(&client->dev, "irq = %d\n", client->irq);
+#ifdef SITRONIX_LEVEL_TRIGGERED
+		ret = request_irq(client->irq, sitronix_ts_irq_handler, IRQF_TRIGGER_LOW | IRQF_DISABLED, client->name, &sitronix_ts_gpts);
+#else
+		ret = request_irq(client->irq, sitronix_ts_irq_handler, IRQF_TRIGGER_FALLING | IRQF_DISABLED, client->name, &sitronix_ts_gpts);
+#endif // SITRONIX_LEVEL_TRIGGERED
+		if (ret == 0){
+			atomic_set(&sitronix_ts_irq_on, 1);
+			sitronix_ts_gpts.use_irq = 1;
+		}else{
+			dev_err(&client->dev, "request_irq failed\n");
+			goto err_request_irq_failed;
+		}
+	}
+
+#ifdef SITRONIX_SYSFS
+	if(!sitronix_ts_sysfs_created){
+		ret = sitronix_ts_create_sysfs_entry(client);
+		if(ret < 0)
+			goto err_create_sysfs_failed;
+		sitronix_ts_sysfs_created = true;
+	}
+#endif // SITRONIX_SYSFS
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	sitronix_ts_gpts.early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	sitronix_ts_gpts.early_suspend.suspend = sitronix_ts_early_suspend;
+	sitronix_ts_gpts.early_suspend.resume = sitronix_ts_late_resume;
+	register_early_suspend(&sitronix_ts_gpts.early_suspend);	
+#endif // CONFIG_HAS_EARLYSUSPEND
+
+
+#ifdef ST_TEST_RAW
+	st_drv_test_raw();
+#endif //ST_TEST_RAW
+
+	return 0;
+err_create_sysfs_failed:
+err_request_irq_failed:
+#ifdef SITRONIX_SYSFS
+	input_unregister_device(sitronix_ts_gpts.input_dev);
+	input_unregister_device(sitronix_ts_gpts.keyevent_input);
+#endif // SITRONIX_SYSFS
+err_input_register_device_failed:
+err_input_dev_alloc_failed:
+	if(sitronix_ts_gpts.input_dev)
+		input_free_device(sitronix_ts_gpts.input_dev);
+	if(sitronix_ts_gpts.keyevent_input)
+		input_free_device(sitronix_ts_gpts.keyevent_input);
+#ifdef SITRONIX_MONITOR_THREAD
+	if(sitronix_ts_gpts.enable_monitor_thread == 1){
+		if(SitronixMonitorThread){
+		      kthread_stop(SitronixMonitorThread);
+		      SitronixMonitorThread = NULL;
+		}
+	}
+#endif // SITRONIX_MONITOR_THREAD
+err_device_info_error:
+err_check_functionality_failed:
+
+	return ret;
+}
+
+static int sitronix_ts_remove(struct i2c_client *client)
+{
+	struct sitronix_ts_data *ts = i2c_get_clientdata(client);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ts->early_suspend);
+#endif // CONFIG_HAS_EARLYSUSPEND
+#ifdef SITRONIX_SYSFS
+	if(!sitronix_ts_sysfs_using){
+		sitronix_ts_destroy_sysfs_entry(client);
+		sitronix_ts_sysfs_created = false;
+	}
+#endif // SITRONIX_SYSFS
+#ifdef SITRONIX_MONITOR_THREAD
+	if(ts->enable_monitor_thread == 1){
+		if(SitronixMonitorThread){
+		      kthread_stop(SitronixMonitorThread);
+		      SitronixMonitorThread = NULL;
+		}
+	}
+#endif // SITRONIX_MONITOR_THREAD
+	i2c_set_clientdata(client, NULL);
+	if (ts->use_irq)
+		free_irq(client->irq, ts);
+	if(ts->input_dev)
+		input_unregister_device(ts->input_dev);
+	if(ts->keyevent_input)
+		input_unregister_device(ts->keyevent_input);
+	return 0;
+}
+
+static int sitronix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct sitronix_ts_data *ts = i2c_get_clientdata(client);
+
+	DbgMsg("%s\n", __FUNCTION__);
+//2.9.15 petitk add
+#ifdef SITRONIX_SMART_WAKE_UP		
+	sitronix_swk_set_swk_enable(ts);
+	swk_flag = 1;	
+#endif //SITRONIX_SMART_WAKE_UP
+
+#ifdef SITRONIX_MONITOR_THREAD
+	if(ts->enable_monitor_thread == 1){
+		if(SitronixMonitorThread){
+			kthread_stop(SitronixMonitorThread);
+			SitronixMonitorThread = NULL;
+		}
+		sitronix_ts_delay_monitor_thread_start = DELAY_MONITOR_THREAD_START_RESUME;
+	}
+#endif // SITRONIX_MONITOR_THREAD
+	if(ts->use_irq){
+		atomic_set(&sitronix_ts_irq_on, 0);
+		disable_irq_nosync(ts->client->irq);
+	}
+	ts->suspend_state = 1;
+
+	ret = sitronix_ts_set_powerdown_bit(ts, 1);
+	if(ts->chip_id == 2){
+#ifdef CONFIG_ARCH_MSM
+		gpio_tlmm_config(GPIO_CFG(SITRONIX_INT_GPIO, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+		gpio_set_value(SITRONIX_INT_GPIO, 1);
+#else
+		gpio_direction_output(irq_to_gpio(client->irq), 1);
+#endif // CONFIG_ARCH_MSM
+	}
+	DbgMsg("%s return\n", __FUNCTION__);
+
+	return 0;
+}
+
+static int sitronix_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct sitronix_ts_data *ts = i2c_get_clientdata(client);
+
+	DbgMsg("%s\n", __FUNCTION__);
+
+	if(ts->chip_id == 2){
+#ifdef CONFIG_ARCH_MSM
+		gpio_set_value(SITRONIX_INT_GPIO, 0);
+		gpio_tlmm_config(GPIO_CFG(SITRONIX_INT_GPIO, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+#else
+		ret = irq_to_gpio(client->irq);
+		gpio_set_value(ret, 0);
+		gpio_direction_input(ret);
+#endif // CONFIG_ARCH_MSM
+	}else{
+		ret = sitronix_ts_set_powerdown_bit(ts, 0);
+	}
+
+	ts->suspend_state = 0;
+	if(ts->use_irq){
+		atomic_set(&sitronix_ts_irq_on, 1);
+		enable_irq(ts->client->irq);
+	}
+#ifdef SITRONIX_MONITOR_THREAD
+	if(ts->enable_monitor_thread == 1){
+		atomic_set(&iMonitorThreadPostpone,1);
+		SitronixMonitorThread = kthread_run(sitronix_ts_gpts.sitronix_mt_fp,"Sitronix","Monitorthread");
+		if(IS_ERR(SitronixMonitorThread))
+			SitronixMonitorThread = NULL;
+	}
+#endif // SITRONIX_MONITOR_THREAD
+	DbgMsg("%s return\n", __FUNCTION__);
+	
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void sitronix_ts_early_suspend(struct early_suspend *h)
+{
+	struct sitronix_ts_data *ts;
+	DbgMsg("%s\n", __FUNCTION__);
+	ts = container_of(h, struct sitronix_ts_data, early_suspend);
+	sitronix_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static void sitronix_ts_late_resume(struct early_suspend *h)
+{
+	struct sitronix_ts_data *ts;
+	DbgMsg("%s\n", __FUNCTION__);
+	ts = container_of(h, struct sitronix_ts_data, early_suspend);
+	sitronix_ts_resume(ts->client);
+}
+#endif // CONFIG_HAS_EARLYSUSPEND
+
+static const struct i2c_device_id sitronix_ts_id[] = {
+	{ SITRONIX_I2C_TOUCH_DRV_NAME, 0x70 },
+	{ }
+};
+#ifdef SITRONIX_MULTI_SLAVE_ADDR
+static int sitronix_ts_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	uint8_t buffer[8];
+	sitronix_ts_reset_ic();
+	printk("%s: bus = %d\n", __FUNCTION__, client->adapter->nr);
+	if((client->adapter->nr == 3) && (!sitronix_i2c_read_bytes(client, STATUS_REG, buffer, 8))){
+		printk("detect successed\n");
+		strlcpy(info->type, SITRONIX_I2C_TOUCH_DRV_NAME, strlen(SITRONIX_I2C_TOUCH_DRV_NAME)+1);
+		return 0;
+	}else{
+		printk("detect failed\n");
+		return -ENODEV;
+	}
+}
+
+const unsigned short sitronix_i2c_addr[] = {0x38, 0x55, 0x70, I2C_CLIENT_END};
+#endif // SITRONIX_MULTI_SLAVE_ADDR
+
+static struct i2c_driver sitronix_ts_driver = {
+#ifdef SITRONIX_MULTI_SLAVE_ADDR
+	.class 		= I2C_CLASS_HWMON,
+#endif // SITRONIX_MULTI_SLAVE_ADDR
+	.probe		= sitronix_ts_probe,
+	.remove		= sitronix_ts_remove,
+	.id_table	= sitronix_ts_id,
+	.driver = {
+		.name	= SITRONIX_I2C_TOUCH_DRV_NAME,
+		.owner = THIS_MODULE,
+	},
+#ifdef SITRONIX_MULTI_SLAVE_ADDR
+	.address_list = sitronix_i2c_addr,
+	.detect = sitronix_ts_detect,
+#endif // SITRONIX_MULTI_SLAVE_ADDR
+};
+
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+static struct file_operations nc_fops = {
+	.owner =        THIS_MODULE,
+	.write		= sitronix_write,
+	.read		= sitronix_read,
+	.open		= sitronix_open,
+	.unlocked_ioctl = sitronix_ioctl,
+	.release	= sitronix_release,
+};
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+void sitronix_ts_reprobe(void)
+{
+	printk("sitronix call reprobe!\n");
+	int retval = 0;	
+	i2c_del_driver(&sitronix_ts_driver);
+	retval = i2c_add_driver(&sitronix_ts_driver);
+	if(retval < 0)
+		printk("fail to reprobe driver!\n");
+}
+
+static int __devinit sitronix_ts_init(void)
+{
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	int result;
+	int err = 0;
+	dev_t devno = MKDEV(sitronix_major, 0);
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+	printk("Sitronix touch driver %d.%d.%d\n", DRIVER_MAJOR, DRIVER_MINOR, DRIVER_PATCHLEVEL);
+	printk("Release date: %s\n", DRIVER_DATE);
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	result  = alloc_chrdev_region(&devno, 0, 1, SITRONIX_I2C_TOUCH_DEV_NAME);
+	if(result < 0){
+		printk("fail to allocate chrdev (%d) \n", result);
+		return 0;
+	}
+	sitronix_major = MAJOR(devno);
+	cdev_init(&sitronix_cdev, &nc_fops);
+	sitronix_cdev.owner = THIS_MODULE;
+	sitronix_cdev.ops = &nc_fops;
+        err =  cdev_add(&sitronix_cdev, devno, 1);
+	if(err){
+		printk("fail to add cdev (%d) \n", err);
+		return 0;
+	}
+
+	sitronix_class = class_create(THIS_MODULE, SITRONIX_I2C_TOUCH_DEV_NAME);
+	if (IS_ERR(sitronix_class)) {
+		result = PTR_ERR(sitronix_class);
+		unregister_chrdev(sitronix_major, SITRONIX_I2C_TOUCH_DEV_NAME);
+		printk("fail to create class (%d) \n", result);
+		return result;
+	}
+	device_create(sitronix_class, NULL, MKDEV(sitronix_major, 0), NULL, SITRONIX_I2C_TOUCH_DEV_NAME);
+#ifdef SITRONIX_PERMISSION_THREAD
+	SitronixPermissionThread = kthread_run(sitronix_ts_permission_thread,"Sitronix","Permissionthread");
+	if(IS_ERR(SitronixPermissionThread))
+		SitronixPermissionThread = NULL;
+#endif // SITRONIX_PERMISSION_THREAD
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+	return i2c_add_driver(&sitronix_ts_driver);
+}
+
+static void __exit sitronix_ts_exit(void)
+{
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	dev_t dev_id = MKDEV(sitronix_major, 0);
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+	i2c_del_driver(&sitronix_ts_driver);
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	cdev_del(&sitronix_cdev);
+
+	device_destroy(sitronix_class, dev_id); //delete device node under /dev
+	class_destroy(sitronix_class); //delete class created by us
+	unregister_chrdev_region(dev_id, 1);
+#ifdef SITRONIX_PERMISSION_THREAD
+	if(SitronixPermissionThread)
+		SitronixPermissionThread = NULL;
+#endif // SITRONIX_PERMISSION_THREAD
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+}
+
+module_init(sitronix_ts_init);
+module_exit(sitronix_ts_exit);
+
+MODULE_DESCRIPTION("Sitronix Multi-Touch Driver");
+MODULE_LICENSE("GPL");
+
+
+#if defined(ST_TEST_RAW) || defined(ST_UPGRADE_FIRMWARE)
+
+static int st_i2c_read_direct(st_u8 *rxbuf, int len)
+{
+	
+	int ret = 0;	
+	ret = i2c_master_recv(sitronix_ts_gpts.client, rxbuf, len);
+
+	if (ret < 0){
+		stmsg("read direct error (%d)\n", ret);
+		return ret;
+	}
+	return len;
+}
+
+static int st_i2c_read_bytes(st_u8 addr, st_u8 *rxbuf, int len)
+{
+	
+	int ret = 0;
+	st_u8 txbuf = addr;
+	
+	ret = i2c_master_send(sitronix_ts_gpts.client, &txbuf, 1);
+	if (ret < 0){
+		stmsg("write 0x%x error (%d)\n", addr, ret);
+		return ret;
+	}
+	ret = i2c_master_recv(sitronix_ts_gpts.client, rxbuf, len);
+
+	if (ret < 0){
+		stmsg("read 0x%x error (%d)\n", addr, ret);
+		return ret;
+	}
+	return len;
+}
+
+static int st_i2c_write_bytes(st_u8 *txbuf, int len)
+{
+	
+	int ret = 0;
+	if(txbuf == NULL)
+		return -1;
+
+	ret = i2c_master_send(sitronix_ts_gpts.client, txbuf, len);
+	if (ret < 0){
+		stmsg("write 0x%x error (%d)\n", *txbuf, ret);
+		return ret;
+	}
+	return len;
+}
+#endif
+
+#ifdef ST_UPGRADE_FIRMWARE
+
+static int st_check_chipid(void)
+{
+	int ret = 0;
+	st_u8 buffer[8];
+
+	ret = st_i2c_read_bytes(STATUS_REG, buffer, 8);
+	if (ret < 0){
+		stmsg("read status reg error (%d)\n", ret);
+		return ret;
+	}else{
+		stmsg("ChipID = %d\n", buffer[1]);
+	}
+
+#ifdef ST_IC_A8008
+	if(buffer[1] != 0x6)
+	{
+		stmsg("This IC is not A8008 , cancel upgrade\n");
+		return -1;
+	}	
+#else
+	if(buffer[1] != 0xA)
+	{
+		stmsg("This IC is not A8010 , cancel upgrade\n");
+		return -1;
+	}
+#endif
+	return 0;
+}
+
+static int st_get_device_status(void)
+{
+	int ret = 0;
+	st_u8 buffer[8];
+
+	ret = st_i2c_read_bytes(STATUS_REG, buffer, 8);
+	if (ret < 0){
+		stmsg("read status reg error (%d)\n", ret);
+		return ret;
+	}else{
+		stmsg("status reg = %d\n", buffer[0]);
+	}
+
+
+	return buffer[0];
+}
+
+static int st_check_device_status(int ck1,int ck2,int delay)
+{
+	int maxTimes = 100;
+	int isInStauts = 0;
+	int status = -1;
+	while(maxTimes-->0 && isInStauts==0)
+	{
+		status = st_get_device_status();
+		stmsg("status : %d\n",status);
+		if(status == ck1 || status == ck2)
+			isInStauts=1;
+		st_msleep(delay);
+	}
+	if(isInStauts==0)
+		return -1;
+	else
+		return 0;
+}
+
+static int st_power_up(void)
+{
+	st_u8 reset[2];
+	reset[0] = 2;
+	reset[1] = 0;
+	return st_i2c_write_bytes(reset,2);
+}
+int st_isp_off(void)
+{
+	unsigned char data[8];
+	int rt = 0;
+	
+	memset(data, 0, sizeof(data));
+	data[0] = ISP_CMD_RESET;
+	
+	rt += st_i2c_write_bytes(data,sizeof(data));
+
+	if(rt < 0)
+	{
+		stmsg("ISP off error\n");
+		return -1;
+	}
+	st_msleep(300);
+	
+
+	return st_check_device_status(0,4,10);
+}
+static int st_isp_on(void)
+{
+	unsigned char IspKey[] = {0,'S',0,'T',0,'X',0,'_',0,'F',0,'W',0,'U',0,'P'};
+	unsigned char i;
+	int icStatus = st_get_device_status();
+	
+	stmsg("ISP on\n");		
+		
+	if(icStatus <0)
+		return -1;
+	if(icStatus == 0x6)
+		return 0;
+	else if(icStatus == 0x5)
+		st_power_up();	
+
+	for(i=0;i<sizeof(IspKey); i+=2)
+	{
+		if(st_i2c_write_bytes(&IspKey[i],2) < 0)
+		{
+			stmsg("Entering ISP fail.\n");
+			return -1;
+		}
+	}
+	st_msleep(300);	//This delay is very important for ISP mode changing.	
+					//Do not remove this delay arbitrarily.
+	return st_check_device_status(6,99,10);
+}
+
+static int st_irq_off(void)
+{
+	if (sitronix_ts_gpts.use_irq){
+		atomic_set(&sitronix_ts_irq_on, 0);
+		disable_irq_nosync(sitronix_ts_gpts.client->irq);
+	}
+}
+static int st_irq_on(void)
+{
+	if (sitronix_ts_gpts.use_irq)
+	{
+		atomic_set(&sitronix_ts_irq_on, 1);
+		enable_irq(sitronix_ts_gpts.client->irq);
+	}
+}
+
+unsigned short st_flash_get_checksum(unsigned char *Buf, unsigned short ValidDataSize)
+{
+	unsigned short Checksum;
+	int i;
+
+	Checksum = 0;
+	for(i = 0; i < ValidDataSize; i++)
+		Checksum += (unsigned short)Buf[i];
+
+	return Checksum;
+}
+
+static int st_flash_unlock(void)
+{
+	unsigned char PacketData[ISP_PACKET_SIZE];
+	
+	int retryCount=0;
+	int isSuccess=0;
+	memset(PacketData,0,ISP_PACKET_SIZE);
+	PacketData[0] = ISP_CMD_UNLOCK;		
+	if(st_i2c_write_bytes(PacketData,ISP_PACKET_SIZE) == ISP_PACKET_SIZE)
+	while(isSuccess==0 && retryCount++ < 2)
+	{
+		while(isSuccess==0 && retryCount++ < 2)
+		{	
+			if(retryCount > 1)
+				st_msleep(150);
+				
+			if(st_i2c_read_direct(PacketData,ISP_PACKET_SIZE) == ISP_PACKET_SIZE)
+			{
+				if(PacketData[0] == ISP_CMD_READY)
+					isSuccess = 1;
+			}
+			else
+				st_msleep(50);
+			
+			if(isSuccess ==0)
+			{
+				stmsg("Read ISP_Unlock_Ready packet fail retry : %d\n",retryCount);
+				//MSLEEP(30);			
+			}
+		}		
+	}
+	
+	if(isSuccess == 0)
+	{
+		stmsg("Read ISP_Unlock_Ready packet fail.\n");
+		return -1;
+	}
+	
+	return 0;
+}
+
+int st_flash_erase_page(unsigned short PageNumber)
+{
+	unsigned char PacketData[ISP_PACKET_SIZE];
+	
+	int retryCount=0;
+	int isSuccess=0;
+	
+	memset(PacketData,0,ISP_PACKET_SIZE);
+	PacketData[0] = ISP_CMD_ERASE;
+	PacketData[2] = (unsigned char)PageNumber;
+	if(st_i2c_write_bytes(PacketData,ISP_PACKET_SIZE) == ISP_PACKET_SIZE)
+	{		
+		while(isSuccess==0 && retryCount++ < 2)				
+		{	
+			if(retryCount > 1)
+				st_msleep(150);
+				
+			if(st_i2c_read_direct(PacketData,ISP_PACKET_SIZE) == ISP_PACKET_SIZE)
+			{
+				if(PacketData[0] == ISP_CMD_READY)
+					isSuccess = 1;
+			}
+			else
+			{
+				//time out 
+				st_msleep(50);								
+			}
+			
+			if(isSuccess ==0)
+			{
+				stmsg("Read ISP_Erase_Ready packet fail with page %d retry : %d\n",PageNumber,retryCount);
+				//MSLEEP(30);			
+			}
+		}		
+	}
+	
+	if(isSuccess == 0)
+	{
+		stmsg("Read ISP_Erase_Ready packet fail.\n");
+		return -1;
+	}
+	
+	return 0;
+}
+
+static int st_flash_read_page(unsigned char *Buf,unsigned short PageNumber)
+{
+	unsigned char PacketData[ISP_PACKET_SIZE];
+	short ReadNumByte;
+	short ReadLength;
+
+	ReadNumByte = 0;
+	memset(PacketData,0,ISP_PACKET_SIZE);
+	PacketData[0] = ISP_CMD_READ_FLASH;
+	PacketData[2] = (unsigned char)PageNumber;
+	if(st_i2c_write_bytes(PacketData,ISP_PACKET_SIZE) != ISP_PACKET_SIZE)
+	{
+		stmsg("Send ISP_Read_Flash packet fail.\n");
+		return -1;
+	}
+
+	while(ReadNumByte < ST_FLASH_PAGE_SIZE)
+	{
+		if((ReadLength = st_i2c_read_direct(Buf+ReadNumByte,ISP_PACKET_SIZE)) != ISP_PACKET_SIZE)
+		{
+			stmsg("ISP read page data fail.\n");
+			return -1;
+		}
+		if(ReadLength == 0)
+			break;
+		ReadNumByte += ReadLength;
+	}
+	return ReadNumByte;
+}
+
+static int st_flash_write_page(unsigned char *Buf,unsigned short PageNumber)
+{
+	unsigned char PacketData[ISP_PACKET_SIZE];
+	short WriteNumByte;
+	short WriteLength;
+	unsigned short Checksum;
+	unsigned char RetryCount;
+
+	RetryCount = 0;
+	while(RetryCount++ < 1)
+	{
+		WriteNumByte = 0;
+		memset(PacketData,0,ISP_PACKET_SIZE);
+		Checksum = st_flash_get_checksum(Buf,ST_FLASH_PAGE_SIZE);
+			
+		PacketData[0] = ISP_CMD_WRITE_FLASH;
+		PacketData[2] = (unsigned char)PageNumber;
+		PacketData[4] = (unsigned char)(Checksum & 0xFF);
+		PacketData[5] = (unsigned char)(Checksum >> 8);
+		if(st_i2c_write_bytes(PacketData,ISP_PACKET_SIZE) != ISP_PACKET_SIZE )
+		{
+			stmsg("Send ISP_Write_Flash packet fail.\n");
+			return -1;
+		}
+		PacketData[0] = ISP_CMD_SEND_DATA;
+		while(WriteNumByte < ST_FLASH_PAGE_SIZE)
+		{
+			WriteLength = ST_FLASH_PAGE_SIZE - WriteNumByte;
+			if(WriteLength > 7)
+				WriteLength = 7;
+			memcpy(&PacketData[1],&Buf[WriteNumByte],WriteLength);
+			if(st_i2c_write_bytes(PacketData,ISP_PACKET_SIZE) != ISP_PACKET_SIZE)
+			{
+				stmsg("Send ISP_Write_Flash_Data packet error.\n");
+				return -1;
+			}
+			WriteNumByte += WriteLength;
+		}
+
+
+		if(st_i2c_read_direct(PacketData,ISP_PACKET_SIZE) != ISP_PACKET_SIZE)
+		{
+			stmsg("ISP get \"Write Data Ready Packet\" fail.\n");
+			return -1;
+		}
+		if(PacketData[0] != ISP_CMD_READY)
+		{
+			stmsg("Command ID of \"Write Data Ready Packet\" error.\n");
+			return -1;
+		}
+		
+		if((PacketData[2] & 0x10) != 0)
+		{
+			stmsg("Error occurs during write page data into flash. Error Code = 0x%X\n",PacketData[2]);
+			return -1;
+		}			
+		
+		break;
+	}
+	st_msleep(1000);
+	return WriteNumByte;
+}
+
+int st_flash_write(unsigned char *Buf, int Offset, int NumByte)
+{
+	stmsg("Write flash offset:0x%X , length:0x%X\n",Offset,NumByte);	
+	unsigned short StartPage;
+	unsigned short PageOffset;
+	int WriteNumByte;
+	short WriteLength;
+	unsigned char TempBuf[ST_FLASH_PAGE_SIZE];
+	int retry = 0;
+	int isSuccess = 0;
+
+	WriteNumByte = 0;
+	if(NumByte == 0)
+		return WriteNumByte;
+	
+	if((Offset + NumByte) > ST_FLASH_SIZE)
+		NumByte = ST_FLASH_SIZE - Offset;
+		
+	StartPage = Offset / ST_FLASH_PAGE_SIZE;
+	PageOffset = Offset % ST_FLASH_PAGE_SIZE;
+	while(NumByte > 0)
+	{
+		if((PageOffset != 0) || (NumByte < ST_FLASH_PAGE_SIZE))
+		{
+			if(st_flash_read_page(TempBuf,StartPage) < 0)
+				return -1;
+		}
+
+		WriteLength = ST_FLASH_PAGE_SIZE - PageOffset;
+		if(NumByte < WriteLength)
+			WriteLength = NumByte;
+		memcpy(&TempBuf[PageOffset],Buf,WriteLength);
+				
+		retry = 0;
+		isSuccess = 0;
+		while(retry++ <2 && isSuccess ==0)
+		{
+			if(st_flash_unlock() >= 0 && st_flash_erase_page(StartPage) >= 0)
+			{	
+				stmsg("write page:%d\n",StartPage);			
+				if(st_flash_unlock() >= 0 && st_flash_write_page(TempBuf,StartPage) >= 0)
+					isSuccess =1;
+			}
+			isSuccess =1;
+			
+			if(isSuccess==0)
+				stmsg("FIOCTL_IspPageWrite write page %d retry: %d\n",StartPage,retry);
+		}
+		if(isSuccess==0)
+		{
+			stmsg("FIOCTL_IspPageWrite write page %d error\n",StartPage);
+			return -1;
+		}
+		else
+			StartPage++;
+		
+		NumByte -= WriteLength;
+		Buf += WriteLength;
+		WriteNumByte += WriteLength;
+		PageOffset = 0;
+	}
+	return WriteNumByte;
+}
+
+#ifdef ST_FIREWARE_FILE
+static int st_check_fs_mounted(st_char *path_name)
+{
+    struct path root_path;
+    struct path path;
+    int err;
+    err = kern_path("/", LOOKUP_FOLLOW, &root_path);
+
+    if (err)
+        return -1;
+
+    err = kern_path(path_name, LOOKUP_FOLLOW, &path);
+
+    if (err)
+        return -1;
+
+   return 0;
+
+}
+static int st_load_cfg_from_file(unsigned st_char *buf)
+{
+	int j;
+	struct st_file  *cfg_fp;
+	mm_segment_t fs;
+	int fileSize = 0;
+		
+	cfg_fp = st_filp_open(ST_CFG_PATH, O_RDWR,0666);
+	if(IS_ERR(cfg_fp)){
+	       	stmsg("Test: filp_open error!!. %d\n",j);				        	
+	}else
+	{
+		fs = get_fs();
+		set_fs(get_ds());
+			
+		fileSize = cfg_fp->f_op->read(cfg_fp,buf,ST_FW_LEN,&cfg_fp->f_pos);
+		set_fs(fs);
+		st_filp_close(cfg_fp,NULL);
+	}
+	return fileSize;
+}
+
+static int st_load_fw_from_file(unsigned st_char *buf)
+{
+	int i,j;
+	struct st_file  *fw_fp;
+	mm_segment_t fs;
+	int fileSize = 0;
+
+	for(j=0;j<10;j++)
+	{
+		st_msleep(1000);
+		stmsg("Wati for FS %d\n", j);
+
+		if (st_check_fs_mounted(ST_FW_DIR) == 0)
+		{
+                	stmsg("%s mounted ~!!!!\n",ST_FW_DIR);
+                	fileSize = 1;
+                	break;
+		}
+	}
+	if(fileSize ==0)
+	{
+		stmsg("%s don't mounted ~!!!!\n",ST_FW_DIR);
+		return -1;
+	}
+	for(j=0;j<10;j++)
+	{
+ 		st_msleep(1000);
+ 		fileSize = 0;
+		fw_fp = st_filp_open(ST_FW_PATH, O_RDWR,0666);
+	 	if(IS_ERR(fw_fp)){
+	        	stmsg("Test: filp_open error!!. %d\n",j);
+			fileSize = 0;	        	
+	        }else
+	        {
+	        	fileSize = 0;
+			fs = get_fs();
+			set_fs(get_ds());
+			//f->f_op->read(f,buf,ROM_SIZE,&f->f_pos);
+			fileSize = fw_fp->f_op->read(fw_fp,buf,ST_FW_LEN,&fw_fp->f_pos);
+			set_fs(fs);
+	 		stmsg("fw file size:0x%X\n",fileSize);
+			//for(i=0;i<0x10;i++)
+			//	stmsg("Test: data is %X",buf[i]);			
+	          	st_filp_close(fw_fp,NULL);
+			break;
+	    	}
+	}
+	return fileSize;
+}
+
+unsigned char fw_buf[ST_FW_LEN];
+unsigned char cfg_buf[ST_CFG_LEN];
+#else
+unsigned char fw_buf[] = SITRONIX_FW;
+unsigned char cfg_buf[] = SITRONIX_CFG;
+#endif //ST_FIREWARE_FILE
+
+
+static int st_get_fw_info_offset(int fwSize,unsigned st_char *buf)
+{
+	int i=0;
+	for(i=fwSize-ST_FW_INFO_LEN-4;i>=4;i--)
+	{
+		if(	buf[i]   == 0x54 &&
+			buf[i+1] == 0x46 &&
+			buf[i+2] == 0x49 &&
+			buf[i+3] == 0x32 )
+		{
+			stmsg("TOUCH_FW_INFO offset = 0x%X\n",i+4);
+			return i+4;
+		}		
+	}
+	stmsg("can't find TOUCH_FW_INFO offset\n");
+	return -1;
+}
+static int st_compare_array(unsigned st_char *b1,unsigned st_char *b2,int len)
+{
+	int i=0;
+	for(i=0;i<len;i++)
+	{		
+		if(b1[i] != b2[i])
+			return -1;
+	}
+	return 0;
+}
+unsigned char fw_check[ST_FLASH_PAGE_SIZE];
+#ifdef ST_UPGRADE_BY_ID
+unsigned char id_buf[] = SITRONIX_IDS;
+unsigned char id_off[] = SITRONIX_ID_OFF;
+
+unsigned char fw_buf0[] = SITRONIX_FW;
+unsigned char cfg_buf0[] = SITRONIX_CFG;
+unsigned char fw_buf1[] = SITRONIX_FW1;
+unsigned char cfg_buf1[] = SITRONIX_CFG1;
+unsigned char fw_buf2[] = SITRONIX_FW2;
+unsigned char cfg_buf2[] = SITRONIX_CFG2;
+
+static void st_replace_fw_by_id(int id)
+{
+	if(id==0)
+	{
+		stmsg("Found id by SITRONIX_FW and SITRONIX_CFG\n");
+		memcpy(fw_buf,fw_buf0,sizeof(fw_buf0));
+		memcpy(cfg_buf,cfg_buf0,sizeof(cfg_buf0));
+	}
+	else if(id==1)
+	{
+		stmsg("Found id by SITRONIX_FW1 and SITRONIX_CFG1\n");
+		memcpy(fw_buf,fw_buf1,sizeof(fw_buf1));
+		memcpy(cfg_buf,cfg_buf1,sizeof(cfg_buf1));
+	}
+	else if(id==2)
+	{
+		stmsg("Found id by SITRONIX_FW2 and SITRONIX_CFG2\n");
+		memcpy(fw_buf,fw_buf2,sizeof(fw_buf2));
+		memcpy(cfg_buf,cfg_buf2,sizeof(cfg_buf2));
+	}	
+}
+
+static int st_select_fw_by_id(void)
+{	
+	int ret=0;
+	unsigned char buf[8];
+	unsigned char id[4];
+	int i=0;
+	int idlen = sizeof(id_buf) / 4;
+	int isFindID = 0;	
+	int status = st_get_device_status();
+	if(status < 0)
+	{		
+		return -1;
+	}
+	else if(status != 0x6)
+	{		
+		st_i2c_read_bytes(0xC, buf, 4);
+		st_i2c_read_bytes(0xF1, buf+4, 1);
+		buf[6] = buf[4];
+		buf[5] =  (buf[4] &0xFC) | 1;
+		buf[4] = 0xF1;
+		st_i2c_write_bytes(buf+4, 2);
+		st_msleep(1);
+		st_i2c_read_bytes(0xC, id, 4);
+		buf[5] = buf[6];
+		st_i2c_write_bytes(buf+4, 2);
+		st_msleep(1);
+		
+		if(	id[0] == buf[0]
+		   &&	id[1] == buf[1]
+		   &&	id[2] == buf[2]
+		   &&	id[3] == buf[3])
+		 {
+		 	stmsg("read customer id fail \n");
+		 	return -1;
+		 }
+		 else
+		 	stmsg("customer ids: %x %x %x %x \n",id[0],id[1],id[2],id[3]);
+		 
+		 
+		 for(i=0;i<idlen;i++)
+		 {
+		 	if(	id[0] == id_buf[i*4]
+		   	&&	id[1] == id_buf[i*4+1]
+		   	&&	id[2] == id_buf[i*4+2]
+		   	&&	id[3] == id_buf[i*4+3])
+		   	{
+		   		isFindID =1;		   		
+		   		st_replace_fw_by_id(i);		   		
+		   	}
+		 }
+		 if(0== isFindID)
+		 	return -1;
+	}
+	else
+	{
+		stmsg("IC's status : boot code \n");
+		// if bootcode
+		if(0==st_isp_off())
+		{
+			//could ispoff
+			stmsg("IC's could go normat status \n");
+			return st_select_fw_by_id();
+		}
+		else
+		{
+			stmsg("IC really bootcode mode \n");
+			ret = st_flash_read_page(fw_check,ST_CHECK_FW_OFFSET / ST_FLASH_PAGE_SIZE);
+			if(ret < 0 )
+			{
+				stmsg("read flase fail! (%x)\n",ret);
+			}
+			
+			for(i=0;i<idlen;i++)
+			{
+				if(	fw_check[0x300+id_off[i]] == id_buf[i*4]
+			   	&&	fw_check[0x301+id_off[i]] == id_buf[i*4+1]
+			   	&&	fw_check[0x302+id_off[i]] == id_buf[i*4+2]
+			   	&&	fw_check[0x303+id_off[i]] == id_buf[i*4+3])
+			   	{
+			   		isFindID =1;		   		
+		   			st_replace_fw_by_id(i);	
+			   	}
+			}
+			
+			if(0== isFindID)
+				return -1;
+		}
+		
+		
+	}
+	return 0;
+}
+#endif //ST_UPGRADE_BY_ID
+
+#ifdef ST_REPLACE_CFG
+unsigned char st_cfg_version[] = SITRONIX_CFG_VERSION;
+unsigned char st_f_offset[] = SITRONIX_F_OFFSET;
+unsigned char st_t_offset[] = SITRONIX_T_OFFSET;
+
+
+static void st_replace_cfg(unsigned char *fcfg,unsigned char *tcfg,int cfgSize)
+{
+	int i=0,j=0;
+	int index = -1;
+	int cks=0;
+	unsigned char LowByteChecksum;
+	unsigned char now_cfg_version = fcfg[4];
+	
+	for(i=0;i<STIRONIX_FW_SET_COUNT;i++)
+	{
+		if(st_cfg_version[i] == now_cfg_version)
+		{
+			stmsg("Find cfg replace : CFG Version : %x\n",now_cfg_version);
+			index = i;
+		}
+	}
+	if(index == -1)
+	{
+		stmsg("Can't find cfg replace : CFG Version : %x\n",now_cfg_version);
+		return ;
+	}
+	
+	for(i=0;i<sizeof(st_t_offset);i++)
+	{
+		tcfg[st_t_offset[i]] =fcfg[st_f_offset[index*sizeof(st_t_offset)+i]];
+	}
+	//checksum
+	for(i = 0; i < STIRONIX_CFG_CHECKSUM_OFFSET; i++)
+	{
+		cks += (0xff&tcfg[i]);
+		LowByteChecksum = (unsigned char)(cks & 0xFF);
+		LowByteChecksum = (LowByteChecksum) >> 7 | (LowByteChecksum) << 1;
+		cks= (cks & 0xFF00) | LowByteChecksum;
+	}
+	
+	tcfg[STIRONIX_CFG_CHECKSUM_OFFSET] = cks>>8;
+	tcfg[STIRONIX_CFG_CHECKSUM_OFFSET+1] = cks&0xFF;			
+}
+#endif //ST_REPLACE_CFG
+int st_upgrade_fw(void)
+{
+	int rt=0;
+	int fwSize =0;
+	int cfgSize =0;	
+	int fwInfoOff = 0;
+	int fwInfoLen = ST_FW_INFO_LEN;
+	int powerfulWrite = 0;
+	
+#ifdef ST_FIREWARE_FILE	
+	fwSize = st_load_fw_from_file(fw_buf);
+	
+	cfgSize = st_load_cfg_from_file(cfg_buf);
+#else
+
+#ifdef ST_UPGRADE_BY_ID
+	
+	if(0 != st_select_fw_by_id())
+	{
+		stmsg("find id fail , cancel upgrade\n");
+		return -1;
+	}	
+#endif
+
+	fwSize = sizeof(fw_buf);
+	cfgSize = sizeof(cfg_buf);
+	stmsg("fwSize 0x%X,cfgsize 0x%X\n",fwSize,cfgSize);
+#endif //ST_FIREWARE_FILE
+
+	cfgSize = min(cfgSize,ST_CFG_LEN);
+	if(fwSize != 0)
+	{
+		fwInfoOff = st_get_fw_info_offset(fwSize,fw_buf);
+		if(fwInfoOff <0)
+			fwSize = 0;
+		fwInfoLen = fw_buf[fwInfoOff]+1+4;
+#ifdef ST_IC_A8008		
+		if(fwInfoLen != ST_CFG_OFFSET - fwInfoOff)
+		{
+			stmsg("check FwInfo Len error (%x), cancel upgrade\n",fwInfoLen);
+			return -1;
+		}
+#else
+		if(fwInfoOff == -1)
+		{
+			stmsg("check fwInfoOff Len error (%x), cancel upgrade\n",fwInfoOff);
+			return -1;
+		}
+#endif
+		stmsg("fwInfoOff 0x%X\n",fwInfoOff);
+	}
+	
+	if(fwSize ==0 && cfgSize ==0)
+	{
+		stmsg("can't find FW or CFG , cancel upgrade\n");
+		return -1;
+	}
+    	
+    	if(st_get_device_status() == 0x6)
+    		powerfulWrite = 1;    		
+
+    	st_irq_off();
+    	
+    	rt = st_isp_on();
+    	if(rt !=0)
+    	{
+    		stmsg("ISP on fail\n");
+    		goto ST_IRQ_ON;
+    	}
+    	
+    	if(st_check_chipid() < 0)
+    	{
+    		stmsg("Check ChipId fail\n");
+    		rt = -1;
+    		goto ST_ISP_OFF;
+    	}
+    	
+    	if(powerfulWrite ==0 &&(fwSize !=0 || cfgSize!=0))
+    	{
+    		//check fw and cfg
+    		int checkOff = (fwInfoOff / ST_FLASH_PAGE_SIZE) *ST_FLASH_PAGE_SIZE;
+    		if(st_flash_read_page(fw_check,fwInfoOff / ST_FLASH_PAGE_SIZE)< 0 )
+    		{
+    			stmsg("read flash fail , cancel upgrade\n");
+    			rt = -1;
+    			goto ST_ISP_OFF;
+    		}
+    		
+    		if(fwSize !=0)
+    		{
+    			if(0 == st_compare_array(fw_check+(fwInfoOff-checkOff),fw_buf+fwInfoOff,fwInfoLen) )
+    			{
+    				stmsg("fw compare :same\n");
+    				fwSize = 0;
+    			}
+    			else
+    			{
+    				stmsg("fw compare :different\n");
+    			}
+    			
+    		}
+    		
+    		if(cfgSize !=0)
+    		{
+    			
+#ifdef ST_IC_A8008
+			if(0 == st_compare_array(fw_check+(ST_CFG_OFFSET-checkOff),cfg_buf,cfgSize))
+#else
+			st_flash_read_page(fw_check,ST_CFG_OFFSET / ST_FLASH_PAGE_SIZE);
+			if(0 == st_compare_array(fw_check,cfg_buf,cfgSize))
+#endif
+    			{
+    				stmsg("cfg compare :same\n");
+    				cfgSize = 0;
+    			}
+    			else
+    			{
+    				stmsg("cfg compare : different\n");
+#ifdef ST_REPLACE_CFG
+				st_replace_cfg(fw_check+(ST_CFG_OFFSET-checkOff),cfg_buf,cfgSize);
+#endif    				
+    			}
+    			
+    		}
+    		
+    	}
+    	
+    	if(cfgSize !=0)
+    		st_flash_write(cfg_buf,ST_CFG_OFFSET,cfgSize);
+    	
+    	if(fwSize !=0)
+    		st_flash_write(fw_buf,0,fwSize);
+    	    	
+ST_ISP_OFF:    	
+    	rt = st_isp_off();
+ST_IRQ_ON:    	    		
+    	st_irq_on();
+    	return rt;
+}
+#endif //ST_UPGRADE_FIRMWARE
+
+
+#ifdef ST_TEST_RAW
+st_int st_drv_Get_2D_Length(st_int tMode[])
+{
+	if(tMode[0] ==0)
+		return tMode[1];
+	else
+		return tMode[2];
+}
+st_int st_drv_Get_2D_Count(st_int tMode[])
+{
+	if(tMode[0] == 0)
+		return tMode[2];
+	else
+		return tMode[1];
+}
+
+st_int st_drv_Get_2D_RAW(st_int tMode[],st_int rawJ[],st_int gsMode)
+{
+	st_int count =st_drv_Get_2D_Count(tMode);
+	st_int length = st_drv_Get_2D_Length(tMode);
+	st_int maxTimes = 40;
+	st_int dataCount=0;
+	st_int times = maxTimes;
+	
+	st_u8 raw[0x40];
+	memset(raw,0,0x40);
+	st_int i=0;
+	st_int j=0;
+	st_int index;
+	st_int keyAddCount = (tMode[3] >0)? 1:0;
+	st_int rawI;
+	st_int errorCount = 0;	
+	st_u8 isFillData[MAX_SENSOR_COUNT];
+	memset(isFillData,0,count+keyAddCount);
+	
+	//stmsg("isFill 0 : %d",isFillData[0]);
+	while(dataCount != (count+keyAddCount) && times-- >0)
+	{	
+		st_i2c_read_bytes(0x40,raw,0x40);
+		//stmsg("%X %X %X data:%d key:%d",raw[0],raw[1],raw[2],dataCount,tMode[3]);
+		if(raw[0] == 6)
+		{
+			int index = raw[2];
+			//stmsg("isFill %d : %d %d , %d",index,isFillData[index],dataCount,count+keyAddCount);
+			if(isFillData[index] ==0)
+			{	
+				//stmsg("index %d",index);			
+				isFillData[index] = 1;
+				dataCount++;
+				//index = index*length;
+				for(i=0;i<length;i++)
+				{
+					rawI = raw[4+2*i]*0x100 + raw[5+2*i];
+					stmsg("Sensor RAW %d,%d = %d",index,i,rawI);
+					if(rawI > MAX_RAW_LIMIT || rawI  < MIN_RAW_LIMIT)
+					{
+						stmsg("Error: Sensor RAW %d,%d = %d out of limity (%d,%d)",index,i,rawI,MIN_RAW_LIMIT,MAX_RAW_LIMIT);
+						errorCount++;
+					}
+					//rawI[index+i] = raw[4+2*i]*0x100 + raw[5+2*i];
+				}
+			}
+		}
+		else if(raw[0]==7)
+		{
+			//key
+			//stmsg("key");
+			if(isFillData[count] ==0)
+			{	
+				isFillData[count] = 1 ;				
+				dataCount++;
+				for(i=0;i<tMode[3];i++)
+				{
+					rawI = raw[4+2*i]*0x100 + raw[5+2*i];
+					//stmsg("Key RAW %d = %d",i,rawI);
+					if(rawI > MAX_RAW_LIMIT || rawI  < MIN_RAW_LIMIT)
+					{
+						stmsg("Error: Key RAW %d = %d out of limity ",i,rawI,MIN_RAW_LIMIT,MAX_RAW_LIMIT);
+						errorCount++;
+					}
+					//rawI[count*length+i] = raw[4+2*i]*0x100 + raw[5+2*i];
+					
+				}
+			}
+		}		
+	}
+	
+	if(times <=0)
+	{
+		stmsg("Get 2D RAW fail!");
+		return -1;
+	}
+	return errorCount;
+}
+int st_drv_test_raw()
+{
+	stmsg("start of st_drv_test_raw");	
+	st_int result = 0;
+	st_u8 buf[8];
+	st_int sensorCount =0;
+	st_int raw_J[MAX_SENSOR_COUNT];
+		
+	/////////////////////////////
+	//check status
+	memset(buf,0,8);
+	if( st_i2c_read_bytes(1,buf,8) <0)
+	{
+		stmsg("get status fail");
+		return -1;	
+	}
+
+	stmsg("status :0x%X",buf[0]);
+	if(buf[0] != 0 && buf[0] != 4)
+	{
+		stmsg("can't test in this status");
+		result = -1;
+		goto st_drv_notest;
+	}
+	//////////////////////////////
+	//go develop page
+	memset(buf,0,8);
+	st_i2c_read_bytes(0xFF, buf,8);
+	if(buf[1] != 0x53 || buf[2] != 0x54 || buf[3] != 0x50 || buf[4] != 0x41)
+	{
+		stmsg("ic check fail , not sitronix protocol type");
+		goto st_drv_notest;
+	}
+	
+	buf[0] = buf[6];
+	buf[1] = buf[7];
+	st_i2c_write_bytes(buf,2);	
+	
+	st_i2c_read_bytes(0xFF,buf,2);
+	stmsg("page 0x%X",buf[0]);
+	if(buf[0] != 0xEF)
+	{
+		stmsg("change page fail");
+		goto st_drv_notest;
+	}
+	///////////////////////////////
+	//get tmode
+	st_int tMode[4];
+	tMode[0] = TX_ASSIGNMENT;	//tx is ?
+	st_i2c_read_bytes(0xF5,buf,3);
+	tMode[1] = buf[0];	//x
+	tMode[2] = buf[1];	//y
+	tMode[3] = buf[2]&0xf;	// key
+
+	sensorCount = tMode[1]+tMode[2]+tMode[3];
+	
+	stmsg("sensor count:%d %d %d",tMode[1],tMode[2],tMode[3]);
+	//////////////////////////////
+	//get raw and judge
+	result = st_drv_Get_2D_RAW(tMode,raw_J,0);
+	if(result !=0)
+	{
+		stmsg("Error: Test fail with %d sensor",result);
+		result = -1;		
+	}
+	else
+	{
+	stmsg("Test successed!");
+	}
+	//////////////////////////////
+	//reset
+	buf[0] = 2;
+	buf[1] = 1;
+	st_i2c_write_bytes(buf,2);
+
+	st_msleep(100);	
+st_drv_notest:		
+	return result;
+}
+#endif //ST_TEST_RAW
+#ifdef ST_PEN_SWITCH
+int sitronix_ts_pen_switch(struct i2c_client *client,int ison)
+{
+	int ret = 0;
+	uint8_t buffer[2];	
+	int nowPenStatus=0;
+	
+	buffer[0] = MISC_CONTROL;
+	
+	ret = sitronix_i2c_read_bytes(client, MISC_CONTROL, buffer+1, 1);
+	if(ret <0)
+	{
+		printk("read MISC_CONTROL error (%d)\n", ret);
+		return ret;
+	}
+	nowPenStatus = (buffer[1]>>4) & 0x1;
+	
+	printk("Pen status now:(%d) , operator:(%d)\n",nowPenStatus,ison);
+	if(nowPenStatus == ison)
+		return 0;
+	else if(ison == 1)
+	{
+		buffer[1] = buffer[1] | 0x10;
+		ret = sitronix_i2c_write_bytes(client, buffer, 2);		
+	}
+	else if(ison == 0)
+	{
+		buffer[1] = buffer[1] & 0xEF;
+		ret = sitronix_i2c_write_bytes(client, buffer, 2);		
+	}	
+	
+	if (ret < 0){
+		printk("write MISC_CONTROL error (%d)\n", ret);
+		return ret;
+	}
+	
+	return 0;
+	
+}
+#endif //ST_PEN_SWITCH
diff --git a/drivers/stromer/st1633.h b/drivers/stromer/st1633.h
new file mode 100644
index 0000000..546d74b
--- /dev/null
+++ b/drivers/stromer/st1633.h
@@ -0,0 +1,424 @@
+/*
+ * drivers/input/touchscreen/sitronix_i2c_touch.h
+ *
+ * Touchscreen driver for Sitronix
+ *
+ * Copyright (C) 2011 Sitronix Technology Co., Ltd.
+ *	Rudy Huang <rudy_huang@sitronix.com.tw>
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#ifndef __SITRONIX_I2C_TOUCH_h
+#define __SITRONIX_I2C_TOUCH_h
+
+#include <linux/ioctl.h> /* needed for the _IOW etc stuff used later */
+
+#define SITRONIX_TOUCH_DRIVER_VERSION 0x03
+#define SITRONIX_MAX_SUPPORTED_POINT 10
+#define SITRONIX_I2C_TOUCH_DRV_NAME "sitronix"
+#define SITRONIX_I2C_TOUCH_DEV_NAME "sitronixDev"
+#define SITRONIX_I2C_TOUCH_MT_INPUT_DEV_NAME "sitronix-i2c-touch-mt"
+#define SITRONIX_I2C_TOUCH_KEY_INPUT_DEV_NAME "sitronix-i2c-touch-key"
+
+#ifdef CONFIG_MACH_DEVKIT8000
+#define SITRONIX_RESET_GPIO	170
+#define SITRONIX_INT_GPIO	157
+#elif defined(CONFIG_MACH_OMAP4_PANDA)
+#define SITRONIX_RESET_GPIO	44
+#define SITRONIX_INT_GPIO	47
+#elif defined(CONFIG_ARCH_MSM8X60)
+#define SITRONIX_RESET_GPIO	58
+#define SITRONIX_INT_GPIO	61
+#endif // CONFIG_MACH_DEVKIT8000
+
+// MT SLOT feature is implmented in linux kernel 2.6.38 and later. Make sure that version of your linux kernel before using this feature.
+//#define SITRONIX_SUPPORT_MT_SLOT
+//#define SITRONIX_SWAP_XY
+//#define SITRONIX_I2C_COMBINED_MESSAGE
+#ifndef SITRONIX_I2C_COMBINED_MESSAGE
+#define SITRONIX_I2C_SINGLE_MESSAGE
+#endif // SITRONIX_I2C_COMBINED_MESSAGE
+//#define SITRONIX_MONITOR_THREAD
+#define DELAY_MONITOR_THREAD_START_PROBE 10000
+#define DELAY_MONITOR_THREAD_START_RESUME 3000
+#define SITRONIX_FW_UPGRADE_FEATURE
+//#define SITRONIX_PERMISSION_THREAD
+#define SITRONIX_SYSFS
+#define SITRONIX_LEVEL_TRIGGERED
+
+// When enable_irq() is invoked, irq will be sent once while INT is not triggered if CONFIG_HARDIRQS_SW_RESEND is set.
+// This behavior is implemented by linux kernel, it is used to prevent irq from losting when irq is edge-triggered mode.
+#ifndef SITRONIX_LEVEL_TRIGGERED
+#define SITRONIX_INT_POLLING_MODE
+#define INT_POLLING_MODE_INTERVAL 14
+#endif // SITRONIX_LEVEL_TRIGGERED
+//#define SITRONIX_IDENTIFY_ID
+//#define SITRONIX_MULTI_SLAVE_ADDR
+
+//#define EnableDbgMsg 1
+//#define EnableUpgradeMsg 1
+
+#ifdef EnableDbgMsg
+#define DbgMsg(arg...) printk(arg)
+#else
+#define DbgMsg(arg...)
+#endif
+
+#ifdef EnableUpgradeMsg
+#define UpgradeMsg(arg...) printk(arg)
+#else
+#define UpgradeMsg(arg...)
+#endif
+
+typedef enum{
+	FIRMWARE_VERSION,
+	STATUS_REG,
+	DEVICE_CONTROL_REG,
+	TIMEOUT_TO_IDLE_REG,
+	XY_RESOLUTION_HIGH,
+	X_RESOLUTION_LOW,
+	Y_RESOLUTION_LOW,
+	DEVICE_CONTROL_REG2 = 0x09,
+	FIRMWARE_REVISION_3 = 0x0C,
+	FIRMWARE_REVISION_2,
+	FIRMWARE_REVISION_1,
+	FIRMWARE_REVISION_0,
+	FINGERS,
+	KEYS_REG,
+	XY0_COORD_H,
+	X0_COORD_L,
+	Y0_COORD_L,
+	I2C_PROTOCOL = 0x3E,
+	MAX_NUM_TOUCHES,
+	DATA_0_HIGH,
+	DATA_0_LOW,
+	MISC_CONTROL = 0xF1,
+	SMART_WAKE_UP_REG = 0xF2,
+	CHIP_ID = 0xF4,
+	PAGE_REG = 0xff,
+}RegisterOffset;
+
+
+//#define SITRONIX_SMART_WAKE_UP
+#ifdef SITRONIX_SMART_WAKE_UP
+typedef enum{
+	SWK_NO = 0x0,
+	CHARACTER_C	    = 0x63,
+	CHARACTER_E	    = 0x65,
+	CHARACTER_M	    = 0x6D,
+	CHARACTER_O	    = 0x6F,
+	CHARACTER_S	    = 0x73,
+	CHARACTER_V	    = 0x76,
+	CHARACTER_W	    = 0x77,
+	CHARACTER_Z	    = 0x7A,
+	LEFT_TO_RIGHT_SLIDE = 0xB0,
+	RIGHT_TO_LEFT_SLIDE = 0xB4,
+	TOP_TO_DOWN_SLIDE   = 0xB8,
+	DOWN_TO_UP_SLIDE    = 0xBC,
+	DOUBLE_CLICK	    = 0xC0,
+	SINGLE_CLICK	    = 0xC8,
+}SWK_ID;
+#endif
+
+//#define SITRONIX_GESTURE
+#ifdef SITRONIX_GESTURE
+typedef enum{
+	G_NO 			 = 0x0,
+	G_ZOOM_IN	   	 = 0x2,
+	G_ZOOM_OUT	 = 0x3,
+	G_L_2_R		 = 0x4,
+	G_R_2_L		 = 0x5,
+	G_T_2_D		 = 0x6,
+	G_D_2_T		 = 0x7,
+	G_PALM		   	 = 0x8,
+	G_SINGLE_TAB	 = 0x9,
+}GESTURE_ID;
+#endif
+
+#define SITRONIX_TS_CHANGE_MODE_DELAY 150
+
+typedef enum{
+	XY_COORD_H,
+	X_COORD_L,
+	Y_COORD_L,
+	PIXEL_DATA_LENGTH_B,
+	PIXEL_DATA_LENGTH_A,
+}PIXEL_DATA_FORMAT;
+
+#define X_RES_H_SHFT 4
+#define X_RES_H_BMSK 0xf
+#define Y_RES_H_SHFT 0
+#define Y_RES_H_BMSK 0xf
+#define FINGERS_SHFT 0
+#define FINGERS_BMSK 0xf
+#define X_COORD_VALID_SHFT 7
+#define X_COORD_VALID_BMSK 0x1
+#define X_COORD_H_SHFT 4
+#define X_COORD_H_BMSK 0x7
+#define Y_COORD_H_SHFT 0
+#define Y_COORD_H_BMSK 0x7
+
+typedef enum{
+	SITRONIX_RESERVED_TYPE_0,
+	SITRONIX_A_TYPE,
+	SITRONIX_B_TYPE,
+}I2C_PROTOCOL_TYPE;
+
+#define I2C_PROTOCOL_SHFT 0x0
+#define I2C_PROTOCOL_BMSK 0x3
+
+typedef enum{
+	SENSING_BOTH,
+	SENSING_X_ONLY,
+	SENSING_Y_ONLY,
+	SENSING_BOTH_NOT,
+}ONE_D_SENSING_CONTROL_MODE;
+
+#define ONE_D_SENSING_CONTROL_SHFT 0x2
+#define ONE_D_SENSING_CONTROL_BMSK 0x3
+
+#define SMT_IOC_MAGIC   0xf1
+
+enum{
+	SMT_GET_DRIVER_REVISION = 1,
+	SMT_GET_FW_REVISION,
+	SMT_ENABLE_IRQ,
+	SMT_DISABLE_IRQ,
+	SMT_RESUME,
+	SMT_SUSPEND,
+	SMT_HW_RESET,
+	SMT_REPROBE,
+	SMT_RAW_TEST,
+	SMT_PEN_ON,
+	SMT_PEN_OFF,
+	SMT_IOC_MAXNR,
+};
+
+#define IOCTL_SMT_GET_DRIVER_REVISION				_IOC(_IOC_READ,  SMT_IOC_MAGIC, SMT_GET_DRIVER_REVISION, 			1)
+#define IOCTL_SMT_GET_FW_REVISION					_IOC(_IOC_READ,  SMT_IOC_MAGIC, SMT_GET_FW_REVISION, 				4)
+#define IOCTL_SMT_ENABLE_IRQ					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_ENABLE_IRQ, 0)
+#define IOCTL_SMT_DISABLE_IRQ					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_DISABLE_IRQ, 0)
+#define IOCTL_SMT_RESUME					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_RESUME, 0)
+#define IOCTL_SMT_SUSPEND					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_SUSPEND, 0)
+#define IOCTL_SMT_HW_RESET					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_HW_RESET, 0)
+#define IOCTL_SMT_REPROBE					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_REPROBE, 0)
+#define IOCTL_SMT_RAW_TEST					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_RAW_TEST, 0)
+#define IOCTL_SMT_PEN_ON					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_PEN_ON, 0)
+#define IOCTL_SMT_PEN_OFF					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_PEN_OFF, 0)								
+
+
+//#define SITRONIX_AA_KEY
+#define SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+
+typedef struct {
+	u8 y_h		:3,
+	   reserved	:1,
+	   x_h		:3,
+	   valid	:1;
+	u8 x_l;
+	u8 y_l;
+	u8 z;
+}xy_data_t;
+
+typedef struct {
+	xy_data_t	xy_data[SITRONIX_MAX_SUPPORTED_POINT];
+}stx_report_data_t;
+
+struct sitronix_sensor_key_t{
+	unsigned int code;
+};
+
+#ifndef SITRONIX_AA_KEY
+enum{
+	AREA_NONE,
+	AREA_DISPLAY,
+};
+#else
+enum{
+	AREA_NONE,
+	AREA_DISPLAY,
+	AREA_KEY,
+	AREA_INVALID,
+};
+
+struct sitronix_AA_key{
+	int x_low;
+	int x_high;
+	int y_low;
+	int y_high;
+	unsigned int code;
+};
+#endif // SITRONIX_AA_KEY
+
+typedef struct {
+	uint8_t offset;
+	uint8_t shft;
+	uint8_t bmsk;
+}sitronix_reg_field;
+
+typedef struct {
+	sitronix_reg_field dis_coord_flag;
+}sitronix_i2c_protocol_map;
+
+static sitronix_i2c_protocol_map sitronix_i2c_ptcl_v1 = {
+	.dis_coord_flag = {
+		.offset = 0x09,
+		.shft = 0,
+		.bmsk = 0x1,
+	},
+};
+
+static sitronix_i2c_protocol_map sitronix_i2c_ptcl_v2 = {
+	.dis_coord_flag = {
+		.offset = 0xF1,
+		.shft = 2,
+		.bmsk = 0x1,
+	},
+};
+
+struct sitronix_i2c_touch_platform_data {
+	uint32_t version;	/* Use this entry for panels with */
+				/* (major << 8 | minor) version or above. */
+				/* If non-zero another array entry follows */
+	void (*reset_ic)(void);
+};
+
+//petitk add
+
+//#define CONFIG_TOUCHSCREEN_SITRONIX_I2C_TOUCH
+/* #define KERN_DEBUG    "<7>"    /\* debug-level messages *\/ */
+////////////
+
+#define stmsg(format, ...)	\
+	printk("[sitronix 000] " format "\n", ## __VA_ARGS__)
+
+//Upgrade
+//#define ST_UPGRADE_FIRMWARE
+
+#ifdef ST_UPGRADE_FIRMWARE
+//#define ST_UPGRADE_BY_ID
+//#define ST_REPLACE_CFG
+//#define ST_FIREWARE_FILE
+#define ST_IC_A8008
+//#define ST_IC_A8010
+
+#ifdef ST_IC_A8008
+#define ST_FW_LEN	0x4000
+#define ST_CFG_LEN	0xFE
+#define ST_CFG_OFFSET	0x3F00
+#define ST_FLASH_PAGE_SIZE 1024
+#define ST_FLASH_SIZE 0x3FFE
+#define ST_CHECK_FW_OFFSET 	0x3F00
+
+#else
+#define ST_FW_LEN	0x6900
+#define ST_CFG_LEN	0x2C0
+#define ST_CFG_OFFSET	0xBC00
+#define ST_FLASH_PAGE_SIZE 1024
+#define ST_FLASH_SIZE 0xBEC0
+#define ST_CHECK_FW_OFFSET 	0x6900
+#endif
+
+
+#define ISP_PACKET_SIZE 8
+#define ST_FW_INFO_LEN	0x10
+
+#define ISP_CMD_ERASE						0x80
+#define ISP_CMD_SEND_DATA					0x81
+#define	ISP_CMD_WRITE_FLASH					0x82
+#define	ISP_CMD_READ_FLASH					0x83
+#define	ISP_CMD_RESET						0x84
+#define	ISP_CMD_UNLOCK						0x87
+#define	ISP_CMD_READY						0x8F
+
+#ifdef ST_FIREWARE_FILE
+// from file
+#define st_file file
+#define st_filp_open filp_open
+#define st_filp_close filp_close
+#define ST_FW_DIR "/data"
+#define ST_FW_PATH "/data/sitronix_fw.bin"
+#define ST_CFG_PATH "/data/CFG_4221_0x55.cfg"
+//#define ST_FW_PATH "/data/FW4221_16K.bin"
+
+#else
+// from .h
+#define SITRONIX_FW {\
+}
+
+#define SITRONIX_CFG {\
+}
+
+#ifdef ST_UPGRADE_BY_ID
+#define SITRONIX_IDS {\
+0x0,0x0,0x0,0x0,\
+0x1,0x2,0x3,0x4\
+}
+#define SITRONIX_ID_OFF {\
+0xD6,\
+0xD6\
+}
+
+#define SITRONIX_FW1 {\
+}
+
+#define SITRONIX_CFG1 {\
+}
+
+#define SITRONIX_FW2 {\
+}
+
+#define SITRONIX_CFG2 {\
+}
+
+#endif	//ST_UPGRADE_BY_ID
+
+#ifdef ST_REPLACE_CFG
+#define STIRONIX_CFG_CHECKSUM_OFFSET	0xFC
+#define STIRONIX_FW_SET_COUNT	2
+#define SITRONIX_CFG_VERSION {\
+0x47,\
+0x48\
+}
+#define SITRONIX_F_OFFSET {\
+0x9E,0x9F,0xA0,\
+0x9E,0x9F,0xA0\
+}
+#define SITRONIX_T_OFFSET {\
+0x9E,0x9F,0xA0\
+}
+#endif	//ST_REPLACE_CFG
+
+#endif //ST_FIREWARE_FILE
+
+#endif //ST_UPGRADE_FIRMWARE
+//
+
+//#define ST_TEST_RAW
+
+#ifdef ST_TEST_RAW
+#define MAX_RX_COUNT	12
+#define MAX_TX_COUNT	21
+#define MAX_KEY_COUNT	4
+#define MAX_SENSOR_COUNT	MAX_RX_COUNT+MAX_TX_COUNT+MAX_KEY_COUNT
+#define TX_ASSIGNMENT	1
+
+#define MAX_RAW_LIMIT	7800
+#define MIN_RAW_LIMIT	3700
+#endif //ST_TEST_RAW
+
+#if defined(ST_TEST_RAW) || defined(ST_UPGRADE_FIRMWARE)
+#define st_u8 u8
+#define st_char char
+#define st_msleep msleep
+#define st_int int
+#endif
+
+#define ST_PEN_SWITCH
+
+#endif // __SITRONIX_I2C_TOUCH_h
