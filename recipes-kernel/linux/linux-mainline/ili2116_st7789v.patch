diff --git a/drivers/Kconfig b/drivers/Kconfig
index e1e2066..662b0ab 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -12,6 +12,8 @@ source "drivers/mtd/Kconfig"
 
 source "drivers/of/Kconfig"
 
+source "drivers/stromer/Kconfig"
+
 source "drivers/parport/Kconfig"
 
 source "drivers/pnp/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 53abb4a..0124cf0 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -8,6 +8,8 @@
 obj-y				+= irqchip/
 obj-y				+= bus/
 
+obj-y				+= stromer/
+
 obj-$(CONFIG_GENERIC_PHY)	+= phy/
 
 # GPIO must come after pinctrl as gpios may need to mux pins etc
diff --git a/drivers/stromer/Kconfig b/drivers/stromer/Kconfig
new file mode 100644
index 0000000..a59fdcb
--- /dev/null
+++ b/drivers/stromer/Kconfig
@@ -0,0 +1,29 @@
+
+menuconfig STROMER_DP
+	tristate "Stromer SUI - Display und Touch driver"
+	---help---
+	  Framebuffer driver for the IMX6UL LCDIF periphery in combination
+	  with the ST7789 based display
+
+if STROMER_DP
+
+config ILI2116_TOUCH
+	tristate "ILI2116 touch controller driver"
+	help
+	  ILI2116 Touch controller driver using I2C interfaces
+
+config IMX6UL_LCDIF_ST7789
+	tristate "LCDIF peripheral driver for a ST7789 display"
+	help
+	  LCDIF driver for IMX6UL for usage with a ST7789 based
+	  display
+
+config ST7789_SPI
+	tristate "ST7789 - Supports spi init functionality required for RGB interface"
+	depends on IMX6UL_LCDIF_ST7789
+	help
+	  SPI driver for the ST7789 3-wire interface (1. SCL, 2. CS, 3. MISO/MOSI)
+	  providing functions to inititalize the display for RGB interface
+
+endif
+
diff --git a/drivers/stromer/Makefile b/drivers/stromer/Makefile
new file mode 100644
index 0000000..9a682ec
--- /dev/null
+++ b/drivers/stromer/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_ILI2116_TOUCH)        += ili2116.o
+obj-$(CONFIG_IMX6UL_LCDIF_ST7789)  += fb_imx6_lcdif.o
+obj-$(CONFIG_ST7789_SPI)           += fb_imx6_st7789_spi.o
diff --git a/drivers/stromer/fb_imx6.h b/drivers/stromer/fb_imx6.h
new file mode 100644
index 0000000..3098c75
--- /dev/null
+++ b/drivers/stromer/fb_imx6.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2017 Christian Duenki, Escatec Switzerland AG
+ */
+
+#define DEBUG
+
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+/** SPI driver name */
+#define SPI_DRIVER_NAME "st7789v"
+
+/** Perform SPI init sequence */
+#define DO_SPI_INIT_SEQUENCE
+/** Do panning in spi driver */
+#define DO_SPI_PAN
+/** Register SPI device */
+#define DO_REGISTER_SPI_DEVICE
+/** Do panning in lcdif driver */
+//#define DO_LCDIF_PAN
+
+/** Reset pin responsibility */
+/* define RESET_DONE_BY_LCDIF */
+
+#if defined (RESET_DONE_BY_LCDIF)
+ #define GPIO_LCDIF_RESET  (int)68
+#else
+ #define GPIO_SPI_RESET    (int)68
+#endif
+
+#define NUMARGS(...) (sizeof((int[]){__VA_ARGS__})/sizeof(int))
+
+#define st7789_write_reg(...)				\
+	st7789_write_register(NUMARGS(__VA_ARGS__), __VA_ARGS__)
+
+struct mxsfb_info {
+	struct fb_info fb_info;
+	struct platform_device *pdev;
+	struct clk *clk;
+	struct clk *clk_axi;
+	struct clk *clk_disp_axi;
+	void __iomem *base;	/* registers */
+	unsigned allocated_size;
+	int enabled;
+	unsigned ld_intf_width;
+	unsigned dotclk_delay;
+	const struct mxsfb_devdata *devdata;
+	u32 sync;
+	struct regulator *reg_lcd;
+#if defined (GPIO_LCDIF_RESET)
+	int gpio_reset;
+#endif
+};
diff --git a/drivers/stromer/fb_imx6_lcdif.c b/drivers/stromer/fb_imx6_lcdif.c
new file mode 100644
index 0000000..84e5edd
--- /dev/null
+++ b/drivers/stromer/fb_imx6_lcdif.c
@@ -0,0 +1,1015 @@
+/*
+ * Copyright (C) 2017 Christian Duenki, Escatec Switzerland AG
+ *
+ * This code is based on:
+ * Author: Juefgen Beisert, Pengutronix
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ */
+/**
+ * @file
+ * @brief LCDIF driver for i.MX6UL (based on mxsfb.c)
+ *
+ * Only the Dotclock mode of the LCDIF is implemented (RGB interface)
+ *
+ * This driver depends on a correct setup of the pins used for this purpose
+ * (platform specific).
+ *
+ * For the developer: Don't forget to set the data bus width to the display
+ * in the imx_fb_videomode structure. You will else end up with ugly colours.
+ * If you fight against jitter you can vary the clock delay. This is a feature
+ * of the i.MX6 and you can vary it between 2 ns ... 8 ns in 2 ns steps. Give
+ * the required value in the imx_fb_videomode structure.
+ */
+
+#include "fb_imx6.h"
+
+#define DRIVER_NAME "mxsfb_st7789"
+
+/* LCDIF part */
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/regulator/consumer.h>
+#include <video/of_display_timing.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+#include <linux/export.h>
+#if defined (GPIO_LCDIF_RESET)
+ #include <linux/gpio.h>
+ #include <linux/delay.h>
+#endif
+
+/* SPI */
+#include <linux/spi/spi.h>
+
+#define REG_SET	4
+#define REG_CLR	8
+
+#define LCDC_CTRL			0x00
+#define LCDC_CTRL1			0x10
+#define LCDC_V4_CTRL2			0x20
+#define LCDC_V4_TRANSFER_COUNT		0x30
+#define LCDC_V4_CUR_BUF			0x40
+#define LCDC_V4_NEXT_BUF		0x50
+#define LCDC_TIMING			0x60
+#define LCDC_VDCTRL0			0x70
+#define LCDC_VDCTRL1			0x80
+#define LCDC_VDCTRL2			0x90
+#define LCDC_VDCTRL3			0xa0
+#define LCDC_VDCTRL4			0xb0
+#define LCDC_DVICTRL0			0xc0
+#define LCDC_DVICTRL1			0xd0
+#define LCDC_DVICTRL2			0xe0
+#define LCDC_DVICTRL3			0xf0
+#define LCDC_DVICTRL4			0x100
+#define LCDC_V4_DATA			0x180
+#define LCDC_V4_DEBUG0			0x1d0
+
+#define CTRL_SFTRST			(1 << 31)
+#define CTRL_CLKGATE			(1 << 30)
+#define CTRL_BYPASS_COUNT		(1 << 19)
+#define CTRL_VSYNC_MODE			(1 << 18)
+#define CTRL_DOTCLK_MODE		(1 << 17)
+#define CTRL_DATA_SELECT		(1 << 16)
+#define CTRL_SET_BUS_WIDTH(x)		(((x) & 0x3) << 10)
+#define CTRL_GET_BUS_WIDTH(x)		(((x) >> 10) & 0x3)
+#define CTRL_SET_WORD_LENGTH(x)		(((x) & 0x3) << 8)
+#define CTRL_GET_WORD_LENGTH(x)		(((x) >> 8) & 0x3)
+#define CTRL_MASTER			(1 << 5)
+#define CTRL_DF16			(1 << 3)
+#define CTRL_DF18			(1 << 2)
+#define CTRL_DF24			(1 << 1)
+#define CTRL_RUN			(1 << 0)
+
+#define CTRL1_FIFO_CLEAR		(1 << 21)
+#define CTRL1_SET_BYTE_PACKAGING(x)	(((x) & 0xf) << 16)
+#define CTRL1_GET_BYTE_PACKAGING(x)	(((x) >> 16) & 0xf)
+
+#define TRANSFER_COUNT_SET_VCOUNT(x)	(((x) & 0xffff) << 16)
+#define TRANSFER_COUNT_GET_VCOUNT(x)	(((x) >> 16) & 0xffff)
+#define TRANSFER_COUNT_SET_HCOUNT(x)	((x) & 0xffff)
+#define TRANSFER_COUNT_GET_HCOUNT(x)	((x) & 0xffff)
+
+#define VDCTRL0_ENABLE_PRESENT		(1 << 28)
+#define VDCTRL0_VSYNC_ACT_HIGH		(1 << 27)
+#define VDCTRL0_HSYNC_ACT_HIGH		(1 << 26)
+#define VDCTRL0_DOTCLK_ACT_FALLING	(1 << 25)
+#define VDCTRL0_ENABLE_ACT_HIGH		(1 << 24)
+#define VDCTRL0_VSYNC_PERIOD_UNIT	(1 << 21)
+#define VDCTRL0_VSYNC_PULSE_WIDTH_UNIT	(1 << 20)
+#define VDCTRL0_HALF_LINE		(1 << 19)
+#define VDCTRL0_HALF_LINE_MODE		(1 << 18)
+#define VDCTRL0_SET_VSYNC_PULSE_WIDTH(x) ((x) & 0x3ffff)
+#define VDCTRL0_GET_VSYNC_PULSE_WIDTH(x) ((x) & 0x3ffff)
+
+#define VDCTRL2_SET_HSYNC_PERIOD(x)	((x) & 0x3ffff)
+#define VDCTRL2_GET_HSYNC_PERIOD(x)	((x) & 0x3ffff)
+
+#define VDCTRL3_MUX_SYNC_SIGNALS	(1 << 29)
+#define VDCTRL3_VSYNC_ONLY		(1 << 28)
+#define SET_HOR_WAIT_CNT(x)		(((x) & 0xfff) << 16)
+#define GET_HOR_WAIT_CNT(x)		(((x) >> 16) & 0xfff)
+#define SET_VERT_WAIT_CNT(x)		((x) & 0xffff)
+#define GET_VERT_WAIT_CNT(x)		((x) & 0xffff)
+
+#define VDCTRL4_SET_DOTCLK_DLY(x)	(((x) & 0x7) << 29)
+#define VDCTRL4_GET_DOTCLK_DLY(x)	(((x) >> 29) & 0x7)
+#define VDCTRL4_SYNC_SIGNALS_ON		(1 << 18)
+#define SET_DOTCLK_H_VALID_DATA_CNT(x)	((x) & 0x3ffff)
+
+#define DEBUG0_HSYNC			(1 < 26)
+#define DEBUG0_VSYNC			(1 < 25)
+
+#define MIN_XRES			120
+#define MIN_YRES			120
+
+#define RED 0
+#define GREEN 1
+#define BLUE 2
+#define TRANSP 3
+
+#define STMLCDIF_8BIT  1 /** pixel data bus to the display is of 8 bit width */
+#define STMLCDIF_16BIT 0 /** pixel data bus to the display is of 16 bit width */
+#define STMLCDIF_18BIT 2 /** pixel data bus to the display is of 18 bit width */
+#define STMLCDIF_24BIT 3 /** pixel data bus to the display is of 24 bit width */
+
+#define MXSFB_SYNC_DATA_ENABLE_HIGH_ACT	(1 << 6)
+#define MXSFB_SYNC_DOTCLK_FALLING_ACT	(1 << 7) /* negtive edge sampling */
+
+//#define SPI_BUS_SPEED 6500000 /* Max read clock cycle 150 ns -> 6.5 MHz */
+#define SPI_BUS_SPEED 1000000
+#define SPI_BUS 0 /** Bus used for display initialization */
+#define SPI_DISP_CS 0 /** CS on selected SPI bus to access display */
+
+/* CPU dependent register offsets */
+struct mxsfb_devdata {
+	unsigned transfer_count;
+	unsigned cur_buf;
+	unsigned next_buf;
+	unsigned debug0;
+	unsigned hs_wdth_mask;
+	unsigned hs_wdth_shift;
+};
+
+static const struct mxsfb_devdata mxsfb_devdata = {
+	.transfer_count = LCDC_V4_TRANSFER_COUNT,
+	.cur_buf = LCDC_V4_CUR_BUF,
+	.next_buf = LCDC_V4_NEXT_BUF,
+	.debug0 = LCDC_V4_DEBUG0,
+	.hs_wdth_mask = 0x3fff,
+	.hs_wdth_shift = 18,
+};
+
+#define to_imxfb_host(x) (container_of(x, struct mxsfb_info, fb_info))
+
+/* mask and shift depends on architecture */
+static inline u32 set_hsync_pulse_width(struct mxsfb_info *host, unsigned val)
+{
+	return (val & host->devdata->hs_wdth_mask) <<
+		host->devdata->hs_wdth_shift;
+}
+
+static inline u32 get_hsync_pulse_width(struct mxsfb_info *host, unsigned val)
+{
+	return (val >> host->devdata->hs_wdth_shift) &
+		host->devdata->hs_wdth_mask;
+}
+
+static const struct fb_bitfield def_rgb565[] = {
+	[RED] = {
+		.offset = 11,
+		.length = 5,
+	},
+	[GREEN] = {
+		.offset = 5,
+		.length = 6,
+	},
+	[BLUE] = {
+		.offset = 0,
+		.length = 5,
+	},
+	[TRANSP] = {	/* no support for transparency */
+		.length = 0,
+	}
+};
+
+static const struct fb_bitfield def_rgb888[] = {
+	[RED] = {
+		.offset = 16,
+		.length = 8,
+	},
+	[GREEN] = {
+		.offset = 8,
+		.length = 8,
+	},
+	[BLUE] = {
+		.offset = 0,
+		.length = 8,
+	},
+	[TRANSP] = {	/* no support for transparency */
+		.length = 0,
+	}
+};
+
+static inline unsigned chan_to_field(unsigned chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int mxsfb_check_var(struct fb_var_screeninfo *var,
+		struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	const struct fb_bitfield *rgb = NULL;
+
+	if (var->xres < MIN_XRES)
+		var->xres = MIN_XRES;
+	if (var->yres < MIN_YRES)
+		var->yres = MIN_YRES;
+
+	var->xres_virtual = var->xres;
+
+	var->yres_virtual = var->yres;
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		/* always expect RGB 565 */
+		rgb = def_rgb565;
+		break;
+	case 32:
+		switch (host->ld_intf_width) {
+		case STMLCDIF_8BIT:
+			pr_debug("Unsupported LCD bus width mapping\n");
+			break;
+		case STMLCDIF_16BIT:
+		case STMLCDIF_18BIT:
+		case STMLCDIF_24BIT:
+			/* real 24 bit */
+			rgb = def_rgb888;
+			break;
+		}
+		break;
+	default:
+		pr_err("Unsupported colour depth: %u\n", var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	/*
+	 * Copy the RGB parameters for this display
+	 * from the machine specific parameters.
+	 */
+	var->red    = rgb[RED];
+	var->green  = rgb[GREEN];
+	var->blue   = rgb[BLUE];
+	var->transp = rgb[TRANSP];
+
+	return 0;
+}
+
+static inline void mxsfb_enable_axi_clk(struct mxsfb_info *host)
+{
+	if (host->clk_axi)
+		clk_prepare_enable(host->clk_axi);
+}
+
+static inline void mxsfb_disable_axi_clk(struct mxsfb_info *host)
+{
+	if (host->clk_axi)
+		clk_disable_unprepare(host->clk_axi);
+}
+
+void mxsfb_enable_controller(struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	u32 reg;
+	int ret;
+
+	dev_dbg(&host->pdev->dev, "%s\n", __func__);
+
+	if (host->reg_lcd) {
+		ret = regulator_enable(host->reg_lcd);
+		if (ret) {
+			dev_err(&host->pdev->dev,
+				"lcd regulator enable failed:	%d\n", ret);
+			return;
+		}
+	}
+
+	if (host->clk_disp_axi)
+		clk_prepare_enable(host->clk_disp_axi);
+	clk_prepare_enable(host->clk);
+	clk_set_rate(host->clk, PICOS2KHZ(fb_info->var.pixclock) * 1000U);
+
+	mxsfb_enable_axi_clk(host);
+
+	/* if it was disabled, re-enable the mode again */
+	writel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_SET);
+
+	/* enable the SYNC signals first, then the DMA engine */
+	reg = readl(host->base + LCDC_VDCTRL4);
+	reg |= VDCTRL4_SYNC_SIGNALS_ON;
+	writel(reg, host->base + LCDC_VDCTRL4);
+
+	writel(CTRL_RUN, host->base + LCDC_CTRL + REG_SET);
+
+	host->enabled = 1;
+}
+EXPORT_SYMBOL(mxsfb_enable_controller);
+
+void mxsfb_disable_controller(struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	unsigned loop;
+	u32 reg;
+	int ret;
+
+	dev_dbg(&host->pdev->dev, "%s\n", __func__);
+
+	/*
+	 * Even if we disable the controller here, it will still continue
+	 * until its FIFOs are running out of data
+	 */
+	writel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_CLR);
+
+	loop = 1000;
+	while (loop) {
+		reg = readl(host->base + LCDC_CTRL);
+		if (!(reg & CTRL_RUN))
+			break;
+		loop--;
+	}
+
+	reg = readl(host->base + LCDC_VDCTRL4);
+	writel(reg & ~VDCTRL4_SYNC_SIGNALS_ON, host->base + LCDC_VDCTRL4);
+
+	mxsfb_disable_axi_clk(host);
+
+	clk_disable_unprepare(host->clk);
+	if (host->clk_disp_axi)
+		clk_disable_unprepare(host->clk_disp_axi);
+
+	host->enabled = 0;
+
+	if (host->reg_lcd) {
+		ret = regulator_disable(host->reg_lcd);
+		if (ret)
+			dev_err(&host->pdev->dev,
+				"lcd regulator disable failed: %d\n", ret);
+	}
+}
+EXPORT_SYMBOL(mxsfb_disable_controller);
+
+static int mxsfb_set_par(struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	u32 ctrl, vdctrl0, vdctrl4;
+	int line_size, fb_size;
+	int reenable = 0;
+
+	line_size =  fb_info->var.xres * (fb_info->var.bits_per_pixel >> 3);
+	fb_size = fb_info->var.yres_virtual * line_size;
+
+	if (fb_size > fb_info->fix.smem_len)
+		return -ENOMEM;
+
+	fb_info->fix.line_length = line_size;
+
+	/*
+	 * It seems, you can't re-program the controller if it is still running.
+	 * This may lead into shifted pictures (FIFO issue?).
+	 * So, first stop the controller and drain its FIFOs
+	 */
+	if (host->enabled) {
+		reenable = 1;
+		mxsfb_disable_controller(fb_info);
+	}
+
+	mxsfb_enable_axi_clk(host);
+
+	/* clear the FIFOs */
+	writel(CTRL1_FIFO_CLEAR, host->base + LCDC_CTRL1 + REG_SET);
+
+	ctrl = CTRL_BYPASS_COUNT | CTRL_MASTER |
+		CTRL_SET_BUS_WIDTH(host->ld_intf_width);
+
+	switch (fb_info->var.bits_per_pixel) {
+	case 16:
+		dev_dbg(&host->pdev->dev, "Setting up RGB565 mode\n");
+		ctrl |= CTRL_SET_WORD_LENGTH(0);
+		writel(CTRL1_SET_BYTE_PACKAGING(0xf), host->base + LCDC_CTRL1);
+		break;
+	case 32:
+		dev_dbg(&host->pdev->dev, "Setting up RGB888/666 mode\n");
+		ctrl |= CTRL_SET_WORD_LENGTH(3);
+		switch (host->ld_intf_width) {
+		case STMLCDIF_8BIT:
+			mxsfb_disable_axi_clk(host);
+			dev_err(&host->pdev->dev,
+					"Unsupported LCD bus width mapping\n");
+			return -EINVAL;
+		case STMLCDIF_16BIT:
+		case STMLCDIF_18BIT:
+		case STMLCDIF_24BIT:
+			/* real 24 bit */
+			break;
+		}
+		/* do not use packed pixels = one pixel per word instead */
+		writel(CTRL1_SET_BYTE_PACKAGING(0x7), host->base + LCDC_CTRL1);
+		break;
+	default:
+		mxsfb_disable_axi_clk(host);
+		dev_err(&host->pdev->dev, "Unhandled color depth of %u\n",
+				fb_info->var.bits_per_pixel);
+		return -EINVAL;
+	}
+
+	writel(ctrl, host->base + LCDC_CTRL);
+
+	writel(TRANSFER_COUNT_SET_VCOUNT(fb_info->var.yres) |
+			TRANSFER_COUNT_SET_HCOUNT(fb_info->var.xres),
+			host->base + host->devdata->transfer_count);
+
+	vdctrl0 = VDCTRL0_ENABLE_PRESENT |	/* always in DOTCLOCK mode */
+		VDCTRL0_VSYNC_PERIOD_UNIT |
+		VDCTRL0_VSYNC_PULSE_WIDTH_UNIT |
+		VDCTRL0_SET_VSYNC_PULSE_WIDTH(fb_info->var.vsync_len);
+	if (fb_info->var.sync & FB_SYNC_HOR_HIGH_ACT)
+		vdctrl0 |= VDCTRL0_HSYNC_ACT_HIGH;
+	if (fb_info->var.sync & FB_SYNC_VERT_HIGH_ACT)
+		vdctrl0 |= VDCTRL0_VSYNC_ACT_HIGH;
+	if (host->sync & MXSFB_SYNC_DATA_ENABLE_HIGH_ACT)
+		vdctrl0 |= VDCTRL0_ENABLE_ACT_HIGH;
+	if (host->sync & MXSFB_SYNC_DOTCLK_FALLING_ACT)
+		vdctrl0 |= VDCTRL0_DOTCLK_ACT_FALLING;
+
+	writel(vdctrl0, host->base + LCDC_VDCTRL0);
+
+	/* frame length in lines */
+	writel(fb_info->var.upper_margin + fb_info->var.vsync_len +
+		fb_info->var.lower_margin + fb_info->var.yres,
+		host->base + LCDC_VDCTRL1);
+
+	/* line length in units of clocks or pixels */
+	writel(set_hsync_pulse_width(host, fb_info->var.hsync_len) |
+		VDCTRL2_SET_HSYNC_PERIOD(fb_info->var.left_margin +
+		fb_info->var.hsync_len + fb_info->var.right_margin +
+		fb_info->var.xres),
+		host->base + LCDC_VDCTRL2);
+
+	writel(SET_HOR_WAIT_CNT(fb_info->var.left_margin +
+		fb_info->var.hsync_len) |
+		SET_VERT_WAIT_CNT(fb_info->var.upper_margin +
+			fb_info->var.vsync_len),
+		host->base + LCDC_VDCTRL3);
+
+	vdctrl4 = SET_DOTCLK_H_VALID_DATA_CNT(fb_info->var.xres);
+	vdctrl4 |= VDCTRL4_SET_DOTCLK_DLY(host->dotclk_delay);
+	writel(vdctrl4, host->base + LCDC_VDCTRL4);
+
+	writel(fb_info->fix.smem_start +
+			fb_info->fix.line_length * fb_info->var.yoffset,
+			host->base + host->devdata->next_buf);
+
+	mxsfb_disable_axi_clk(host);
+
+	if (reenable)
+		mxsfb_enable_controller(fb_info);
+
+	return 0;
+}
+
+static int mxsfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+		u_int transp, struct fb_info *fb_info)
+{
+	unsigned int val;
+	int ret = -EINVAL;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (fb_info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+					7471 * blue) >> 16;
+
+	switch (fb_info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 12 or 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fb_info->pseudo_palette;
+
+			val  = chan_to_field(red, &fb_info->var.red);
+			val |= chan_to_field(green, &fb_info->var.green);
+			val |= chan_to_field(blue, &fb_info->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+static int mxsfb_blank(int blank, struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		if (host->enabled)
+			mxsfb_disable_controller(fb_info);
+		break;
+
+	case FB_BLANK_UNBLANK:
+		if (!host->enabled)
+			mxsfb_enable_controller(fb_info);
+		break;
+	}
+	return 0;
+}
+
+int mxsfb_pan_display(struct fb_var_screeninfo *var,
+					  struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	unsigned offset;
+
+	if (var->xoffset != 0)
+		return -EINVAL;
+
+	offset = fb_info->fix.line_length * var->yoffset;
+
+	mxsfb_enable_axi_clk(host);
+
+	/* update on next VSYNC */
+	writel(fb_info->fix.smem_start + offset,
+			host->base + host->devdata->next_buf);
+
+	mxsfb_disable_axi_clk(host);
+
+	return 0;
+}
+EXPORT_SYMBOL(mxsfb_pan_display);
+
+static struct fb_ops mxsfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = mxsfb_check_var,
+	.fb_set_par = mxsfb_set_par,
+	.fb_setcolreg = mxsfb_setcolreg,
+	.fb_blank = mxsfb_blank,
+	.fb_pan_display = mxsfb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+};
+
+static int mxsfb_restore_mode(struct mxsfb_info *host,
+			struct fb_videomode *vmode)
+{
+	struct fb_info *fb_info = &host->fb_info;
+	unsigned line_count;
+	unsigned period;
+	unsigned long pa, fbsize;
+	int bits_per_pixel, ofs, ret = 0;
+	u32 transfer_count, vdctrl0, vdctrl2, vdctrl3, vdctrl4, ctrl;
+
+	mxsfb_enable_axi_clk(host);
+
+	/* Only restore the mode when the controller is running */
+	ctrl = readl(host->base + LCDC_CTRL);
+	if (!(ctrl & CTRL_RUN)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	vdctrl0 = readl(host->base + LCDC_VDCTRL0);
+	vdctrl2 = readl(host->base + LCDC_VDCTRL2);
+	vdctrl3 = readl(host->base + LCDC_VDCTRL3);
+	vdctrl4 = readl(host->base + LCDC_VDCTRL4);
+
+	transfer_count = readl(host->base + host->devdata->transfer_count);
+
+	vmode->xres = TRANSFER_COUNT_GET_HCOUNT(transfer_count);
+	vmode->yres = TRANSFER_COUNT_GET_VCOUNT(transfer_count);
+
+	switch (CTRL_GET_WORD_LENGTH(ctrl)) {
+	case 0:
+		bits_per_pixel = 16;
+		break;
+	case 3:
+		bits_per_pixel = 32;
+		break;
+	case 1:
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	fb_info->var.bits_per_pixel = bits_per_pixel;
+
+	vmode->pixclock = KHZ2PICOS(clk_get_rate(host->clk) / 1000U);
+	vmode->hsync_len = get_hsync_pulse_width(host, vdctrl2);
+	vmode->left_margin = GET_HOR_WAIT_CNT(vdctrl3) - vmode->hsync_len;
+	vmode->right_margin = VDCTRL2_GET_HSYNC_PERIOD(vdctrl2) -
+		vmode->hsync_len - vmode->left_margin - vmode->xres;
+	vmode->vsync_len = VDCTRL0_GET_VSYNC_PULSE_WIDTH(vdctrl0);
+	period = readl(host->base + LCDC_VDCTRL1);
+	vmode->upper_margin = GET_VERT_WAIT_CNT(vdctrl3) - vmode->vsync_len;
+	vmode->lower_margin = period - vmode->vsync_len -
+		vmode->upper_margin - vmode->yres;
+
+	vmode->vmode = FB_VMODE_NONINTERLACED;
+
+	vmode->sync = 0;
+	if (vdctrl0 & VDCTRL0_HSYNC_ACT_HIGH)
+		vmode->sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (vdctrl0 & VDCTRL0_VSYNC_ACT_HIGH)
+		vmode->sync |= FB_SYNC_VERT_HIGH_ACT;
+
+	pr_debug("Reconstructed video mode:\n");
+	pr_debug("%dx%d, hsync: %u left: %u, right: %u, vsync: %u, upper: %u, lower: %u\n",
+		vmode->xres, vmode->yres, vmode->hsync_len, vmode->left_margin,
+		vmode->right_margin, vmode->vsync_len, vmode->upper_margin,
+		vmode->lower_margin);
+	pr_debug("pixclk: %ldkHz\n", PICOS2KHZ(vmode->pixclock));
+
+	host->ld_intf_width = CTRL_GET_BUS_WIDTH(ctrl);
+	host->dotclk_delay = VDCTRL4_GET_DOTCLK_DLY(vdctrl4);
+
+	fb_info->fix.line_length = vmode->xres * (bits_per_pixel >> 3);
+
+	pa = readl(host->base + host->devdata->cur_buf);
+	fbsize = fb_info->fix.line_length * vmode->yres;
+	if (pa < fb_info->fix.smem_start) {
+		ret = -EINVAL;
+		goto err;
+	}
+	if (pa + fbsize > fb_info->fix.smem_start + fb_info->fix.smem_len) {
+		ret = -EINVAL;
+		goto err;
+	}
+	ofs = pa - fb_info->fix.smem_start;
+	if (ofs) {
+		memmove(fb_info->screen_base, fb_info->screen_base + ofs, fbsize);
+		writel(fb_info->fix.smem_start, host->base + host->devdata->next_buf);
+	}
+
+	line_count = fb_info->fix.smem_len / fb_info->fix.line_length;
+	fb_info->fix.ypanstep = 1;
+
+	clk_prepare_enable(host->clk);
+	host->enabled = 1;
+
+err:
+	if (ret)
+		mxsfb_disable_axi_clk(host);
+
+	return ret;
+}
+
+static int mxsfb_init_fbinfo_dt(struct mxsfb_info *host,
+				struct fb_videomode *vmode)
+{
+	struct fb_info *fb_info = &host->fb_info;
+	struct fb_var_screeninfo *var = &fb_info->var;
+	struct device *dev = &host->pdev->dev;
+	struct device_node *np = host->pdev->dev.of_node;
+	struct device_node *display_np;
+	struct videomode vm;
+	u32 width;
+	int ret;
+
+	display_np = of_parse_phandle(np, "display", 0);
+	if (!display_np) {
+		dev_err(dev, "failed to find display phandle\n");
+		return -ENOENT;
+	}
+
+	ret = of_property_read_u32(display_np, "bus-width", &width);
+	if (ret < 0) {
+		dev_err(dev, "failed to get property bus-width\n");
+		goto put_display_node;
+	}
+
+	switch (width) {
+	case 8:
+		host->ld_intf_width = STMLCDIF_8BIT;
+		break;
+	case 16:
+		host->ld_intf_width = STMLCDIF_16BIT;
+		break;
+	case 18:
+		host->ld_intf_width = STMLCDIF_18BIT;
+		break;
+	case 24:
+		host->ld_intf_width = STMLCDIF_24BIT;
+		break;
+	default:
+		dev_err(dev, "invalid bus-width value\n");
+		ret = -EINVAL;
+		goto put_display_node;
+	}
+
+	ret = of_property_read_u32(display_np, "bits-per-pixel",
+				   &var->bits_per_pixel);
+	if (ret < 0) {
+		dev_err(dev, "failed to get property bits-per-pixel\n");
+		goto put_display_node;
+	}
+
+	ret = of_get_videomode(display_np, &vm, OF_USE_NATIVE_MODE);
+	if (ret) {
+		dev_err(dev, "failed to get videomode from DT\n");
+		goto put_display_node;
+	}
+
+	ret = fb_videomode_from_videomode(&vm, vmode);
+	if (ret < 0)
+		goto put_display_node;
+
+	if (vm.flags & DISPLAY_FLAGS_DE_HIGH)
+		host->sync |= MXSFB_SYNC_DATA_ENABLE_HIGH_ACT;
+	if (vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)
+		host->sync |= MXSFB_SYNC_DOTCLK_FALLING_ACT;
+
+put_display_node:
+	of_node_put(display_np);
+	return ret;
+}
+
+static int mxsfb_init_fbinfo(struct mxsfb_info *host,
+			struct fb_videomode *vmode)
+{
+	int ret;
+	struct fb_info *fb_info = &host->fb_info;
+	struct fb_var_screeninfo *var = &fb_info->var;
+	dma_addr_t fb_phys;
+	void *fb_virt;
+	unsigned fb_size;
+
+	fb_info->fbops = &mxsfb_ops;
+	fb_info->flags = FBINFO_FLAG_DEFAULT | FBINFO_READS_FAST;
+	strlcpy(fb_info->fix.id, "mxs", sizeof(fb_info->fix.id));
+	fb_info->fix.type = FB_TYPE_PACKED_PIXELS;
+	fb_info->fix.ypanstep = 1;
+	fb_info->fix.visual = FB_VISUAL_TRUECOLOR,
+	fb_info->fix.accel = FB_ACCEL_NONE;
+
+	ret = mxsfb_init_fbinfo_dt(host, vmode);
+	if (ret)
+		return ret;
+
+	var->nonstd = 0;
+	var->activate = FB_ACTIVATE_NOW;
+	var->accel_flags = 0;
+	var->vmode = FB_VMODE_NONINTERLACED;
+
+	/* Memory allocation for framebuffer */
+	fb_size = SZ_2M;
+	fb_virt = alloc_pages_exact(fb_size, GFP_DMA);
+	if (!fb_virt)
+		return -ENOMEM;
+
+	fb_phys = virt_to_phys(fb_virt);
+
+	fb_info->fix.smem_start = fb_phys;
+	fb_info->screen_base = fb_virt;
+	fb_info->screen_size = fb_info->fix.smem_len = fb_size;
+
+	if (mxsfb_restore_mode(host, vmode))
+		memset(fb_virt, 0, fb_size);
+
+	return 0;
+}
+
+static void mxsfb_free_videomem(struct mxsfb_info *host)
+{
+	struct fb_info *fb_info = &host->fb_info;
+
+	free_pages_exact(fb_info->screen_base, fb_info->fix.smem_len);
+}
+
+static const struct platform_device_id mxsfb_devtype[] = {
+	{
+		.name = "imx6ul-fb",
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(platform, mxsfb_devtype);
+
+static const struct of_device_id mxsfb_dt_ids[] = {
+	{ .compatible = "fsl,imx6ul-lcdif", .data = &mxsfb_devtype, },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, mxsfb_dt_ids);
+
+/** Used for control and initialize the display */
+static struct spi_board_info spi_if;
+
+static int mxsfb_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id =
+			of_match_device(mxsfb_dt_ids, &pdev->dev);
+	struct resource *res;
+	struct mxsfb_info *host;
+	struct fb_info *fb_info;
+	struct fb_videomode *mode;
+#if defined (DO_REGISTER_SPI_DEVICE)
+	struct spi_board_info *spi = &spi_if;
+#endif
+	int ret;
+
+	if (of_id)
+		pdev->id_entry = of_id->data;
+
+	fb_info = framebuffer_alloc(sizeof(struct mxsfb_info), &pdev->dev);
+	if (!fb_info) {
+		dev_err(&pdev->dev, "Failed to allocate fbdev\n");
+		return -ENOMEM;
+	}
+
+	mode = devm_kzalloc(&pdev->dev, sizeof(struct fb_videomode),
+			GFP_KERNEL);
+	if (mode == NULL)
+		return -ENOMEM;
+
+	host = to_imxfb_host(fb_info);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	host->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(host->base)) {
+		ret = PTR_ERR(host->base);
+		goto fb_release;
+	}
+
+	host->pdev = pdev;
+	platform_set_drvdata(pdev, host);
+
+	host->devdata = &mxsfb_devdata;
+
+#if defined (GPIO_LCDIF_RESET)
+	ret = gpio_request_one(GPIO_LCDIF_RESET, GPIOF_OUT_INIT_LOW, "st7789v_reset");
+	if (ret) {
+		dev_err(&host->pdev->dev, "Failed to get the reset pin\n");
+		return ret;
+	}
+	/* Generate display reset sequence */
+	gpio_set_value(host->gpio_reset, 1);
+	mdelay(1);
+	gpio_set_value(host->gpio_reset, 0);
+	mdelay(10);
+	gpio_set_value(host->gpio_reset, 1);
+#endif
+#if defined (DO_REGISTER_SPI_DEVICE)
+	/* Fill SPI information to board info struct */
+	strncpy(spi->modalias, SPI_DRIVER_NAME, SPI_NAME_SIZE);
+	spi->chip_select = (u16)SPI_DISP_CS;
+	spi->bus_num = (u16)SPI_BUS;
+	spi->max_speed_hz = (u32)SPI_BUS_SPEED;
+	spi->mode = SPI_MODE_0;
+	spi->controller_data = (void *)fb_info;
+	/* Registrer new device */
+	dev_dbg(&pdev->dev, "Registering SPI device: %s", spi->modalias);
+	ret = spi_register_board_info(spi, 1);
+
+	if (ret) {
+		pr_err("failed to register SPI device\n");
+		return ret;
+	} else {
+		dev_dbg(&pdev->dev, "Successfully registered SPI device");
+	}
+#endif
+	host->clk = devm_clk_get(&host->pdev->dev, NULL);
+	if (IS_ERR(host->clk)) {
+		ret = PTR_ERR(host->clk);
+		goto fb_release;
+	}
+
+	host->clk_axi = devm_clk_get(&host->pdev->dev, "axi");
+	if (IS_ERR(host->clk_axi))
+		host->clk_axi = NULL;
+
+	host->clk_disp_axi = devm_clk_get(&host->pdev->dev, "disp_axi");
+	if (IS_ERR(host->clk_disp_axi))
+		host->clk_disp_axi = NULL;
+
+	host->reg_lcd = devm_regulator_get(&pdev->dev, "lcd");
+	if (IS_ERR(host->reg_lcd))
+		host->reg_lcd = NULL;
+
+	fb_info->pseudo_palette = devm_kzalloc(&pdev->dev, sizeof(u32) * 16,
+					       GFP_KERNEL);
+	if (!fb_info->pseudo_palette) {
+		ret = -ENOMEM;
+		goto fb_release;
+	}
+
+	ret = mxsfb_init_fbinfo(host, mode);
+	if (ret != 0)
+		goto fb_release;
+
+	fb_videomode_to_var(&fb_info->var, mode);
+
+	/* init the color fields */
+	mxsfb_check_var(&fb_info->var, fb_info);
+#if defined (DO_LCDIF_PAN)
+	fb_info->var.xoffset = 0;
+	fb_info->var.yoffset = 0;
+	/* mxsfb_pan_display(&fb_info->var, fb_info); */
+#endif
+
+	platform_set_drvdata(pdev, fb_info);
+
+	ret = register_framebuffer(fb_info);
+	if (ret != 0) {
+		dev_err(&pdev->dev,"Failed to register framebuffer\n");
+		goto fb_destroy;
+	}
+
+	if (!host->enabled) {
+		mxsfb_enable_axi_clk(host);
+		writel(0, host->base + LCDC_CTRL);
+		mxsfb_disable_axi_clk(host);
+		mxsfb_set_par(fb_info);
+		mxsfb_enable_controller(fb_info);
+	}
+	dev_info(&pdev->dev, "initialized\n");
+
+	return 0;
+
+fb_destroy:
+	if (host->enabled)
+		clk_disable_unprepare(host->clk);
+fb_release:
+	framebuffer_release(fb_info);
+
+	return ret;
+}
+
+static int mxsfb_remove(struct platform_device *pdev)
+{
+	struct fb_info *fb_info = platform_get_drvdata(pdev);
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+
+	if (host->enabled)
+		mxsfb_disable_controller(fb_info);
+
+	unregister_framebuffer(fb_info);
+	mxsfb_free_videomem(host);
+
+	framebuffer_release(fb_info);
+
+	return 0;
+}
+
+static void mxsfb_shutdown(struct platform_device *pdev)
+{
+	struct fb_info *fb_info = platform_get_drvdata(pdev);
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+
+	mxsfb_enable_axi_clk(host);
+
+	/*
+	 * Force stop the LCD controller as keeping it running during reboot
+	 * might interfere with the BootROM's boot mode pads sampling.
+	 */
+	writel(CTRL_RUN, host->base + LCDC_CTRL + REG_CLR);
+
+	mxsfb_disable_axi_clk(host);
+}
+
+static struct platform_driver mxsfb_driver = {
+	.probe = mxsfb_probe,
+	.remove = mxsfb_remove,
+	.shutdown = mxsfb_shutdown,
+	.id_table = mxsfb_devtype,
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .of_match_table = mxsfb_dt_ids,
+	},
+};
+
+module_platform_driver(mxsfb_driver);
+
+MODULE_DESCRIPTION("Freescale mxs framebuffer driver");
+MODULE_AUTHOR("Christian Duenki, Escatec Switzerland AG");
+MODULE_LICENSE("GPL");
diff --git a/drivers/stromer/fb_imx6_st7789_spi.c b/drivers/stromer/fb_imx6_st7789_spi.c
new file mode 100644
index 0000000..a18f6e4
--- /dev/null
+++ b/drivers/stromer/fb_imx6_st7789_spi.c
@@ -0,0 +1,472 @@
+/*
+ * Copyright (C) 2017 Christian Duenki, Escatec Switzerland AG
+ *
+ * This driver is inspired by:
+ *   fbtft, Copyright (C) 2013 Noralf Tronnes
+ *   fb_st7789v, Copyright (C) 2015 Dennis Menschel
+ */
+
+#include "fb_imx6.h"
+
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <video/mipi_display.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+
+#define DEFAULT_GAMMA \
+	"70 2C 2E 15 10 09 48 33 53 0B 19 18 20 25\n" \
+	"70 2C 2E 15 10 09 48 33 53 0B 19 18 20 25"
+
+/**
+ * enum st7789v_command - ST7789V display controller commands
+ *
+ * @PORCTRL: porch setting
+ * @GCTRL: gate control
+ * @VCOMS: VCOM setting
+ * @VDVVRHEN: VDV and VRH command enable
+ * @VRHS: VRH set
+ * @VDVS: VDV set
+ * @VCMOFSET: VCOM offset set
+ * @PWCTRL1: power control 1
+ * @PVGAMCTRL: positive voltage gamma control
+ * @NVGAMCTRL: negative voltage gamma control
+ *
+ * The command names are the same as those found in the datasheet to ease
+ * looking up their semantics and usage.
+ *
+ * Note that the ST7789V display controller offers quite a few more commands
+ * which have been omitted from this list as they are not used at the moment.
+ * Furthermore, commands that are compliant with the MIPI DCS have been left
+ * out as well to avoid duplicate entries.
+ */
+
+enum st7789v_command {
+	RAMWR = 0x2C,
+	RAMCTRL = 0xB0,
+	RGBCTRL = 0xB1,
+	PORCTRL = 0xB2,
+	GCTRL = 0xB7,
+	VCOMS = 0xBB,
+	LCMCTRL = 0xC0,
+	VDVVRHEN = 0xC2,
+	VRHS = 0xC3,
+	VDVS = 0xC4,
+	VCMOFSET = 0xC5,
+	FRCTRL2 = 0xC6,
+	PWCTRL1 = 0xD0,
+	PVGAMCTRL = 0xE0,
+	NVGAMCTRL = 0xE1,
+};
+
+struct st7789_driver_par {
+	struct spi_device *spi;
+	struct fb_info *p_fb_info;
+#if defined (GPIO_SPI_RESET)
+	int gpio_reset;
+#endif
+	u8 *buf;
+};
+
+#define MADCTL_BGR BIT(3) /* bitmask for RGB/BGR order */
+#define MADCTL_MV BIT(5) /* bitmask for page/column order */
+#define MADCTL_MX BIT(6) /* bitmask for column address order */
+#define MADCTL_MY BIT(7) /* bitmask for page address order */
+
+extern void mxsfb_enable_controller(struct fb_info *fb_info);
+extern void mxsfb_disable_controller(struct fb_info *fb_info);
+extern int mxsfb_pan_display(struct fb_var_screeninfo *var,
+							 struct fb_info *fb_info);
+
+void st7789_write_register(int len, ...);
+int st7789_write_spi(void *buf, size_t len);
+int st7789_trx_spi(void *buf_out, void *buf_in, size_t trx_len);
+int st7789_init_display(void);
+
+/** Local driver information */
+static struct st7789_driver_par disp;
+
+void st7789_write_register(int len, ...)
+{
+	va_list args;
+	u16 *buf = NULL;
+	int res, cnt = 0;
+
+	buf = (u16*)kmalloc((size_t)(len * sizeof(u16)), GFP_NOIO);
+
+	va_start(args, len);
+	for (cnt = 0; cnt < len; cnt++) {
+		buf[cnt] = (u16)(((u16)va_arg(args, unsigned int) & 0x00ff) | 0x0100);
+	}
+	va_end(args);
+
+	/* Set data(!command) bit of forst byte */
+	buf[0] &= 0x00ff;
+#if defined (DEBUG)
+	pr_debug("SPI Data: 0x%04x", buf[0]);
+	for (cnt = 1; cnt < len; cnt++) {
+		pr_debug(", 0x%04x", buf[cnt]);
+	}
+	pr_debug("\n");
+#endif
+
+	res = st7789_write_spi(buf, (size_t)(sizeof(u16) * len));
+
+	kfree(buf);
+
+	return;
+}
+
+/**
+ * @brief Transmit spi messages to the stromer-display
+ *
+ * @param buf[in] Data to be sent
+ * @param len[in] Length of message
+ * @return Success
+ */
+int st7789_write_spi(void *buf, size_t len)
+{
+	struct spi_device *spi = disp.spi;
+	struct spi_message m;
+	struct spi_transfer t = {
+		.tx_buf = buf,
+		.len = len,
+	};
+
+	if (!spi) {
+		pr_err("%s: spi is unexpectedly NULL\n", __func__);
+		return PTR_ERR(spi);
+	}
+
+	spi_message_init(&m);
+
+	spi_message_add_tail(&t, &m);
+	return spi_sync(spi, &m);
+}
+/* EXPORT_SYMBOL(st7789_write_spi); */
+
+/**
+ * @brief Transmit and receive spi messages
+ *
+ * @param buf_out[in] Buffer containing data to be sent
+ * @param buf_in[out] Buffer to store received data
+ * @param trx_len[in] Length of transmitt and receive (sum)
+ * @return zero on success, else a negative error code
+ */
+int st7789_trx_spi(void *buf_out, void *buf_in,
+				   size_t trx_len)
+{
+	struct spi_device *spi = disp.spi;
+	struct spi_message m;
+	struct spi_transfer t = {
+		.tx_buf = buf_out,
+		.rx_buf = buf_in,
+		.len = trx_len,
+	};
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+
+	return spi_sync(spi, &m);
+}
+/* EXPORT_SYMBOL(st7789_trx_spi); */
+
+#if 0
+/**
+ * blank() - blank the display
+ *
+ * @on: whether to enable or disable blanking the display
+ *
+ * Return: 0 on success, < 0 if error occurred.
+ */
+static int st7789_spi_blank(bool on)
+{
+	if (on)
+		st7789_write_reg(MIPI_DCS_SET_DISPLAY_OFF);
+	else
+		st7789_write_reg(MIPI_DCS_SET_DISPLAY_ON);
+	return 0;
+}
+/* EXPORT_SYMBOL(st7789_spi_blank); */
+#endif
+
+/**
+ * init_display() - initialize the display controller
+ *
+ * Most of the commands in this init function set their parameters to the
+ * same default values which are already in place after the display has been
+ * powered up. (The main exception to this rule is the pixel format which
+ * would default to 18 instead of 16 bit per pixel.)
+ * Nonetheless, this sequence can be used as a template for concrete
+ * displays which usually need some adjustments.
+ *
+ * Return: 0 on success, < 0 if error occurred.
+ */
+int st7789_init_display(void)
+{
+#if defined (GPIO_SPI_RESET)
+	/* Apply reset sequence */
+	if (gpio_is_valid(disp.gpio_reset)) {
+		/* dummy write to activate spi lines */
+		st7789_write_reg(MIPI_DCS_EXIT_SLEEP_MODE);
+
+		/* Apply clean reset sequence */
+		gpio_set_value(disp.gpio_reset, 1);
+		pr_debug("Set Display reset\n");
+		mdelay(1);
+		gpio_set_value(disp.gpio_reset, 0);
+		pr_debug("Clear Display reset\n");
+		mdelay(10);
+		gpio_set_value(disp.gpio_reset, 1);
+		pr_debug("Set Display reset\n");
+		mdelay(120);
+	}
+#endif
+	/* turn off sleep mode */
+	st7789_write_reg(MIPI_DCS_EXIT_SLEEP_MODE);
+	mdelay(120);
+
+	/* Memory data access contrl */
+	st7789_write_reg(MIPI_DCS_SET_ADDRESS_MODE, 0x00);
+
+	/* Porch settings */
+	st7789_write_reg(PORCTRL, 0x0c, 0x0c, 0x00,  0x33, 0x33);
+
+	/* Gate control
+	 * VGH = 13.26V
+	 * VGL = -10.43V
+	 */
+	st7789_write_reg(GCTRL, 0x35);
+
+	/* VCOM = 1.175 V */
+	st7789_write_reg(VCOMS, 0x2B);
+
+	/* LCMCTRL */
+	st7789_write_reg(LCMCTRL, 0x2C);
+
+	/*
+	 * VDV and VRH register values come from command write
+	 * (instead of NVM)
+	 */
+	st7789_write_reg(VDVVRHEN, 0x01);
+
+	/*
+	 * VAP =  4.1V + (VCOM + VCOM offset + 0.5 * VDV)
+	 * VAN = -4.1V + (VCOM + VCOM offset + 0.5 * VDV)
+	 */
+	st7789_write_reg(VRHS, 0x20);
+
+	/* VDV = 0V */
+	st7789_write_reg(VDVS, 0x20);
+
+	/* Frame rate control */
+	st7789_write_reg(FRCTRL2, 0x0F);
+
+	/*
+	 * AVDD = 6.8V
+	 * AVCL = -4.8V
+	 * VDS = 2.3V
+	 */
+	st7789_write_reg(PWCTRL1, 0xA4, 0xA1);
+
+	/* Positive voltage gamma control */
+	st7789_write_reg(PVGAMCTRL, 0xD0, 0xCA, 0xE0, 0x08, 0x09, 0x07, 0x2D, 0x3B,
+					 0x3D, 0x34, 0x0A, 0x0A, 0x1B, 0x28);
+
+	/* Negative voltage gamma control */
+	st7789_write_reg(NVGAMCTRL, 0xD0, 0xCA, 0x0F, 0x08, 0x08, 0x07, 0x2E, 0x5C,
+					 0X40, 0x34, 0x09, 0x0B, 0x1B, 0x28);
+
+	/* st7789_write_reg(MIPI_DCS_ENTER_INVERT_MODE); */
+
+	/* RAM control */
+	st7789_write_reg(RAMCTRL, 0x11, 0x00, 0x00);
+
+	/* RGB Interface control */
+	st7789_write_reg(RGBCTRL, 0x40, 0x04, 0x0A);
+
+	/* set pixel format to RGB-565 */
+	st7789_write_reg(MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
+
+	/* Frame rate control */
+	st7789_write_reg(MIPI_DCS_SET_COLUMN_ADDRESS, 0x00, 0x00, 0x00, 0xEF);
+	/* st7789_write_reg(MIPI_DCS_SET_COLUMN_ADDRESS, 0x00, 0x00, 0x01, 0x3F); */
+
+	/* Display function control */
+	st7789_write_reg(MIPI_DCS_SET_PAGE_ADDRESS, 0x00, 0x00, 0x01, 0x3F);
+	/* st7789_write_reg(MIPI_DCS_SET_PAGE_ADDRESS, 0x00, 0x00, 0x00, 0xEF); */
+
+	/* Display on */
+	st7789_write_reg(MIPI_DCS_SET_DISPLAY_ON);
+
+	/* Memory write control */
+	st7789_write_reg(RAMWR);
+
+	pr_debug("Display init done...\n");
+
+	return 0;
+}
+/* EXPORT_SYMBOL(st7789_init_display); */
+
+#if 0
+/**
+ * set_gamma() - set gamma curves
+ *
+ * @curves: gamma curves
+ *
+ * Before the gamma curves are applied, they are preprocessed with a bitmask
+ * to ensure syntactically correct input for the display controller.
+ * This implies that the curves input parameter might be changed by this
+ * function and that illegal gamma values are auto-corrected and not
+ * reported as errors.
+ *
+ * Return: 0 on success, < 0 if error occurred.
+ */
+static int set_gamma(unsigned long *curves)
+{
+	/* int i; */
+	/* int j; */
+	/* int c; /\* curve index offset *\/ */
+
+	/* /\* */
+	/*  * Bitmasks for gamma curve command parameters. */
+	/*  * The masks are the same for both positive and negative voltage */
+	/*  * gamma curves. */
+	/*  *\/ */
+	/* const u8 gamma_par_mask[] = { */
+	/* 	0xFF, /\* V63[3:0], V0[3:0]*\/ */
+	/* 	0x3F, /\* V1[5:0] *\/ */
+	/* 	0x3F, /\* V2[5:0] *\/ */
+	/* 	0x1F, /\* V4[4:0] *\/ */
+	/* 	0x1F, /\* V6[4:0] *\/ */
+	/* 	0x3F, /\* J0[1:0], V13[3:0] *\/ */
+	/* 	0x7F, /\* V20[6:0] *\/ */
+	/* 	0x77, /\* V36[2:0], V27[2:0] *\/ */
+	/* 	0x7F, /\* V43[6:0] *\/ */
+	/* 	0x3F, /\* J1[1:0], V50[3:0] *\/ */
+	/* 	0x1F, /\* V57[4:0] *\/ */
+	/* 	0x1F, /\* V59[4:0] *\/ */
+	/* 	0x3F, /\* V61[5:0] *\/ */
+	/* 	0x3F, /\* V62[5:0] *\/ */
+	/* }; */
+
+	/* for (i = 0; i < par->gamma.num_curves; i++) { */
+	/* 	c = i * par->gamma.num_values; */
+	/* 	for (j = 0; j < par->gamma.num_values; j++) */
+	/* 		curves[c + j] &= gamma_par_mask[j]; */
+	/* 	st7789_write_reg( */
+	/* 		par, PVGAMCTRL + i, */
+	/* 		curves[c + 0], curves[c + 1], curves[c + 2], */
+	/* 		curves[c + 3], curves[c + 4], curves[c + 5], */
+	/* 		curves[c + 6], curves[c + 7], curves[c + 8], */
+	/* 		curves[c + 9], curves[c + 10], curves[c + 11], */
+	/* 		curves[c + 12], curves[c + 13]); */
+	/* } */
+	return 0;
+}
+#endif
+
+int st7789_probe_spi(struct spi_device *spi)
+{
+	int ret = 0;
+	struct fb_info *fb_info;
+#if defined (DO_SPI_PAN)
+	struct fb_var_screeninfo *var;
+#endif
+	if (NULL == spi) {
+		return PTR_ERR(spi);
+	}
+
+	/* dev_dbg(spi, "Probing STROMER-ST7789v device"); */
+	pr_debug("Probing STROMER-ST7789v device");
+
+	/* store spi device locally */
+	disp.spi = spi;
+	/* Set mode to 9-Bit */
+	spi->bits_per_word = 9;
+#if defined (GPIO_SPI_RESET)
+	/* Try getting the reset pin */
+	ret = gpio_request_one(GPIO_SPI_RESET, GPIOF_OUT_INIT_LOW, "st7789v_reset");
+	if (ret) {
+		pr_debug("Failed to get the reset pin");
+		return ret;
+	}
+	disp.gpio_reset = GPIO_SPI_RESET;
+#endif
+
+	/* Disable lcdif during initialization */
+	if (!spi->controller_data) {
+		pr_err("No LCDIF controller data!\n");
+		return -1;
+	}
+#if defined (DO_SPI_INIT_SEQUENCE)
+	fb_info = (struct fb_info *)spi->controller_data;
+	mxsfb_disable_controller(fb_info);
+	/* Init and configure display */
+	pr_debug("Configuring display...\n");
+	ret = st7789_init_display();
+ #if defined (DO_SPI_PAN)
+	pr_debug("Do panning\n");
+	var = &(fb_info->var);
+
+	var->xoffset = 0;
+	var->yoffset = 0;
+	mxsfb_pan_display(var, fb_info);
+ #endif
+	mxsfb_enable_controller(fb_info);
+#endif
+	return ret;
+}
+
+int st7789_remove_spi(struct spi_device *spi)
+{
+	/* ToDo! */
+	return 0;
+}
+
+static const struct of_device_id dt_ids[] = {
+	{ .compatible = "st7789v" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, dt_ids);
+
+static struct spi_driver st7789_driver_spi_driver = {
+	.driver = {
+		.name   = "st7789v",
+		/* .of_match_table = of_match_ptr(dt_ids), */
+		.owner = THIS_MODULE,
+	},
+	.probe  = st7789_probe_spi,
+	.remove = st7789_remove_spi,
+};
+
+static int __init st7789_driver_module_init(void)
+{
+	int ret;
+
+	ret = spi_register_driver(&st7789_driver_spi_driver);
+
+	return ret;
+}
+
+static void __exit st7789_driver_module_exit(void)
+{
+	spi_unregister_driver(&st7789_driver_spi_driver);
+}
+
+module_init(st7789_driver_module_init);
+module_exit(st7789_driver_module_exit);
+
+MODULE_ALIAS("spi:" SPI_DRIVER_NAME);
+MODULE_ALIAS("platform:" SPI_DRIVER_NAME);
+MODULE_ALIAS("spi:st7789v");
+MODULE_ALIAS(SPI_DRIVER_NAME);
+
+MODULE_DESCRIPTION("SPI driver for the ST7789V LCD Controller");
+MODULE_AUTHOR("Christian Duenki");
+MODULE_LICENSE("GPL");
diff --git a/drivers/stromer/ili2116.c b/drivers/stromer/ili2116.c
new file mode 100644
index 0000000..ae5014c
--- /dev/null
+++ b/drivers/stromer/ili2116.c
@@ -0,0 +1,469 @@
+#define DEBUG
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/device.h>
+#include "ili2116.h"
+
+#define MAX_TOUCHES		10
+#define DEFAULT_POLL_PERIOD	20
+
+/* Touchscreen commands */
+#define REG_TOUCHDATA		0x10
+#define REG_TOUCH_REPORT    0x11
+#define REG_PANEL_INFO		0x20
+#define REG_FIRMWARE_VERSION	0x40
+#define REG_PROTOCOL_VERSION	0x42
+#define REG_CALIBRATE		0xcc
+
+struct finger {
+	u8 x_low;
+	u8 x_high;
+	u8 y_low;
+	u8 y_high;
+} __packed;
+
+struct finger_read {
+	u8 status;
+	u8 x_high;
+	u8 x_low;
+	u8 y_high;
+	u8 y_low;
+} __packed;
+
+struct touchdata {
+	u8 status;
+	struct finger_read finger[MAX_TOUCHES];
+} __packed;
+
+struct panel_info {
+	/* struct panel_info_finger finger_max; */
+	struct finger finger_max;
+	u8 xchannel_num;
+	u8 ychannel_num;
+	u8 max_report_points;
+	u8 channel_num;
+} __packed;
+
+struct firmware_version {
+	u8 id;
+	u8 major;
+	u8 minor;
+} __packed;
+
+struct protocol_vesion {
+	u8 major;
+	u8 minor;
+	u8 release;
+} __packed;
+
+struct ili2116 {
+	struct i2c_client *client;
+	struct input_dev *input;
+	int gpio_pendown;
+	bool (*get_pendown_state)(struct ili2116 *priv);
+	unsigned int poll_period;
+	unsigned int max_channels;
+	struct delayed_work dwork;
+};
+
+static int ili2116_read_reg(struct i2c_client *client, u8 reg, void *buf,
+			    size_t len)
+{
+	struct i2c_msg msg[2] = {
+		{
+			.addr	= client->addr,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= &reg,
+		},
+		{
+			.addr	= client->addr,
+			.flags	= I2C_M_RD,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+
+	if (i2c_transfer(client->adapter, msg, 2) != 2) {
+		dev_err(&client->dev, "i2c transfer failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void ili2116_report_events(struct input_dev *input,
+								  const struct touchdata *touchdata,
+								  unsigned int num_of_events,
+								  unsigned int num_of_max_events)
+{
+	int i;
+	bool touch;
+	unsigned int x, y;
+	const struct finger_read *finger;
+
+	for (i = 0; i < num_of_max_events; i++) {
+		input_mt_slot(input, i);
+
+		if (i < num_of_events) {
+			finger = &(touchdata->finger)[i];
+			touch = ((finger->status & 0xC0) == 0x80);
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
+			if (touch) {
+				x = finger->x_low | (finger->x_high << 8);
+				y = finger->y_low | (finger->y_high << 8);
+
+				input_report_abs(input, ABS_MT_POSITION_X, x);
+				input_report_abs(input, ABS_MT_POSITION_Y, y);
+			}
+		} else {
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, false);
+		}
+		input_mt_report_pointer_emulation(input, false);
+	}
+
+	input_sync(input);
+}
+
+static void ili2116_work(struct work_struct *work)
+{
+	struct ili2116 *priv = container_of(work, struct ili2116,
+					    dwork.work);
+	struct i2c_client *client = priv->client;
+	struct touchdata touchdata;
+	int error;
+	int cnt;
+
+	error = ili2116_read_reg(client, REG_TOUCHDATA,
+				 &touchdata.status, sizeof(touchdata.status));
+	if (error) {
+		dev_err(&client->dev,
+			"Unable to get touch report, err = %d\n", error);
+		return;
+	}
+	for (cnt = 0; cnt < touchdata.status; cnt++) {
+		error = ili2116_read_reg(client, REG_TOUCH_REPORT,
+								 &touchdata.finger[cnt], sizeof(struct finger_read));
+		if (error) {
+			dev_err(&client->dev,
+					"Unable to get touch report, err = %d\n", error);
+			return;
+		}
+		if (cnt >= MAX_TOUCHES) {
+			break;
+		}
+	}
+
+	ili2116_report_events(priv->input, &touchdata,
+						  touchdata.status, priv->max_channels);
+
+	if ((touchdata.status > 0) || priv->get_pendown_state(priv)) {
+		schedule_delayed_work(&priv->dwork,
+				      msecs_to_jiffies(priv->poll_period));
+	}
+}
+
+static irqreturn_t ili2116_irq(int irq, void *irq_data)
+{
+	struct ili2116 *priv = irq_data;
+
+	schedule_delayed_work(&priv->dwork, 0);
+
+	return IRQ_HANDLED;
+}
+
+static ssize_t ili2116_calibrate(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili2116 *priv = i2c_get_clientdata(client);
+	unsigned long calibrate;
+	int rc;
+	u8 cmd = REG_CALIBRATE;
+
+	if (kstrtoul(buf, 10, &calibrate))
+		return -EINVAL;
+
+	if (calibrate > 1)
+		return -EINVAL;
+
+	if (calibrate) {
+		rc = i2c_master_send(priv->client, &cmd, sizeof(cmd));
+		if (rc != sizeof(cmd))
+			return -EIO;
+	}
+
+	return count;
+}
+static DEVICE_ATTR(calibrate, S_IWUSR, NULL, ili2116_calibrate);
+
+static struct attribute *ili2116_attributes[] = {
+	&dev_attr_calibrate.attr,
+	NULL,
+};
+
+static const struct attribute_group ili2116_attr_group = {
+	.attrs = ili2116_attributes,
+};
+
+static bool ili2116_get_pendown_state(struct ili2116 *priv)
+{
+	bool state = false;
+
+	if (!gpio_get_value(priv->gpio_pendown)) {
+		state = true;
+	}
+
+	return state;
+}
+
+static int ili2116_setup_pendown(struct device *dev,
+				 struct ili2116 *priv)
+{
+	int err;
+
+	err = gpio_request_one(priv->gpio_pendown, GPIOF_IN,
+				       "ili2116_pendown");
+	if (err) {
+		dev_err(dev,
+				"failed to request/setup pendown GPIO%d: %d\n",
+				priv->gpio_pendown, err);
+		return err;
+	}
+
+	return 0;
+}
+
+static int ili2116_i2c_probe(struct i2c_client *client,
+				       const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	const struct ili2116_platform_data *pdata = dev_get_platdata(dev);
+	struct ili2116 *priv;
+	struct input_dev *input;
+	struct panel_info panel;
+	struct protocol_vesion protocol;
+	struct firmware_version firmware;
+	int xmax, ymax;
+	int error;
+	int oftree = 0;
+	dev_dbg(dev, "Probing for ILI2116 I2C Touschreen driver");
+
+	if (!pdata) {
+		dev_err(dev, "No platform data, switching to device tree\n");
+		oftree = 1;
+		/* return -EINVAL; */
+	}
+
+	if (client->irq <= 0) {
+		dev_err(dev, "No IRQ!\n");
+		return -EINVAL;
+	}
+
+	/* Get firmware version */
+	dev_dbg(dev, "Try to read firmware version...");
+	error = ili2116_read_reg(client, REG_FIRMWARE_VERSION,
+				 &firmware, sizeof(firmware));
+	if (error) {
+		dev_err(dev, "Failed to get firmware version, err: %d\n",
+			error);
+		return error;
+	} else {
+			dev_dbg(dev, "Read firmware version");
+	}
+
+	/* get panel info */
+	dev_dbg(dev, "Try to read panel info...");
+	error = ili2116_read_reg(client, REG_PANEL_INFO, &panel, sizeof(panel));
+	if (error) {
+		dev_err(dev, "Failed to get panel information, err: %d\n",
+			error);
+		return error;
+	} else {
+			dev_dbg(dev, "Read panel infos");
+	}
+
+	/* get panel protocol version */
+	dev_dbg(dev, "Try to read protocol version...");
+	error = ili2116_read_reg(client, REG_PROTOCOL_VERSION, &protocol, sizeof(protocol));
+	if (error) {
+		dev_err(dev, "Failed to get panel protocol version, err: %d\n",	error);
+		return error;
+	} else {
+		dev_dbg(dev, "Read panel protocol version 0x%02x 0x%02x 0x%02xh",
+				protocol.major, protocol.minor, protocol.release);
+	}
+
+	xmax = panel.finger_max.x_low | (panel.finger_max.x_high << 8);
+	ymax = panel.finger_max.y_low | (panel.finger_max.y_high << 8);
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	input = input_allocate_device();
+	if (!priv || !input) {
+		error = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	if (oftree) {
+		priv->gpio_pendown = of_get_named_gpio(dev->of_node, "pendown-gpio", 0);
+		if (100 < priv->gpio_pendown) {
+			dev_err(dev, "Unable to read pendown-gpio from device tree\n");
+			return -EINVAL;
+		} else {
+			dev_dbg(dev, "Got Pendown gpio: %d from device tree", priv->gpio_pendown);
+		}
+	}
+	error = ili2116_setup_pendown(dev, priv);
+
+	priv->client = client;
+	priv->input = input;
+	priv->get_pendown_state = ili2116_get_pendown_state;
+	priv->poll_period = DEFAULT_POLL_PERIOD;
+	INIT_DELAYED_WORK(&priv->dwork, ili2116_work);
+
+	/* Setup input device */
+	input->name = "Ili2116 Touchscreen";
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = dev;
+
+	__set_bit(EV_SYN, input->evbit);
+	__set_bit(EV_KEY, input->evbit);
+	__set_bit(EV_ABS, input->evbit);
+	__set_bit(BTN_TOUCH, input->keybit);
+
+	/* Single touch */
+	input_set_abs_params(input, ABS_X, 0, xmax, 0, 0);
+	input_set_abs_params(input, ABS_Y, 0, ymax, 0, 0);
+
+	/* Multi touch */
+	input_mt_init_slots(input, (unsigned int)panel.max_report_points, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_X, 0, xmax, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, ymax, 0, 0);
+
+	/* Add data to private struct */
+	priv->max_channels = panel.max_report_points;
+
+	input_set_drvdata(input, priv);
+	i2c_set_clientdata(client, priv);
+
+	error = request_irq(client->irq, ili2116_irq, (IRQF_TRIGGER_FALLING | IRQF_ONESHOT),
+			    client->name, priv);
+	if (error) {
+		dev_err(dev, "Unable to request touchscreen IRQ, err: %d\n",
+			error);
+		goto err_free_mem;
+	}
+
+	error = sysfs_create_group(&dev->kobj, &ili2116_attr_group);
+	if (error) {
+		dev_err(dev, "Unable to create sysfs attributes, err: %d\n",
+			error);
+		goto err_free_irq;
+	}
+
+	error = input_register_device(priv->input);
+	if (error) {
+		dev_err(dev, "Cannot register input device, err: %d\n", error);
+		goto err_remove_sysfs;
+	}
+
+	device_init_wakeup(&client->dev, 1);
+
+	dev_dbg(dev,
+		"Ili2116 initialized (IRQ: %d), firmware version %d.%d.%d",
+		client->irq, firmware.id, firmware.major, firmware.minor);
+
+	return 0;
+
+err_remove_sysfs:
+	sysfs_remove_group(&dev->kobj, &ili2116_attr_group);
+err_free_irq:
+	free_irq(client->irq, priv);
+err_free_mem:
+	input_free_device(input);
+	kfree(priv);
+	return error;
+}
+
+static int ili2116_i2c_remove(struct i2c_client *client)
+{
+	struct ili2116 *priv = i2c_get_clientdata(client);
+
+	gpio_free(priv->gpio_pendown);
+	sysfs_remove_group(&client->dev.kobj, &ili2116_attr_group);
+	free_irq(priv->client->irq, priv);
+	cancel_delayed_work_sync(&priv->dwork);
+	input_unregister_device(priv->input);
+	kfree(priv);
+
+	return 0;
+}
+
+static int __maybe_unused ili2116_i2c_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (device_may_wakeup(&client->dev))
+		enable_irq_wake(client->irq);
+
+	return 0;
+}
+
+static int __maybe_unused ili2116_i2c_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (device_may_wakeup(&client->dev))
+		disable_irq_wake(client->irq);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(ili2116_i2c_pm,
+			 ili2116_i2c_suspend, ili2116_i2c_resume);
+
+static const struct ili2116_platform_data stromer_ili2116 = {
+	.irq_flags = (IRQF_TRIGGER_FALLING | IRQF_ONESHOT),
+	.poll_period = DEFAULT_POLL_PERIOD,
+};
+
+static const struct i2c_device_id ili2116_i2c_id[] = {
+	{ .name="stromer-ili2116", .driver_data = (long)&stromer_ili2116 },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(i2c, ili2116_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id ili2116_of_match[] = {
+	{ .compatible = "stromer-ili2116", .data = &stromer_ili2116 },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ili2116_of_match);
+#endif
+
+static struct i2c_driver ili2116_ts_driver = {
+	.driver = {
+		.name = "stromer-ili2116",
+		.pm = &ili2116_i2c_pm,
+	},
+	.id_table = ili2116_i2c_id,
+	.probe = ili2116_i2c_probe,
+	.remove = ili2116_i2c_remove,
+};
+
+module_i2c_driver(ili2116_ts_driver);
+
+MODULE_AUTHOR("Christian Duenki <christian.duenki@escatec.com>");
+MODULE_DESCRIPTION("ILI2116 I2C Touchscreen Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/stromer/ili2116.h b/drivers/stromer/ili2116.h
new file mode 100644
index 0000000..dad4765
--- /dev/null
+++ b/drivers/stromer/ili2116.h
@@ -0,0 +1,11 @@
+#ifndef _ILI2116_H
+#define _ILI2116_H
+
+/* struct ili2116_platform_data { */
+struct ili2116_platform_data {
+	unsigned long irq_flags;
+	unsigned int poll_period;
+	bool (*get_pendown_state)(void);
+};
+
+#endif
